<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础知识介绍]]></title>
    <url>%2F2018%2F07%2F09%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Java的基础知识大概是一年前看的吧，现在忘了啥啥不认识。。GitHub找到一个开源仓库，作者也做了Gitbook，但是体验不好，网页时长崩溃。故引用至此，原项目地址：https://github.com/JackChan1999/Java_Basic_Introduction 第1章 ava开发入门Java概述1. 计算机基础知识1.1 计算机计算机（Computer）全称：电子计算机，俗称电脑。是一种能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。由硬件和软件所组成，没有安装任何软件的计算机称为裸机。常见的形式有台式计算机、笔记本计算机、大型计算机等。 计算机的应用已渗透到社会的各个领域，正在改变着人们的工作、学习和生活的方式，推动着社会的发展。 计算机的应用主要在以下几个方面： 1.1.1 科学计算科学计算也称数值计算。计算机最开始是为解决科学研究和工程设计中遇到的大量数学问题的数值计算而研制的计算工具。例如，人造卫星轨迹的计算，房屋抗震强度的计算，火箭、宇宙飞船的研究设计都离不开计算机的精确计算。就连我们每天收听收看的天气预报都离不开计算机的科学计算。 1.1.2 数据处理在科学研究和工程技术中，会得到大量的原始数据，其中包括大量图片、文字、声音等信息处理就是对数据进行收集、分类、排序、存储、计算、传输、制表等操作。 1.1.3 自动控制自动控制是指通过计算机对某一过程进行自动操作，它不需人工干预，能按人预定的目标和预定的状态进行过程控制。例如，无人驾驶飞机、导弹、人造卫星和宇宙飞船等飞行器的控制，都是靠计算机实现的。 1.1.4 计算机辅助设计计算机辅助设计(Computer Aided Design，简称CAD)是指。借助计算机的帮助，人们可以自动或半自动地完成各类工程设计工作。目前CAD技术已应用于飞机设计、船舶设计、建筑设计、机械设计、大规模集成电路设计等。在京九铁路的勘测设计中，使用计算机辅助设计系统绘制一张图纸仅需几个小时，而过去人工完成同样工作则要一周甚至更长时间。可见采用计算机辅助设计，可缩短设计时间，提高工作效率，节省人力、物力和财力，更重要的是提高了设计质量。 1.1.5 人工智能人工智能(Artificial Intelligence，简称AI)是指计算机模拟人类某些智力行为的理论、技术和应用。例如，用计算机模拟人脑的部分功能进行思维学习、推理、联想和决策，使计算机具有一定“思维能力”。我国已开发成功一些中医专家诊断系统，可以模拟名医给患者诊病开方。 还有就是机器人也是计算机人工智能的典型例子。 1.1.6 多媒体应用随着电子技术特别是通信和计算机技术的发展，人们已经有能力把文本、音频、视频、动画、图形和图像等各种媒体综合起来，构成一种全新的概念—“多媒体”(Multimedia)。比如一些flash广告，网页游戏等。 1.1.7 计算机网络计算机网络是由一些独立的和具备信息交换能力的计算机互联构成，以实现资源共享的系统。如在全国范围内的银行信用卡的使用，火车和飞机票系统的使用等。 1.2 计算机硬件计算机硬件（Computer Hardware）是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。这些物理装置按系统结构的要求构成一个有机整体为计算机软件运行提供物质基础。 计算机通常由CPU、主板、内存、电源、主机箱、硬盘、显卡、键盘、鼠标，显示器等多个部件组成。 1.3 计算机软件计算机软件是使用计算机过程中必不可少的东西，计算机软件可以使计算机按照事先预定好的顺序完成特定的功能，计算机软件按照其功能划分为系统软件与应用软件 系统软件： DOS(Disk Operating System), Windows, Linux, Unix, Mac, Android, iOS 应用软件：office QQ聊天 YY语言 扫雷 1.4 软件开发 软件：按照特定顺序组织的计算机数据和指令的集合 开发：软件的制作过程 软件开发：借助开发工具与计算机语言制作软件 1.5 计算机语言语言：人类进行沟通交流的各种表达符号，方便人与人之间进行沟通与信息交换计算机语言： 人与计算机之间进行信息交流沟通的一种特殊语言 计算机语言中也有字符，符号等等 常见的计算机语言如C,C++,C#,JAVA 计算机软件都是用各种计算机语言（后面讲）编写的。最底层的叫机器语言，它由一些0和1组成，可以被某种电脑直接理解，但人就很难理解。上面一层叫汇编语言，它只能由某种电脑的汇编器软件翻译成机器语言程序，才能执行。人能够勉强理解汇编语言。人常用的语言是更上一层的高级语言，比如C，C++，C#， Java等。这些语言编写的程序一般都能在多种电脑上运行，但必须先由一个叫作编译器或者是解释器的软件将高级语言程序翻译成特定的机器语言程序。编写计算机软件的人员叫程序设计员、程序员、编程人员。他们当中的高手有时也自称为黑客。 1.6 人机交互方式软件的出现实现了人与计算机之间更好的交互。 交互方式： 图形化界面：这种方式简单直观，使用者易于接受，容易上手操作。 命令行方式：需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令。 1.7 键盘功能键及快捷键介绍键盘功能键介绍 功能键 说明 Tab 制表符 Shift 上档转换键，也可以用于中英文转换 Ctrl 控制键，通常和其他键结合使用 Alt 交替换挡键，更改键，替换键 空格 空格键，输入空格 ↑ ↓ ← → 上下左右方向键 Enter 回车键 PrtSc(PrintScrenn) 屏幕截屏 键盘快捷键介绍 快捷键 说明 Ctrl + A 全选 Ctrl + C 复制 Ctrl + V 粘贴 Ctrl + X 剪切 Ctrl + Z 撤销 Ctrl + S 保存 Ctrl + F 搜索 1.8 常用的DOS命令打开DOS命令行的方式 开始 → 程序 → 附件 → 命令提示符 开始 → 运 → cmd → 回车 win+r → cmd →回车 dos命令 功能描述 d: 回车 盘符切换 cd 进入指定目录 cd.. 退回到上一级目录 cd\ 退回到根目录 md 创建文件夹 rd 删除文件夹 rd+/s 删除带内容的文件夹 dir directory，列出当前目录下的文件以及文件夹 del 删除文件，删除一堆后缀名一样的文件*.txt cls clear screen，清屏 exit 退出 2. Java语言概述在揭开Java语言的神秘面纱之前，先来认识一下什么是计算机语言。 计算机语言（Computer Language）是人与计算机之间通信的语言，它主要由一些指令组成，这些指令包括数字、符号和语法等内容，程序员可以通过这些指令来指挥计算机进行各种工作。计算机语言的种类非常多，总的来说可以分成机器语言、汇编语言、高级语言三大类。计算机所能识别的语言只有机器语言，但通常人们编程时，不采用机器语言，这是因为机器语言都是由二进制的0和1组成的编码，不便于记忆和识别。目前通用的编程语言是汇编语言和高级语言，汇编语言采用了英文缩写的标识符，容易识别和记忆；而高级语言采用接近于人类的自然语言进行编程，进一步简化了程序编写的过程，所以，高级语言目前是绝大多数编程者的选择。 Java是一种高级计算机语言，它是由SUN公司（已被Oracle公司收购）于1995年5月推出的一种可以编写跨平台应用软件、完全面向对象的程序设计语言。Java语言简单易用、安全可靠、主要面向Internet编程，自问世以来，与之相关的技术和应用发展得非常快。在计算机、移动电话、家用电器等领域中，Java技术无处不在。 为了使软件开发人员、服务提供商和设备生产商可以针对特定的市场进行开发，SUN公司将Java划分为三个技术平台，它们分别是JavaSE、JavaEE和JavaME。 Java SE（Java Platform Standard Edition）标准版，是为开发普通桌面和商务应用程序提供的解决方案。JavaSE是三个平台中最核心的部分，JavaEE和JavaME都是从JavaSE的基础上发展而来的，JavaSE平台中包括了Java最核心的类库，如集合、IO、数据库连接以及网络编程等。 Java EE(Java Platform Enterprise Edition) 企业版，是为开发企业级应用程序提供的解决方案。JavaEE可以被看作一个技术平台，该平台用于开发、装配以及部署企业级应用程序，其中主要包括Servlet、JSP 、JavaBean 、JDBC、EJB、Web Service等技术。 Java ME(Java Platform Micro Edition) 小型版，是为开发电子消费产品和嵌入式设备提供的解决方案。JavaME主要用于小型数字电子设备上软件程序的开发。例如，为家用电器增加智能化控制和联网功能，为手机增加新的游戏和通讯录管理功能。此外，Java ME提供了HTTP等高级Internet协议，使移动电话能以Client/Server方式直接访问Internet的全部信息，提供最高效率的无线交流。 2.1 Java语言发展史Java之父– 詹姆斯·高斯林（James Gosling） 1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得了美国卡内基梅隆大学计算机科学博士学位，毕业后到IBM工作，设计IBM第一代工作站NeWS系统，但不受重视。后来转至Sun公司，1990年，与Patrick，Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak”，后改名为Java。 2.2 Java语言平台版本 J2SE(Java 2 Platform Standard Edition)标准版 是为开发普通桌面和商务应用程序提供的解决方案，该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发 J2ME(Java 2 Platform Micro Edition)小型版 是为开发电子消费产品和嵌入式设备提供的解决方案 J2EE(Java 2 Platform Enterprise Edition)企业版 是为开发企业环境下的应用程序提供的一套解决方案，该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发 2.3 Java语言特点Java语言是一门优秀的编程语言，它之所以应用广泛，受到大众的欢迎，是因为它有众多突出的特点，其中最主要的特点有以下几个。 简单性：解释性 Java语言是一种相对简单的编程语言，它通过提供最基本的方法来完成指定的任务，只需理解一些基本的概念，就可以用它编写出适合于各种情况的应用程序。Java丢弃了C++中很难理解的运算符重载、多重继承等模糊概念。特别是Java语言不使用指针，而是使用引用，并提供了自动的垃圾回收机制，使程序员不必为内存管理而担忧。 面向对象：高性能 Java语言提供了类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯粹的面向对象程序设计语言。 分布式处理：多线程 Java语言是支持多线程的。所谓多线程可以简单理解为程序中有多个任务可以并发执行，这样可以在很大程度上提高程序的执行效率。 健壮性：动态 结构中立：安全性 Java语言不支持指针，一切对内存的访问都必须通过对象的实例变量来实现，从而使应用更安全。 开源 跨平台 Java语言编写的程序可以运行在各种平台之上，也就是说同一段程序既可以在Windows操作系统上运行，也可以在Linux操作系统上运行。 2.4 跨平台性 什么是跨平台性？ 通过Java语言编写的应用程序在不同的系统平台上都可以运行。 原理是什么？ 只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。 因为有了JVM，所以同一个Java程序在三个不同的操作系统中都可以执行。这样就实现了Java程序的跨平台性。也称为Java具有良好的可移植性。 PS：Java语言是跨平台的，而JVM不是跨平台的。 2.5 JDK与JRESUN公司提供了一套Java开发环境，简称JDK(Java Development Kit)，它是整个Java的核心，其中包括Java编译器、Java运行工具、Java文档生成工具、Java打包工具等。 为了满足用户日新月异的需求，JDK的版本也在不断地升级。在1995年，Java诞生之初就提供了最早的版本JDK1.0，随后相继推出了JDK1.1、JDK1.2、JDK1.3、JDK1.4、JDK5.0、JDK6.0、JDK7.0、JDK8.0 SUN公司除了提供JDK，还提供了一种JRE(Java Runtime Environment)工具，它是Java运行环境，是提供给普通用户使用的。由于用户只需要运行事先编写好的程序，不需要自己动手编写程序，因此JRE工具中只包含Java运行工具，不包含Java编译工具。值得一提的是，为了方便使用，SUN公司在其JDK工具中自带了一个JRE工具，也就是说开发环境中包含运行环境，这样一来，开发人员只需要在计算机上安装JDK即可，不需要专门安装JRE工具了。 Oracle公司提供了多种操作系统的JDK，每种操作系统的JDK在使用上基本类似，初学者可以根据自己使用的操作系统，从Oracle官方网站下载相应的JDK安装文件。 3. JDK的下载,安装通过官方网站获取JDK：http://www.oracle.com针对不同操作系统，下载不同的JDK版本：识别计算机的操作系统 JDK的下载步骤图1 JDK的下载步骤图2 JDK的下载步骤图3 3.1 JDK的安装傻瓜式安装，下一步即可。建议：安装路径不要有中文或者特殊符号如空格等。最好目录统一。当提示安装JRE时，可以选择不安装。 为了更好地学习JDK，初学者必须要对JDK安装目录下各个子目录的意义和作用有所了解，接下来分别对JDK安装目录下的子目录进行介绍。 bin目录：该目录用于存放一些可执行程序，如javac.exe（Java编译器）、java.exe（Java运行工具）、jar.exe（打包工具）和javadoc.exe（文档生成工具）等。 db目录：db目录是一个小型的数据库。从JDK 6.0开始，Java中引入了一个新的成员JavaDB，这是一个纯 Java 实现、开源的数据库管理系统。这个数据库不仅很轻便，而且支持JDBC 4.0所有的规范，在学习JDBC时，不再需要额外地安装一个数据库软件，选择直接使用JavaDB即可。 jre目录：“jre”是Java Runtime Environment的缩写，意为Java程序运行时环境。此目录是Java运行时环境的根目录，它包含Java虚拟机，运行时的类包、Java应用启动器以及一个bin目录，但不包含开发环境中的开发工具。 include目录：由于JDK是通过C和C++实现的，因此在启动时需要引入一些C语言的头文件，该目录就是用于存放这些头文件的。 lib目录：lib是library的缩写，意为Java类库或库文件，是开发工具使用的归档包文件。 src.zip文件：src.zip为src文件夹的压缩文件，src中放置的是JDK核心类的源代码，通过该文件可以查看Java基础类的源代码。 值得一提的是，在JDK的bin目录下放着很多可执行程序，其中最重要的就是javac.exe和java.exe，分别如下： javac.exe是Java编译器工具，它可以将编写好的Java文件编译成Java字节码文件（可执行的Java程序）。Java源文件的扩展名为.java，如“HelloWorld.java”。编译后生成对应的Java字节码文件，文件的扩展名为.class，如“HelloWorld.class”。 java.exe是Java运行工具，它会启动一个Java虚拟机（JVM）进程，Java虚拟机相当于一个虚拟的操作系统，它专门负责运行由Java编译器生成的字节码文件（.class文件）。 4. HelloWorld案例4.1 开发工具介绍 编写Java程序可以使用很多种工具 notepad(微软操作系统自带) Notepad++ Eclipse MyEclipse 4.2 HelloWorld 首先定义一个类：class 类名 在类定义后加上一对大括：{ } 在大括号中间添加一个主(main)方法/函数 12public static void main(String [] args)&#123; &#125; 在主方法的大括号中间添加一行输出语句 1System.out.println(“hello world”); 123456javaclass HelloWorld &#123; public static void main(String [] args)&#123; System.out.println(“Hello World”); &#125;&#125; 4.3 程序解析 首先编写java源代码程序，扩展名.java 在命令行模式中，输入javac命令对源代码进行编译，生成字节码文件 javac 源文件名.java 编译完成后，如果没有报错信息，输入java命令对class字节码文件进行解释运行,执行时不需要添加.class扩展名 java HelloWorld 4.4 运行与工作原理 4.5 常见错误 文件扩展名隐藏导致编译失败 class写错Class claas… 类名格式有问题暂时全部使用英文 类名后面的大括号匹配不正确 main方法格式错误 12public static void main(String [] args)&#123; &#125; main方法大括号缺失 打印语句拼写错误 1System.out.println(“”); 引号使用错误，使用成中文全角引号 5. 环境变量的配置在计算机操作系统中可以定义一系列变量，这些变量可供操作系统上所有的应用程序使用，被称作系统环境变量。在学习Java的过程中，需要涉及两个系统环境变量path和classpath 5.1 path环境变量path环境变量是系统环境变量中的一种，它用于保存一系列的路径，每个路径之间以分号分隔。当在命令行窗口运行一个可执行文件时，操作系统首先会在当前目录下查找是否存在该文件，如果不存在会继续在path环境变量中定义的路径下寻找这个文件，如果仍未找到，系统会报错。例如，在命令行窗口输入“javac”命令，并按下回车，会看到错误提示。如下图所示： 从上图的错误提示可以看出系统没有找到javac命令。在命令行窗口输入“set path”命令，可以查看当前系统的path环境变量，如下图所示： 从上图中列出的path环境变量可以看出，其中并没有包含“javac”命令所在的目录，因此操作系统找不到该命令。为了解决这个问题，需要在命令行窗口输入一行命令，将“javac”命令所在的目录添加至path环境变量。命令如下所示： 1set path=%path%;C:\Program Files\Java\jdk1.7.0_60\bin; 其中，“%path%”表示引用原有的path环境变量，“C:\Program Files\Java\jdk1.7.0_60\bin” 表示javac命令所在的目录。整行命令的作用就是在原有的path环境变量值中添加javac命令所在的目录。 再次输入“set path”命令查看path环境变量，结果如下图所示： 设置完path环境变量后，再次运行“javac”命令，找不到javac.exe命令的错误情况就不会再出现了，命令行中会显示“javac”命令的帮助信息，如下图所示： 由于“java”命令和“javac”命令位于同一个目录中，因此在配置完path环境变量后，同样可以在任意的路径下执行“java”命令。 重新打开一个新的命令行窗口，再次运行javac命令，又会出现找不到javac.exe命令错误，使用“set path”命令查看环境变量，会发现之前的设置无效了。出现这种现象的原因在于，在命令窗口中，对环境变量进行任何修改只对当前窗口有效，一旦关闭窗口，所有的设置都会失效。因此，要想让环境变量永久生效，就需要在系统中对环境变量进行配置。让Windows系统永久性地记住所配置的环境变量。配置系统环境变量步骤如下： 1、查看Windows系统属性中的环境变量 右键单击桌面上的【计算机】，从下拉菜单中选择【属性】，在出现的【系统】窗口中选择左边的【高级系统设置】选项，然后在【高级】窗口中单击【环境变量】按钮，打开【环境变量】窗口，如下图所示： 2、设置path系统环境变量 在【环境变量】窗口中的【系统变量】区域选中名为“Path”的系统变量，单击【编辑】按钮，打开【编辑系统变量】窗口，如下图所示： 在【变量值】文本区域内开始处添加“javac”命令所在的目录“C:\ProgramFiles\Java\jdk1.7.0_60\bin”，末尾用英文半角分号(;)结束，与后面的路径隔开。如下图所示： 添加完成后，依次单击打开窗口的【确定】按钮，完成设置。 3、查看和验证设置的path系统环境变量 打开命令行窗口，执行“set path”命令，查看设置后的path变量的变量值，如下图所示： 从上图中环境变量path值的第一行中，已经显示出来配置路径信息。在命令行窗口中执行javac命令，如果能正常地显示帮助信息，说明系统path环境变量配置成功，这样系统就永久性地记住了path环境变量的设置。 5.2 classpath环境变量classpath环境变量也用于保存一系列路径，它和path环境变量的查看与配置的方式完全相同。当Java虚拟机需要运行一个类时，会在classpath环境变量中所定义的路径下寻找所需的class文件。 打开命令提示行窗口，进入C盘根目录下，然后执行“java HelloWorld”命令，运行之前编译好的Java程序，结果会报错，如下图所示： 出现上图中所示错误的原因在于，Java虚拟机在运行程序时无法找到“HelloWorld.class”文件。为了解决这个错误，首先来通过“set classpath”命令查看当前classpath环境变量的值，如下图所示： 从上图中可以看出，当前classpath环境变量没有设置，为了让Java虚拟机能找到所需的class文件，就需要对classpath环境变量进行设置，在命令行窗口输入下面的命令： 1set classpath=C:\Program Files\Java\jdk1.7.0_60\bin 再次执行“java HelloWorld”命令运行程序，会看到正确的结果，如下图所示： 值得注意的是，在1.3小节中并没有对classpath环境变量进行设置，但在“C:\Program Files \Java\jdk1.7.0_60\bin”目录下仍然可以使用“java”命令正常运行程序，而没有出现无法找到“HelloWorld.class”文件的错误。这是因为从JDK5.0开始，如果classpath环境变量没有进行设置，Java虚拟机会自动将其设置为“.”，也就是当前目录。 5.3 path环境变量配置的作用 程序的执行需要使用外部指令javac，但是javac指令仅仅能在JDK安装目录下的bin目录下时候，因此程序只能写入bin目录 程序开发过程中，不能将源代码写入JDK的安装目录，因此需要将源程序保存到任意位置的指定目录(英文目录)，所以需要使javac指令在任意目录下可以运行 5.3.1 path环境变量配置方式1通过配置path环境变量，将javac指令所在目录也就是JDK安装目录下的bin目录配置到path变量下，即可使javac指令在任意目录下运行 win7，win8系统：右键点击桌面计算机 → 选择属性 → 选择高级系统设置 → 选择高级选项卡 → 点击环境变量 → 下方系统变量 中查找 path → 双击path XP系统：右键点击桌面计算机→选择属性→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path 将jdk安装目录下的bin目录添加到最左边并添加分号 5.3.2 path环境变量配置方式2path环境变量的参照形配置方式 创建新的变量名称：JAVA_HOME 为JAVA_HOME添加变量值：JDK安装目录 将path环境变量中JDK目录修改：%JAVA_HOME%\bin; path环境变量具有先后顺序 5.3.3 classpath环境变量配置方式classpath环境变量配置方式 创建新的变量名称：classpath 值设定为指定的还有class文件的目录，多个目录间使用分号(;)分割 作用：使classpath目录中的.class文件可以在任意目录运行 技巧：通常将配置的目录最前面添加.配置，即便当前目录，使.class文件搜索时首先搜索当前目录，然后根据目录配置的顺序依次查找，找到后即运行，因此classpath目录中的配置存在先后顺序 5.4 path和classpath的区别 path环境变量里面记录的是可执行性文件，如.exe文件，对可执行文件先在当前路径去找，如果没找到就去path环境变量中配置的路径去找 classpath环境变量里记录的是java类的运行文件所在的目录 6. Java的运行机制使用Java语言进行程序设计时，不仅要了解Java语言的显著特点，还需要了解Java程序的运行机制。 Java程序运行时，必须经过编译和运行两个步骤。首先将后缀名为.java的源文件进行编译，最终生成后缀名为.class的字节码文件。然后Java虚拟机将字节码文件进行解释执行，并将结果显示出来。 以HelloWorld为例，对Java程序的运行过程进行详细的分析，具体步骤如下： 编写一个HelloWorld.java的文件。 使用“javac HelloWorld.java”命令开启Java编译器并进行编译。编译结束后，会自动生成一个HelloWorld.class的字节码文件。 使用“java HelloWorld”命令启动Java虚拟机运行程序，Java虚拟机首先将编译好的字节码文件加载到内存，这个过程被称为类加载，它是由类加载器完成的，然后虚拟机针对加载到内存中的Java类进行解释执行，便可看到运行结果。 通过上面的分析不难发现，Java程序是由虚拟机负责解释执行的，而并非操作系统。这样做的好处是可以实现跨平台性，也就是说针对不同的操作系统可以编写相同的程序，只需安装不同版本的虚拟机即可，如下图所示： 从上图可以看出，不同的操作系统需要使用不同版本的虚拟机，这种方式使得Java语言具有“一次编写，到处运行（write once，run anywhere）”的特性，有效地解决了程序设计语言在不同操作系统编译时产生不同机器代码的问题，大大降低了程序开发和维护的成本。 需要注意的是，Java程序通过Java虚拟机可以达到跨平台特性，但Java虚拟机并不是跨平台的。也就是说，不同操作系统上的Java虚拟机是不同的，即Windows平台上的Java虚拟机不能用在Linux平台上，反之亦然。 7. Eclipse开发工具在实际项目开发过程中，由于使用记事本编写代码速度慢，且不容易排错，所以程序员很少用它来编写代码。为了提高程序的开发效率，大部分软件开发人员都是使用集成开发工具（IDE，Integrated Development Environment）来进行Java程序开发的。正所谓“工欲善其事，必先利其器”，接下来就为读者介绍一种Java常用的开发工具——Eclipse。 Eclipse是由蓝色巨人IBM花费巨资开发的一款功能完整且成熟的IDE集成开发环境，它是一个开源的、基于Java的可扩展开发平台，是目前最流行的Java语言开发工具。Eclipse具有强大的代码编排功能，可以帮助程序开发人员完成语法修正、代码修正、补全文字、信息提示等编码工作，大大提高了程序开发的效率。 Eclipse的设计思想是“一切皆插件”。就其本身而言，它只是一个框架和一组服务，所有功能都是将插件组件加入到Eclipse框架中来实现的。Eclipse作为一款优秀的开发工具，其自身附带了一个标准的插件集，其中包括了Java开发工具（JDK），因此，使用Eclipse工具进行Java程序开发不需要再安装JDK以及配置Java运行环境。下面将为读者具体的讲解Eclipse工具的使用。 8. 包的定义与使用为了便于对硬盘上的文件进行管理，通常都会将文件分目录进行存放。同理，在程序开发中，也需要将编写的类在项目中分目录存放，以便于文件管理。为此，Java引入了包(package)机制，程序可以通过声明包的方式对Java类定义目录。 Java中的包是专门用来存放类的，通常功能相同的类存放在相同的包中。在声明包时，使用package语句，具体示例如下： 12package cn.itcast.chapter01; // 使用package关键字声明包public class Example01&#123;…&#125; 需要注意的是，包的声明只能位于Java源文件的第一行。 在实际程序开发过程中，定义的类都是含有包名的，如果没有显式地声明package语句，创建的类则处于默认包下，在实际开发中，这种情况是不应该出现的，本教材的示例代码主要展现的是功能部分的代码，所以在大多数示例代码中没有为示例指定包名，但是在提供的源码中，都已使用包名。 在开发时，一个项目中可能会使用很多包，当一个包中的类需要调用另一个包中的类时，就需要使用import关键字引入需要的类。使用import可以在程序中一次导入某个指定包下的类，这样就不必在每次用到该类时都书写完整类名，简化了代码量。使用import关键字的具体格式如下所示： 1import 包名.类名; 需要注意的是，import通常出现在package语句之后，类定义之前。如果有时候需要用到一个包中的许多类，则可以使用“import 包名.*; ”来导入该包下所有类。 在JDK中，不同功能的类都放在不同的包中，其中Java的核心类主要放在java包及其子包下，Java扩展的大部分类都放在javax包及其子包下。为了便于后面的学习，接下来简单介绍Java语言中的常用包。 java.util:包含Java中大量工具类、集合类等，例如Arrays、List、Set等。 java.net:包含Java网络编程相关的类和接口。 java.io:包含了Java输入、输出有关的类和接口。 java.awt:包含用于构建图形界面(GUI)的相关类和接口。 除了上面提到的常用包，JDK中还有很多其它的包，比如数据库编程的java.sql包，编写GUI的javax.swing包等等，JDK中所有包中的类构成了Java类库。在以后的章节中，这些包中的类和接口将逐渐介绍，这里只需要有个大致印象即可。 jdk、JRE、JVM的区别和联系1. 详细介绍1.1 JVM – java virtual machineJVM就是我们常说的java虚拟机，它是整个java实现跨平台的 最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可 以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解 释给本地系统执行。 JVM 是 Java 平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行 时操作不同的内存区域。 JVM 通过抽象操作系统和 CPU 结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方 法、主机硬件、主机操作系统无关。但是在一些小的方面， JVM 的实现也是互不相同的，比如垃圾回收 算法，线程调度算法（可能不同 OS 有不同的实现）。 JVM 的主要工作是解释自己的指令集（即字节码）到 CPU 的指令集或 OS 的系统调用，保护用户免被恶意程序骚扰。 JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的 组成包括 JVM 指令集，符号表以及一些补助信息。 1.2 JRE – java runtime environmentJRE是指java运行环境。光有JVM还不能成class的 执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。 在JDK的安装目 录里你可以找到jre目录，里面有两个文件夹bin和lib,在 这里可以认为bin里的就是jvm，lib中则是jvm工 作所需要的类库，而jvm和 lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件 和jre一起打包发给朋友，这样你的朋友就 可以运行你写程序了。（jre里有运行.class的java.exe） JRE 是 Sun 公司发布的一个更大的系统，它里面就有一个 JVM 。 JRE 就与具体的 CPU 结构和操作系统有关，我们从 Sun 下载 JRE 的时候就看到了不同的各种版本。同 JVM 一起组成 JRE 的还有一些 API （如 awt ， swing 等）。 JRE 是运行 Java 程序必不可少的。 JRE （ Java Runtime Environment ），是运行 Java 程序必不可少的（除非用其他一些编译环境编译成.exe可执行文件……），JRE的 地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮 我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。 JRE里面有一个 JVM ， JRE 与具体的 CPU 结构和操作系统有关，我们从 Sun 下载 JRE 的时候就看到了不同的各种版本，，同 JVM 一起组成 JRE 的还有 一些 API （如 awt ， swing 等）， JRE 是 运行 Java 程序必不可少的. 1.3 JDK – java development kitJDK是java开发工具包，基本上每个学java的人都会先在机器 上装一个JDK，那他都包含哪几部分呢？让我们看一下JDK的安装目录。在目录下面有 六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的 是以下四个文件夹：bin、include、lib、 jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包 含JVM。 bin:最主要的是编译器(javac.exe) include:java和JVM交互用的头文件 lib:类库 jre:java运行环境 注意：这里的bin、lib文件夹和jre里的bin、lib是 不同的，总的来说JDK是用于java程序的开发,而jre则 是只能运行class而没有编译的功能。eclipse、idea等 其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你 选中jre路径就ok了。 2. 三者联系 Java 喊出的带有标志性的口号“ Write Once ， Run Anywhere （一次编写，到处运行）”，正是建立在 JRE 的基础之上。何以实现？就是在 Java 应用程序和操作系统之间增加了一虚拟层—— JRE 。 程序源代码不是直 接编译、链接成机器代码，而是先转化到字节码（ bytecode ） 这种特殊的中间形式，字节码再转换成机器码或系统调用。前者是传统的编译方法，生成的机器代码就不可避免地跟特殊的操作系统和特殊的机器结构相关。 而 Java 程序的字节码文件可以放到任意装有 JRE 的计算机运行，再由不同 JRE 的将它们转化成相应的机器代码，这就实现了 Java 程序的可移植性。这样程序员也不用去关心程序运行的具体环境，而可以专心编写软件。这种分层抽象、隐藏细节的思想在计算机科学中处处可见，比如机器组织结构的设计、网络协议的实现等。 Pascal 语言的发明者 Niklaus Wirth ，就富有预见性地指出应该有这样一种可移植的语言，其生成的中间代码可以在一台假想的机器（ a hypothetical machine ）上运行。 而 Java 虚拟机（ Java virtual machine 或 JVM ）就是这样的一台机器，它模拟实际处理器的结构，解释字节码。 怎么一会说是 JRE ，一会儿又成了 JVM ，两者是否同物不同名？ 回答是否定的。 JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮 我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。 要运行Applet，在客户端必须安装有 JRE，即“运行时”，容易一点理解，就象所谓的“插件”，要开发JAVA应用程序\Web应用，就必须在服务器端安装相应的 JVM+JDK 了(开发应用 Java web应用 时，客户端不需要安装任何的JVM） 如果你使用JAVA开发应用，就需要安装 JRE+JDK，就是 J2SE如果在客户端运行Applet，客户端浏览器必须嵌有JAVA JVM，如果没有，就需要安装，即：在客户端创建JRE（运行时，包含JVM），而客户端是不需要做开发的，所以，JDK就没有必要安装 了 不同版本的Applet在不同的JVM下可能无法正常运行,而Microsoft JVM只是Sun JVM的“低版本”，微软在windows xp/2003中干脆将JVM去掉了 第2章 Java编程基础Java语法基础-11. 关键字关键字是编程语言里事先定义好并赋予了特殊含义的单词，也称作保留字。和其它语言一样，Java中保留了许多关键字，例如，class、public等，下面列举的是Java中所有的关键字。 1.1 关键字概述被Java语言赋予特定含义的单词 1.2 关键字特点组成关键字的字母全部小写 1.3 关键字注意事项 goto和const作为保留字存在,目前并不使用 类似Notepad++这样的高级记事本,针对关键字有特殊的颜色标记，非常直观 2. 标识符2.1 标识符概述就是给类，接口，方法，变量等起名字时使用的字符序列 2.2 组成规则由英文大小写字母、数字字符、$（美元符号）、_（下划线）组成 2.3 注意事项 不能以数字开头 不能是Java中的关键字 区分大小写 2.4 标识符常见命名规则：见名知意2.4.1 包其实就是文件夹，用于把相同的类名进行区分，全部小写，单级：liuyi，多级：cn.itcast 为了便于对硬盘上的文件进行管理，通常都会将文件分目录进行存放。同理，在程序开发中，也需要将编写的类在项目中分目录存放，以便于文件管理。为此，Java引入了包(package)机制，程序可以通过声明包的方式对Java类定义目录。 Java中的包是专门用来存放类的，通常功能相同的类存放在相同的包中。在声明包时，使用package语句，具体示例如下： 12package cn.itcast.chapter01; // 使用package关键字声明包public class Example01&#123;…&#125; 需要注意的是，包的声明只能位于Java源文件的第一行。 在实际程序开发过程中，定义的类都是含有包名的，如果没有显式地声明package语句，创建的类则处于默认包下，在实际开发中，这种情况是不应该出现的，本教材的示例代码主要展现的是功能部分的代码，所以在大多数示例代码中没有为示例指定包名，但是在提供的源码中，都已使用包名。 在开发时，一个项目中可能会使用很多包，当一个包中的类需要调用另一个包中的类时，就需要使用import关键字引入需要的类。使用import可以在程序中一次导入某个指定包下的类，这样就不必在每次用到该类时都书写完整类名，简化了代码量。使用import关键字的具体格式如下所示： 1import 包名.类名; 需要注意的是，import通常出现在package语句之后，类定义之前。如果有时候需要用到一个包中的许多类，则可以使用 import 包名.*; 来导入该包下所有类。 在JDK中，不同功能的类都放在不同的包中，其中Java的核心类主要放在java包及其子包下，Java扩展的大部分类都放在javax包及其子包下。为了便于后面的学习，接下来简单介绍Java语言中的常用包。 java.util:包含Java中大量工具类、集合类等，例如Arrays、List、Set等。 java.net:包含Java网络编程相关的类和接口。 java.io:包含了Java输入、输出有关的类和接口。 java.awt:包含用于构建图形界面(GUI)的相关类和接口。 除了上面提到的常用包，JDK中还有很多其它的包，比如数据库编程的java.sql包，编写GUI的javax.swing包等等，JDK中所有包中的类构成了Java类库。在以后的章节中，这些包中的类和接口将逐渐介绍，这里只需要有个大致印象即可。 2.4.2 类或者接口一个单词：单词的首字母必须大写，举例：Student,Dog多个单词：每个单词的首字母必须大写举例：HelloWorld，StudentName 2.4.3 方法和变量一个单词：单词的首字母小写，举例：main,age多个单词：从第二个单词开始，每个单词的首字母大写，举例：studentAge,showAllNames() 2.4.4 常量一个单词：全部大写，举例：PI多个单词：每个字母都大写，用_隔开，举例：STUDENT_MAX_AGE 3. 注释3.1 注释概述用于解释说明程序的文字 3.2 Java中注释分类格式 单行注释，格式： //注释文字 多行注释，格式： /* 注释文字 */ 文档注释，格式：/** 注释文字 */ 12345678910111213141516171819/* 注释：用于解释说明程序的文字 Java中注释的分类及格式 单行注释：// 多行注释：/星 星/ 注意：多行不可以嵌套使用，而单行是可以的 文档注释：被javadoc工具解析生成一个说明书，面向对象部分讲解。*///这是我的注释案例class ZhuShiDemo &#123; //main方法是主方法 //是程序的入口 //被jvm调用 public static void main(String[] args) &#123; System.out.println("好好学习,天天向上"); &#125;&#125; 对于单行和多行注释，被注释的文字，不会被JVM（java虚拟机）解释执行 对于文档注释，是java特有的注释，其中注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档 注释是一个程序员必须要具有的良好编程习惯 初学者编写程序可以养成习惯：先写注释再写代码 将自己的思想通过注释先整理出来，在用代码去体现 因为代码仅仅是思想的一种体现形式而已 12345678910111213141516171819202122232425262728293031/* 需求：我准备写一个java程序，把"HelloWorld"这句话输出在控制台 分析： A:要写一个Java程序，必须定义类 B:把数据能够输出，说明我们的程序是可以独立运行的，而程序要独立运行，必须定义main方法 C:把数据输出在控制台，必须使用输出语句 实现： A:java语言提供了一个关键字：class用来定义类，后面跟的是类名 B:main方法的格式是固定的： public static void main(String[] args) &#123; &#125; C:输出语句的格式是固定的： System.out.println("HelloWorld"); "HelloWorld"这个内容是可以改变的*///这是我的HelloWorld案例class HelloWorld &#123; /* 为了程序能够独立运行，定义main方法 main方法是程序的入口 被jvm自动调用 */ public static void main(String[] args) &#123; //为了把数据显示在控制台，我们就使用了输出语句 System.out.println("HelloWorld"); &#125;&#125; 4. 常量、进制和进制转换4.1 常量概述在程序执行的过程中其值不可以发生改变 4.2 Java中常量分类4.2.1 字面值常量 字符串常量：用双引号括起来的内容，举例：“hello”，“world” 整数常量：所有整数，举例：12，23 小数常量：所有小数，举例：12.34，56.78 字符常量：用单引号括起来的内容，举例：‘a’,’A’,’0’ 布尔常量，较为特有，举例：true，false 空常量，举例：null 4.2.2 自定义常量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647java/* 常量： 在程序执行过程中，其值不发生改变的量。 分类： A:字面值常量 B:自定义常量(后面讲) 字面值常量 A:字符串常量 用双引号括起来的内容。 举例："hello","world","HelloWorld" B:整数常量 所有的整数 举例：100,200 C:小数常量 所有的小数 举例：10.23,110.11 D:字符常量 用单引号括起来的内容 举例：'a','A','0' 错误的：'ab' E:布尔常量 比较特殊 举例：true,false F:空常量 后面讲 举例：null*/class ConstantDemo &#123; public static void main(String[] args) &#123; //字符串常量的输出 System.out.println("hello"); //整数常量的输出 System.out.println(100); //小数常量的输出 System.out.println(100.10); //字符常量的输出 System.out.println('a'); System.out.println('A'); System.out.println('0'); //这个是有问题的 //System.out.println('ab'); //布尔常量的输出 System.out.println(true); System.out.println(false); &#125;&#125; 4.3 Java针对整数常量提供了4种表现形式二进制，八进制，十进制，十六进制 4.4 进制概述进制：就是进位制，是人们规定的一种进位方法。 对于任何一种进制–X进制，就表示某一位置上的数运算时是逢X进一位。二进制就是逢二进一，八进制是逢八进一，十进制是逢十进一，十六进制是逢十六进一。 PS：二进制的由来：任何数据在计算机中都是以二进制的形式存在的。二进制早期由电信号开关演变而来。 一个整数在内存中一样也是二进制的，但是使用一大串的1或者0组成的数值进行使用很麻烦。所以就想把一大串缩短点，将二进制中的三位用一位表示。这三位可以取到的最大值就是7超过7就进位了，这就是八进制。但是对于过长的二进制变成八进制还是较长，所以出现的用4个二进制位表示一位的情况，四个二进制位最大是15，这就是十六进制。 规律：进制越大，表现形式越短。 4.5 不同进制的数据组成 二进制，由0，1组成。以0b开头 八进制，由0，1，…7组成。以0开头 十进制，由0，1，…9组成。整数默认是十进制的 十六进制，由0，1，…9，a，b，c，d，e，f(大小写均可)。以0x开头 1234567891011121314151617java/* 不同进制的数据表现： 二进制：由0，1组成。以0b开头。 八进制：由0,1,...7组成。以0开头。 十进制：由0,1,...9组成。默认整数是十进制。 十六进制：由0,1,...9,a,b,c,d,e,f(大小写均可)组成。以0x开头。*/class JinZhiDemo &#123; public static void main(String[] args) &#123; System.out.println(100); //十进制 System.out.println(0b100); //二进制 System.out.println(0100); //八进制 System.out.println(0x100); //十六进制 &#125;&#125; 运行结果 4.6 进制转换 其他进制到十进制 十进制到其他进制 十进制和二进制的快速转换，8421码，也叫BCD码 二进制和八进制，十六进制如何转换以十进制作为桥梁，二进制到八进制 3位组合，二进制到十六进制4位组合 PS：1、其他进制到十进制 系数：就是每一位上的数据 基数：X进制，基数就是X 权：在右边，从0开始编号，对应位上的编号即为该位的权 结果：把系数*基数的权次幂相加即可 2、十进制到其他进制除基取余，直到商为0，余数反转。 4.7 有符号数据表示法在计算机内，有符号数有3种表示法：原码、反码和补码。所有数据的运算都是采用补码进行的 原码：就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小 反码：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外 补码：正数的补码与其原码相同；负数的补码是在其反码的末位加1 4.8 练习4.8.1 得到下面数据的十进制值12345678910111213140b10101 =12^4 + 12^2 + 1*2^0 =16 + 4 + 1 =210123 =18^2 + 28^1 + 3*8^0 =64 + 16 + 3 =830x3c =316^1 + c16^0 =48 + 12 =60 4.8.2 得到下面数据的二进制，十进制，十六进制52分别得到二进制，十进制，十六进制 得到二进制：123456752 / 2 = 26 026 / 2 = 13 013 / 2 = 6 16 / 2 = 3 03 / 2 = 1 11 / 2 = 0 10b110100 得到八进制：12352 / 8 = 6 46 / 8 = 0 6064 得到十六进制：12352 / 16 = 3 43 / 16 = 0 30x34 4.8.3 有符号数据表示法的练习A：已知某数X的原码为10110100B，试求X的补码和反码。 符号位 数值位原码：10110100反码：11001011补码：11001100 B:已知某数X的补码11101110B，试求其原码 符号位 数值位补码： 11101110反码： 11101101原码： 10010010 5. 变量在程序运行期间，随时可能产生一些临时数据，应用程序会将这些数据保存在一些内存单元中，每个内存单元都用一个标识符来标识。这些内存单元我们称之为变量，定义的标识符就是变量名，内存单元中存储的数据就是变量的值。 5.1 变量概述在程序执行的过程中，在某个范围内其值可以发生改变的量，理解：如同数学中的未知数 5.2 变量定义格式数据类型 变量名 = 初始化值;注意：格式是固定的，记住格式，以不变应万变 5.3 变量的组成规则 1、从本质上讲，变量其实是内存中的一小块区域，使用变量名来访问这块区域，因此，每一个变量使用前必须要先申请（声明），然后必须进行赋值（填充内容），才能使用。通过画图说明一个变量的组成部分 数据类型，变量名，变量值 2、为什么要定义变量呢?用来不断的存放同一类型的常量，并可以重复使用 6. 数据类型和类型转换Java是一门强类型的编程语言，它对变量的数据类型有严格的限定。在定义变量时必须声明变量的类型，在为变量赋值时必须赋予和变量同一种类型的值，否则程序会报错。 6.1 数据类型6.1.1 Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存总分配了不同大小的内存空间 6.1.2 所谓有效数字：具体地说，是指在分析工作中实际能够测量到的数字。所谓能够测量到的是包括最后一位估计的，不确定的数字。对于一个近似数，从左边第一个不是0的数字起，到精确到的位数止，所有的数字都叫做这个数的有效数字。 6.1.3 Java 各整数类型有固定的表数范围和字段长度，其不受具体操作系统的影响，以保证Java程序的可移植性。 Java语言的整型常量默认为int型，声明long型常量可以后加‘ l ’或‘ L ’ ，如： int i1 = 600; //正确 long l1 = 88888888888L; //必须加l否则会出错 与整数类型类似，Java浮点类型有固定的表数范围和字段长度，不受平台影响。 Java浮点类型常量有两种表示形式，十进制数形式，如: 3.14 314.0 科学记数法形式，如 3.14e2 3.14*10^2 Java 浮点型常量默认为 double 型，如要声明一个常量为 float 型，则需在数字后面加 f 或 F ，如： double d = 12345.6; //正确 float f = 12.3f; //必须加f否则会出错 char 型数据用来表示通常意义上的“字符” 字符常量为用单引号括起来的单个字符，例如：char ch1= ‘a’; char ch2=’中’; Java字符采用 Unicode 编码，每个字符占两个字节，因而可用十六进制编码形式表示。 注：Unicode是全球语言统一编码 boolean 类型适于逻辑运算，一般用于程序流程控制 。 boolean 类型数据只允许取值 true 或 false ，不可以 0 或非 0 的整数替代 true 和 false ，这点和C语言不同。 数据类型 基本数据类型：整型byte、short、int、long，浮点型float、double，字符型char，布尔型boolean 引用数据类型：类class、接口interface、数组[] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Java/* 数据类型：Java是一种强类型的语言，针对每一种数据都定义了明确的数据类型。 数据类型分类： A:基本数据类型 B:引用数据类型(类,接口,数值) 基本数据类型:4类8种 A:整数 占用字节数 byte 1 short 2 int 4 long 8 B:浮点数 float 4 double 8 C:字符 char 2 D:布尔 boolean 1 注意： 整数默认是int类型 浮点数默认是double类型。 长整型后缀用L或者l标记。建议使用L。 单精度浮点数用F或者f标记。建议使用F。*/class DataTypeDemo &#123; public static void main(String[] args) &#123; //定义变量的格式： //数据类型 变量名 = 初始化值; //定义一个字节变量 byte b = 10; System.out.println(10); System.out.println(b); //定义一个短整型变量 short s = 100; System.out.println(s); //定义一个整型变量 int i = 1000; System.out.println(i); //超过了int的范围 //int j = 1000000000000; long j = 1000000000000L; //long j = 100L; System.out.println(j); //定义浮点数据变量 float f = 12.345F; System.out.println(f); double d = 12.345; System.out.println(d); //定义字符变量 char ch = 'a'; System.out.println(ch); //定义布尔变量 boolean flag = true; System.out.println(flag); &#125;&#125; 运行结果: 6.1.4 使用变量的时候要注意的问题： A：作用域变量定义在哪个大括号内，它就在这个大括号内有效。并且，在同一个大括号内不能同时定义同名的变量。 B：初始化值 没有初始化值的变量不能直接使用。 你只要在使用前给值就行，不一定非要在定义的时候立即给值。 推荐在定义的时候给值。 定义变量的格式： a：数据类型 变量名 = 初始化值; b：数据类型 变量名; 变量名 = 初始化值;C：在一行上建议只定义一个变量 可以定义多个，但是不建议 6.2 类型转换当把一种数据类型的值赋给另一种数据类型的变量时，需要进行数据类型转换。 根据转换方式的不同，数据类型转换可分为两种：自动类型转换和强制类型转换。 6.2.2 默认转换(从小到大的转换)自动类型转换也叫隐式类型转换，指的是两种数据类型在转换的过程中不需要显式地进行声明。 要实现自动类型转换，必须同时满足两个条件， 第一是两种数据类型彼此兼容， 第二是目标类型的取值范围大于源类型的取值范围。 （1）整数类型之间可以实现转换，如byte类型的数据可以赋值给short、int、long类型的变量，short、char类型的数据可以赋值给int、long类型的变量，int类型的数据可以赋值给long类型的变量（2）整数类型转换为float类型，如byte、char、short、int类型的数据可以赋值给float类型的变量。（3）其它类型转换为double类型，如byte、char、short、int、long、float类型的数据可以赋值给double类型的变量。 A：byte，short，char—int—long—float—double B：byte，short，char相互之间不转换，他们参与运算首先转换为int类型 6.2.2 强制转换：强制类型转换也叫显式类型转换，指的是两种数据类型之间的转换需要进行显式地声明。 当两种类型彼此不兼容，或者目标类型取值范围小于源类型时，自动类型转换无法进行，这时就需要进行强制类型转换。 从大的数据类型到小的数据类型格式：目标数据类型 变量 = (目标数据类型) (被转换的数据);注意：不要随意的去使用强制转换，因为它隐含了精度损失问题 12345678910111213141516171819202122java/* 面试题： byte b1=3,b2=4,b; b=b1+b2; b=3+4; 哪句是编译失败的呢？为什么呢？ b = b1 + b2;是有问题的。 因为变量相加，会首先看类型问题，最终把结果赋值的也会考虑类型问题。 常量相加，首先做加法，然后看结果是否在赋值的数据类型范围内，如果不是，才报错。*/class DataTypeDemo6 &#123; public static void main(String[] args) &#123; //定义了三个byte类型的变量，b1，b2，b3 //b1的值是3，b2的值是4，b没有值 byte b1 = 3,b2 = 4,b; //b = b1 + b2; //这个是类型提升，所有有问题 b = 3 + 4; //常量，先把结果计算出来，然后看是否在byte的范围内，如果在就不报错。 &#125;&#125; 1、在定义Long或者Float类型变量的时候，要加L或者f。 整数默认是int类型，浮点数默认是double。 byte，short在定义的时候，他们接收的其实是一个int类型的值。 这个是自己做了一个数据检测的，如果不再它们的范围内，就报错。 2、byte值的问题12345678javabyte b1 = 127;byte b2 = (byte)128; //-128byte b3 = (byte)129; //-127byte b4 = (byte)130; //-126byte的范围：-128 ~ 127128：10000000-128：10000000 (这里的1即是符号位，也是数值位) 3、数据类型转换之默认转换 byte，short，char – int – long – float – double long：8个字节 float：4个字节 A：它们底层的存储结构不同 B：float表示的数据范围比long的范围要大 long：2^63-1 float：3.4*10^38 &gt; 2*10^38 &gt; 2*8^38 = 2*2^3^38 = 2*2^114 &gt; 2^63-1 4、Java语言中的字符char可以存储一个中文汉字吗?为什么呢?可以。因为java语言中的字符占用两个字节。Java语言采用的是Unicode编码。 7. 运算符7.1 运算符 运算：对常量和变量进行操作的过程称为运算。 运算符：对常量和变量进行操作的符号称为运算符 操作数：参与运算的数据称为操作数 用运算符把常量或者变量连接起来符号java语法的式子就可以称为表达式。不同运算符连接的式子体现的是不同类型的表达式。 举例：int a = 3 + 4;这是做了一个加法运算，+就是运算符，是算术运算符，我们还有其他很多的运算符，3和4就是参与运算的操作数据，3 + 4整体其实就是一个算数表达式 7.2 算术运算符 除法的时候要注意一个问题，整数相除，只能得到整数，要想得到小数，可以*1.0 ++和–的应用单独使用：放在操作数的前面和后面效果一样。(这种用法是我们比较常见的)参与运算使用：放在操作数的前面，先自增或者自减，然后再参与运算；放在操作数的后面，先参与运算，再自增或者自减。作用：就是对变量进行自增1或者自减1。 +的用法：加法，正号，字符串连接符 运算符的优先级（由高到低） 7.3 赋值运算符基本的赋值运算符：=，把=右边的数据赋值给左边。扩展的赋值运算符：+=、-=，*=，/=，%=，+= 把左边和右边做加法，然后赋值给左边。 7.4 关系运算符 比较运算符的结果都是boolean型，也就是要么是true，要么是false。 比较运算符“==”不能误写成“=” 7.5 逻辑运算符 逻辑运算符用于连接布尔型表达式，在Java中不可以写成 3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。 “&amp;”和“&amp;&amp;”的区别 单&amp;时，左边无论真假，右边都进行运算 双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算 “|”和“||”的区别同理，双或时，左边为真，右边不参与运算 异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false 7.6 位运算符位运算是直接对二进制进行运算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960java/* 位运算符： &amp;,|,^,~ &lt;&lt;,&gt;&gt;,&gt;&gt;&gt; 注意： 要做位运算，首先要把数据转换为二进制。*/class OperatorDemo &#123; public static void main(String[] args) &#123; //&amp;,|,^,~ int a = 3; int b = 4; System.out.println(3 &amp; 4); System.out.println(3 | 4); System.out.println(3 ^ 4); System.out.println(~3); &#125;&#125;/* 分析：因为是位运算，所以我们必须先把数据换算成二进制。 3的二进制：11 00000000 00000000 00000000 00000011 4的二进制：100 00000000 00000000 00000000 00000100 &amp;位与运算：有0则0。 00000000 00000000 00000000 00000011 &amp;00000000 00000000 00000000 00000100 ----------------------------------- 00000000 00000000 00000000 00000000 结果是：0 |位或运算：有1则1。 00000000 00000000 00000000 00000011 |00000000 00000000 00000000 00000100 ----------------------------------- 00000000 00000000 00000000 00000111 结果是：7 ^位异或运算：相同则0，不同则1。 00000000 00000000 00000000 00000011 &amp;00000000 00000000 00000000 00000100 ----------------------------------- 00000000 00000000 00000000 00000111 结果是：7 ~按位取反运算符：0变1，1变0 00000000 00000000 00000000 00000011 ~11111111 11111111 11111111 11111100 (补码) 补码：11111111 11111111 11111111 11111100 反码：11111111 11111111 11111111 11111011 原码：10000000 00000000 00000000 00000100 结果是：-4*/ 7.7 三目运算符 格式：(关系表达式)?表达式1：表达式2； 如果条件为true，运算后的结果是表达式1； 如果条件为false，运算后的结果是表达式2； 示例：获取两个数中大数。123javaint x=3，y=4，z;z = (x&gt;y)?x：y；//z变量存储的就是两个数的大数。 7.8 运算符的优先级在对一些比较复杂的表达式进行运算时，要明确表达式中所有运算符参与运算的先后顺序，把这种顺序称作运算符的优先级。 7.9 MathMath类提供了常用的一些数学函数，如：三角函数、对数、指数等。一个数学公式如果想用代码表示，则可以将其拆分然后套用Math类下的方法即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586javaMath.abs(12.3); //12.3 返回这个数的绝对值 Math.abs(-12.3); //12.3 Math.copySign(1.23, -12.3); //-1.23,返回第一个参数的量值和第二个参数的符号 Math.copySign(-12.3, 1.23); //12.3 Math.signum(x); //如果x大于0则返回1.0，小于0则返回-1.0，等于0则返回0 Math.signum(12.3); //1.0 Math.signum(-12.3); //-1.0 Math.signum(0); //0.0 //指数 Math.exp(x); //e的x次幂 Math.expm1(x); //e的x次幂 - 1 Math.scalb(x, y); //x*(2的y次幂） Math.scalb(12.3, 3); //12.3*2³ //取整 Math.ceil(12.3); //返回最近的且大于这个数的整数13.0 Math.ceil(-12.3); //-12.0 Math.floor(12.3); //返回最近的且小于这个数的整数12.0 Math.floor(-12.3); //-13.0 //x和y平方和的二次方根 Math.hypot(x, y); //√（x²+y²） //返回概述的二次方根 Math.sqrt(x); //√(x) x的二次方根 Math.sqrt(9); //3.0 Math.sqrt(16); //4.0 //返回该数的立方根 Math.cbrt(27.0); //3 Math.cbrt(-125.0); //-5 //对数函数 Math.log(e); //1 以e为底的对数 Math.log10(100); //10 以10为底的对数 Math.log1p(x); //Ln（x+ 1） //返回较大值和较小值 Math.max(x, y); //返回x、y中较大的那个数 Math.min(x, y); //返回x、y中较小的那个数 //返回 x的y次幂 Math.pow(x, y); Math.pow(2, 3); //即2³ 即返回：8 //随机返回[0,1)之间的无符号double值 Math.random(); //返回最接近这个数的整数,如果刚好居中，则取偶数 Math.rint(12.3); //12.0 Math.rint(-12.3); //-12.0 Math.rint(78.9); //79.0 Math.rint(-78.9); //-79.0 Math.rint(34.5); //34.0 Math.rint(35.5); //36.0 Math.round(12.3); //与rint相似，返回值为long //三角函数 Math.sin(α); //sin（α）的值 Math.cos(α); //cos（α）的值 Math.tan(α); //tan（α）的值 //求角 Math.asin(x/z); //返回角度值[-π/2，π/2] arc sin（x/z） Math.acos(y/z); //返回角度值[0~π] arc cos（y/z） Math.atan(y/x); //返回角度值[-π/2，π/2] Math.atan2(y-y0, x-x0); //同上，返回经过点（x，y）与原点的的直线和经过点（x0，y0）与原点的直线之间所成的夹角 Math.sinh(x); //双曲正弦函数sinh(x)=(exp(x) - exp(-x)) / 2.0; Math.cosh(x); //双曲余弦函数cosh(x)=(exp(x) + exp(-x)) / 2.0; Math.tanh(x); //tanh(x) = sinh(x) / cosh(x); //角度弧度互换 360°角=2π弧度Math.toDegrees(angrad); //角度转换成弧度，返回：angrad * 180d / PI Math.toRadians(angdeg); //弧度转换成角度，返回：angdeg / 180d * PI Math.PI Java语法基础-21. 语句1.1 流程控制语句在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。也就是说程序的流程对运行结果有直接的影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。 流程控制语句分类：顺序结构、选择结构、循环结构 1.2 顺序结构概述是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。 总的来说：写在前面的先执行，写在后面的后执行 1.3 选择结构选择结构也被称为分支结构。选择结构有特定的语法规则，代码要执行具体的逻辑运算进行判断，逻辑运算的结果有两个，所以产生选择，按照不同的选择执行不同的代码。 Java语言提供了两种选择结构语句：（1）if语句（2）switch语句 1.3.1 选择结构(if语句)if语句有三种格式 if语句第一种格式：123if(关系表达式) &#123; 语句体&#125; 执行流程： 首先判断关系表达式看其结果是true还是false 如果是true就执行语句体 如果是false就不执行语句体 注意事项： 关系表达式无论简单还是复杂，结果必须是boolean类型 if语句控制的语句体如果是一条语句，大括号可以省略；如果是多条语句，就不能省略。建议永远不要省略。 一般来说：有左大括号就没有分号，有分号就没有左大括号 if语句第二种格式：12345if(关系表达式) &#123; 语句体1;&#125;else &#123; 语句体2;&#125; 执行流程： 首先判断关系表达式看其结果是true还是false 如果是true就执行语句体1 如果是false就执行语句体2 12345678910111213141516171819202122232425262728293031323334353637383940414243java/* if语句格式2的练习： A:获取两个数据中较大的值 B:判断一个数据是奇数还是偶数,并输出是奇数还是偶数*/ import java.util.Scanner; class IfTest &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //获取两个数据中较大的值 System.out.println("请输入第一个数据："); int a = sc.nextInt(); System.out.println("请输入第二个数据："); int b = sc.nextInt(); //定义一个变量接收最大值 int max; if(a &gt; b) &#123; max = a; &#125;else &#123; max = b; &#125; System.out.println("max:"+max); System.out.println("----------------"); //判断一个数据是奇数还是偶数 System.out.println("请输入你要判断的数据："); int x = sc.nextInt(); if(x%2 == 0) &#123; System.out.println(x+"这个数据是偶数"); &#125;else &#123; System.out.println(x+"这个数据是奇数"); &#125; &#125; &#125; 运行结果： if语句第三种格式：123456789if(关系表达式1) &#123; 语句体1;&#125;else if (关系表达式2) &#123; 语句体2;&#125;…else &#123; 语句体n+1;&#125; 执行流程： 首先判断关系表达式1看其结果是true还是false 如果是true就执行语句体1 如果是false就继续判断关系表达式2看其结果是true还是false 如果是true就执行语句体2 如果是false就继续判断关系表达式…看其结果是true还是false… 如果没有任何关系表达式为true，就执行语句体n+1。 java/* 三种if语句分别适合做什么事情呢? 格式1：适合做单个判断 格式2：适合做两个判断 格式3：适合做多个判断 需求： 键盘录入x的值，计算出y的并输出。 x&gt;=3 y = 2x + 1; -1&lt;=x&lt;3 y = 2x; x&lt;=-1 y = 2x – 1; 分析： A:由于数据要键盘录入，所以必须使用Scanner。 B:由于是三种判断，所以我们选择if语句格式3。 */import java.util.Scanner; class IfTest2 { public static void main(String[] args) { //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入x的值：&quot;); int x = sc.nextInt(); //定义一个y int y; //用if语句格式3进行判断 if(x &gt;= 3) { y = 2*x + 1; }else if(x&gt;=-1 &amp;&amp; x&lt;3) { y = 2*x; }else { y = 2*x - 1; } System.out.println(&quot;y:&quot;+y); } }1运行结果： switch语句格式：123456789101112switch(表达式) &#123; case 值1： 语句体1; break; case 值2： 语句体2; break; … default： 语句体n+1; break;&#125; 格式解释 switch表示这是switch语句 表达式的取值：byte，short，int，char JDK5以后可以是枚举 JDK7以后可以是String case后面跟的是要和表达式进行比较的值 语句体部分可以是一条或多条语句 break表示中断，结束的意思，可以结束switch语句 default语句表示所有情况都不匹配的时候，就执行该处的内容，和if语句的else相似。 执行流程 首先计算出表达式的值 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546java/* 用switch语句实现键盘录入月份，输出对应的季节 分析： A:键盘录入一个月份，用Scanner实现 B:用switch语句实现即可*/ import java.util.Scanner; class SwitchTest4 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //录入数据 System.out.println("请输入月份(1-12)："); int month = sc.nextInt(); //case穿透 switch(month) &#123; case 1: case 2: case 12: System.out.println("冬季"); break; case 3: case 4: case 5: System.out.println("春季"); break; case 6: case 7: case 8: System.out.println("夏季"); break; case 9: case 10: case 11: System.out.println("秋季"); break; default: System.out.println("你输入的月份有误"); &#125; &#125; &#125; 运行结果： （3）if语句和switch语句的区别?if语句： A:针对结果是boolean类型的判断 B:针对一个范围的判断 C:针对几个常量值的判断 switch语句：针对几个常量值的判断 注意事项： case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的 default可以省略吗?可以省略。一般不建议。除非判断的值是固定的。 break可以省略吗?可以省略，一般不建议。否则结果可能不是你想要的 default的位置一定要在最后吗?可以出现在switch语句任意位置。 switch语句的结束条件，遇到break执行到程序的末尾 2. 循环结构循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环。 2.1 循环语句的组成 初始化语句：一条或者多条语句，这些语句完成一些初始化操作 判断条件语句：这是一个boolean 表达式，这个表达式能决定是否执行循环体 循环体语句：这个部分是循环体语句，也就是我们要多次做的事情 控制条件语句：这个部分在一次循环体结束后，下一次循环判断条件执行前执行。通过用于控制循环条件中的变量，使得循环在合适的时候结束 2.2 for循环语句格式1234javafor(初始化语句;判断条件语句;控制条件语句) &#123; 循环体语句;&#125; 执行流程 执行初始化语句 执行判断条件语句，看其结果是true还是false 如果是false，循环结束 如果是true，继续执行 执行循环体语句 执行控制条件语句 回到B继续 注意事项 判断条件语句的结果是一个boolean类型 循环体语句如果是一条语句，大括号可以省略；如果是多条语句，大括号不能省略。建议永远不要省略。 一般来说：有左大括号就没有分号，有分号就没有左大括号 2.3 for语句的练习代码示例：在控制台输出所有的”水仙花数”12345678910111213141516171819202122232425262728293031323334353637383940414243java/* 需求：在控制台输出所有的”水仙花数” 分析： 我们都不知道什么叫"水仙花数"，你让我怎么做呢? 所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。 举例：153就是一个水仙花数。 153 = 1*1*1 + 5*5*5 + 3*3*3 = 1 + 125 + 27 = 153 A:三位数其实是告诉了我们范围。 B:通过for循环我们就可以实现获取每一个三位数 但是麻烦是如何获取这个三位数的个,十,百位上的数据 我们如何获取一个数据的个,十,百呢? 假设有个一个数据:153 ge: 153%10 = 3 shi: 153/10%10 = 5 bai：153/10/10%10 = 1 qian：x/10/10/10%10 wan: x/10/10/10/10%10 ... C:让ge*ge*ge+shi*shi*shi+bai*bai*bai和该数据比较 如果相同，就把该数据在控制台输出。*/ class ForDemo6 &#123; public static void main(String[] args) &#123; //三位数其实是告诉了我们范围。 for(int x=100; x&lt;1000; x++) &#123; int ge = x%10; int shi = x/10%10; int bai = x/10/10%10; //让ge*ge*ge+shi*shi*shi+bai*bai*bai和该数据比较 if(x == (ge*ge*ge+shi*shi*shi+bai*bai*bai)) &#123; //如果相同，就把该数据在控制台输出。 System.out.println(x); &#125; &#125; &#125; &#125; 运行结果： 代码示例：回文数12345678910111213141516171819202122232425262728293031java/* 练习： 请在控制台输出满足如下条件的五位数 个位等于万位 十位等于千位 个位+十位+千位+万位=百位 分析： A:五位数就告诉了我们范围。 B:分解每一个五位数的个，十，百，千，万位上的数据 C:按照要求进行判断即可*/ class ForDemo7 &#123; public static void main(String[] args) &#123; //五位数就告诉了我们范围。 for(int x=10000; x&lt;100000; x++) &#123; //分解每一个五位数的个，十，百，千，万位上的数据 int ge = x%10; int shi = x/10%10; int bai = x/10/10%10; int qian = x/10/10/10%10; int wan = x/10/10/10/10%10; //按照要求进行判断即可 if((ge==wan) &amp;&amp; (shi==qian) &amp;&amp; (ge+shi+qian+wan==bai)) &#123; System.out.println(x); &#125; &#125; &#125; &#125; 运行结果： 2.4 while循环语句格式基本格式1234javawhile(判断条件语句) &#123; 循环体语句;&#125; 扩展格式123456java初始化语句;while(判断条件语句) &#123; 循环体语句; 控制条件语句;&#125; 循环结构(for循环和while循环的区别)：for循环语句和while循环语句可以等价转换，但还是有些小区别的 使用区别：控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率。 场景区别：for循环适合针对一个范围判断进行操作,while循环适合判断次数不明确操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344java/* 练习：用while循环实现 左边：求出1-100之和 右边：统计水仙花数有多少个 初始化语句; while(判断条件语句) &#123; 循环体语句; 控制条件语句; &#125; for(初始化语句;判断条件语句;控制条件语句) &#123; 循环体语句; &#125;*/ class WhileDemo2 &#123; public static void main(String[] args) &#123; //求出1-100之和 //for语句版本 int sum = 0; for(int x=1; x&lt;=100; x++) &#123; sum+=x; &#125; System.out.println("sum:"+sum); System.out.println("--------"); //while语句版本 int sum2 = 0; int y=1; while(y&lt;=100) &#123; sum2+=y; y++; &#125; System.out.println("sum2:"+sum2); System.out.println("--------"); &#125; &#125; 运行结果： 1234567891011121314151617181920212223242526272829303132333435363738394041java/* 需求：统计水仙花数有多少个*/ class WhileDemo3 &#123; public static void main(String[] args) &#123; //for循环版本 int count = 0; for(int x=100; x&lt;1000; x++) &#123; int ge = x%10; int shi = x/10%10; int bai = x/10/10%10; if((ge*ge*ge+shi*shi*shi+bai*bai*bai) == x) &#123; count++; &#125; &#125; System.out.println("count:"+count); System.out.println("------------"); //while循环版本 int count2 = 0; int y = 100; while(y&lt;1000) &#123; int ge = y%10; int shi = y/10%10; int bai = y/10/10%10; if((ge*ge*ge+shi*shi*shi+bai*bai*bai) == y) &#123; count2++; &#125; y++; &#125; System.out.println("count2:"+count2); &#125; &#125; 运行结果： 2.4 while循环和for循环的区别?使用区别：如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。不知道用for循环。因为变量及早的从内存中消失，可以提高内存的使用效率。 其实还有一种场景的理解:如果是一个范围的，用for循环非常明确。如果是不明确要做多少次，用while循环较为合适。举例：吃葡萄。 1234567891011121314151617181920javaclass WhileDemo4 &#123; public static void main(String[] args) &#123; //for循环实现 for(int x=0; x&lt;10; x++) &#123; System.out.println("学习Java技术哪家强,中国北京传智播客"); &#125; //这里不能在继续访问了 //System.out.println(x); //while循环实现 int y = 0; while(y&lt;10) &#123; System.out.println("学习Java技术哪家强,中国北京传智播客"); y++; &#125; //这里是可以继续访问的 System.out.println(y); &#125; &#125; 2.5 do…while循环语句格式基本格式1234javado &#123; 循环体语句;&#125;while((判断条件语句); 扩展格式123456java初始化语句;do &#123; 循环体语句; 控制条件语句;&#125; while((判断条件语句); 注意死循环： A:一定要注意控制条件语句控制的那个变量的问题，不要弄丢了，否则就容易死循环。B:两种最简单的死循环格式123javawhile(true)&#123;...&#125;for(;;)&#123;...&#125; 2.6 循环嵌套代码示例：九九表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748java/* 需求：在控制台输出九九乘法表。 首先我们写出九九乘法表： 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 ... 1*9=9 2*9=18 3*9=27 ... 我们先把这个九九乘法表看出是这样的一个形状： * ** *** **** ***** ****** ******* ******** ********* 注意： '\x' x表示任意，这种做法叫转移字符。 '\t' tab键的位置 '\r' 回车 '\n' 换行*/ class ForForDemo3 &#123; public static void main(String[] args) &#123; for(int x=0; x&lt;9; x++) &#123; for(int y=0; y&lt;=x; y++) &#123; System.out.print("*"); &#125; System.out.println(); &#125; System.out.println("--------------"); //为了使用数据，我们从1开始 for(int x=1; x&lt;=9; x++) &#123; for(int y=1; y&lt;=x; y++) &#123; System.out.print(y+"*"+x+"="+y*x+"\t"); &#125; System.out.println(); &#125; &#125; &#125; 运行结果： 2.7 跳转控制语句Java中的goto是保留字，目前不能使用。虽然没有goto语句可以增强程序的安全性，但是也带来很多不便，比如说，我想在某个循环知道到某一步的时候就结束，现在就做不了这件事情。为了弥补这个缺陷，Java就提供了break，continue和return来实现控制语句的跳转和中断。 break 中断、continue 继续、return 返回 2.7.1 break的使用场景 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的 2.7.2 break的作用 跳出单层循环 跳出多层循环带标签的跳出格式：标签名: 循环语句标签名要符合Java的命名规则 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849java/* 控制跳转语句： break:中断 continue:继续 return:返回 break:中断的意思 使用场景： A:switch语句中 B:循环语句中。 (循环语句中加入了if判断的情况) 注意：离开上面的两个场景，无意义。 如何使用呢? A:跳出单层循环 B:跳出多层循环 要想实现这个效果，就必须知道一个东西。带标签的语句。 格式： 标签名: 语句*/ class BreakDemo &#123; public static void main(String[] args) &#123; //在 switch 或 loop 外部中断 //break; //跳出单层循环 for(int x=0; x&lt;10; x++) &#123; if(x == 3) &#123; break; &#125; System.out.println("HelloWorld"); &#125; System.out.println("over"); System.out.println("-------------"); wc:for(int x=0; x&lt;3; x++) &#123; nc:for(int y=0; y&lt;4; y++) &#123; if(y == 2) &#123; //break nc; break wc; &#125; System.out.print("*"); &#125; System.out.println(); &#125; &#125; &#125; 2.7.3 continue的使用场景 在循环语句中 离开使用场景的存在是没有意义的 2.7.4 continue的作用 单层循环对比break，然后总结两个的区别 break 退出当前循环 continue 退出本次循环 也可以带标签的使用 12345678910111213141516171819202122232425262728293031323334353637383940java/* continue:继续 使用场景： 循环中。离开此场景无意义。 测试，找到和break的区别： break:跳出单层循环 continue:跳出一次循环，进入下一次的执行 练习题： for(int x=1; x&lt;=10; x++) &#123; if(x%3==0) &#123; //在此处填写代码 &#125; System.out.println(“Java基础班”); &#125; 我想在控制台输出2次:“Java基础班“ break; 我想在控制台输出7次:“Java基础班“ continue; 我想在控制台输出13次:“Java基础班“ System.out.println(“Java基础班”);*/ class ContinueDemo &#123; public static void main(String[] args) &#123; for(int x=0; x&lt;10; x++) &#123; if(x == 3) &#123; //break; continue; &#125; System.out.println(x); &#125; &#125; &#125; 2.7.5 return关键字不是为了跳转出循环体，更常用的功能是结束一个方法，也就是退出一个方法。跳转到上层调用的方法。这个在方法的使用那里会在详细的讲解 12345678910111213141516171819202122java/* return:返回 其实它的作用不是结束循环的，而是结束方法的。*/ class ReturnDemo &#123; public static void main(String[] args) &#123; for(int x=0; x&lt;10; x++) &#123; if(x == 2) &#123; System.out.println("退出"); //break; //continue; return; &#125; System.out.println(x); &#125; System.out.println("over"); &#125; &#125; 3. 方法3.1 方法概述假设有一个游戏程序，程序在运行过程中，要不断地发射炮弹(植物大战僵尸)。发射炮弹的动作需要编写100行的代码，在每次实现发射炮弹的地方都需要重复地编写这100行代码，这样程序会变得很臃肿，可读性也非常差。为了解决代码重复编写的问题，可以将发射炮弹的代码提取出来放在一个{}中，并为这段代码起个名字，这样在每次发射炮弹的地方通过这个名字来调用发射炮弹的代码就可以了。上述过程中，所提取出来的代码可以被看作是程序中定义的一个方法，程序在需要发射炮弹时调用该方法即可。 3.2 方法定义及格式1、简单的说：方法就是完成特定功能的代码块 在很多语言里面都有函数的定义，函数在Java中被称为方法2、格式：12345Java修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2…) &#123; 函数体; return 返回值; &#125; 3.3 方法格式解释 修饰符 比较多，后面会详细介绍。目前public static 返回值类型 用于限定返回值的数据类型 方法名 一个名称，为了方便我们调用方法 参数类型 限定调用方法时传入参数的数据类型 参数名 是一个变量，接收调用方法时传入的参数 方法体 完成功能的代码 return 结束方法以及返回方法指定类型的值 返回值 程序被return带回的结果，返回给调用者 3.4 有明确返回值的方法调用 单独调用，没有意义 输出调用，有意义，但是不够好，因为我不一定非要把结果输出 赋值调用，推荐方式 注意事项： 方法不调用不执行 方法与方法是平级关系，不能嵌套定义 方法定义的时候参数之间用逗号隔开 方法调用的时候不用在传递数据类型 如果方法有明确的返回值，一定要有return带回一个值 3.5 没有明确返回值的函数调用 其实就是void类型方法的调用 只能单独调用 3.6 方法调用图解 3.7 方法重载 方法重载概述 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 方法重载特点 与返回值类型无关，只看方法名和参数列表 在调用时，虚拟机通过参数列表的不同来区分同名方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445java/* 比较两个数据是否相等。参数类型分别为 两个byte类型，两个short类型，两个int类型，两个long类型， 并在main方法中进行测试*/ class FunctionTest6 &#123; public static void main(String[] args) &#123; //测试 byte b1 = 3; byte b2 = 4; System.out.println("byte:"+compare(b1,b2)); //测试 short s1 = 5; short s2 = 5; System.out.println("short:"+compare(s1,s2)); //后面的两个自己测试 &#125; //byte类型 public static boolean compare(byte a,byte b) &#123; System.out.println("byte"); return a == b; &#125; //short类型 public static boolean compare(short a,short b) &#123; System.out.println("short"); return a == b; &#125; //int类型 public static boolean compare(int a,int b) &#123; System.out.println("int"); return a == b; &#125; //long类型 public static boolean compare(long a,long b) &#123; System.out.println("long"); return a == b; &#125; &#125; 运行结果： 4. 数组4.1 数组概述需求：现在需要统计某公司员工的工资情况，例如计算平均工资、找到最高工资等。假设该公司有80名员工，用前面所学的知识，程序首先需要声明80个变量来分别记住每位员工的工资，然后在进行操作，这样做会显得很麻烦。为了解决这种问题，Java就提供了数组供我们使用 那么数组到底是什么呢?有什么特点呢?通过上面的分析：我们可以得到如下两句话： 数组是存储多个变量(元素)的东西(容器) 这多个变量的数据类型要一致 4.2 数组概念 数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器 数组既可以存储基本数据类型，也可以存储引用数据类型 4.3 数组的定义格式格式1：数据类型[] 数组名;格式2：数据类型 数组名[];注意：这两种定义做完了，数组中是没有元素值的 4.4 数组初始化概述： Java中的数组必须先初始化,然后才能使用 所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋值 数组的初始化方式 动态初始化：初始化时只指定数组长度，由系统为数组分配初始值。 静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度 动态初始化：初始化时只指定数组长度，由系统为数组分配初始值 格式：数据类型[] 数组名 = new 数据类型[数组长度];数组长度其实就是数组中元素的个数。举例：int[] arr = new int[3];解释：定义了一个int类型的数组，这个数组中可以存放3个int类型的值。 4.5 Java中的内存分配Java 程序在运行时，需要在内存中的分配空间。为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。 栈 存储局部变量 堆 存储new出来的东西 方法区 (面向对象部分讲) 本地方法区 (和系统相关) 寄存器 (给CPU使用) 4.6 Java中数组的内存图解图解1：定义一个数组，输出数组名及元素。然后给数组中的元素赋值，再次输出数组名及元素。 图解2：定义两个数组，分别输出数组名及元素。然后分别给数组中的元素赋值，分别再次输出数组名及元素。 图解3：定义两个数组，先定义一个数组，赋值，输出。然后定义第二个数组的时候把第一个数组的地址赋值给第二个数组。然后给第二个数组赋值，再次输出两个数组的名及元素。 4.7 数组的初始化静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…};举例：int[] arr = new int[]{1,2,3};解释：定义了一个int类型的数组，这个数组中可以存放3个int类型的值，并且值分别是1,2,3。其实这种写法还有一个简化的写法：int[] arr = {1,2,3}; 4.8 数组操作常见的两个小问题 ArrayIndexOutOfBoundsException 数组索引越界访问到了数组中的不存在的索引时发生 NullPointerException 空指针异常数组引用没有指向实体，却在操作实体中的元素时。 4.9 二维数组概述二维数组概述 我们传智播客的Java基础班每个班有很多个学生，所以，可以用数组来存储，而我们又同时有很多个Java基础班。这个也应该用一个数组来存储。如何来表示这样的数据呢?Java就提供了二维数组供我们使用。由此可见：其实二维数组其实就是一个元素为一维数组的数组。 二维数组定义格式（1）格式11234java数据类型[][] 变量名 = new 数据类型[m][n];// m表示这个二维数组有多少个一维数组// n表示每一个一维数组的元素个数 举例：123456javaint[][] arr = new int[3][2];// 定义了一个二维数组arr// 这个二维数组有3个一维数组，名称是arr[0],arr[1],arr[2]// 每个一维数组有2个元素，可以通过arr[m][n]来获取// 表示获取第m+1个一维数组的第n+1个元素 （2）格式21234java数据类型[][] 变量名 = new 数据类型[m][];// m表示这个二维数组有多少个一维数组// 这一次没有直接给出一维数组的元素个数，可以动态的给出。 举例：12345javaint[][] arr = new int[3][];arr[0] = new int[2];arr[1] = new int[3]arr[2] = new int[1]; （3）格式31234java数据类型[][] 变量名 = new 数据类型[][]&#123;&#123;元素…&#125;,&#123;元素…&#125;,&#123;元素…&#125;&#125;;简化版格式：数据类型[][] 变量名 = &#123;&#123;元素…&#125;,&#123;元素…&#125;,&#123;元素…&#125;&#125;;举例：int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,6&#125;,&#123;6&#125;&#125;; 4.10 数组常见操作4.10.1 数组遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071java/* 数组遍历：就是依次输出数组中的每一个元素。 注意：数组提供了一个属性length，用于获取数组的长度。 格式：数组名.length*/ class ArrayTest &#123; public static void main(String[] args) &#123; //定义数组 int[] arr = &#123;11,22,33,44,55&#125;; //获取每一个元素 //如何获取呢?我们知道数组名结合编号(索引)就可以找到数据 for(int x=0; x&lt;5; x++) &#123; //x=0,1,2,3,4 System.out.println(arr[x]); &#125; System.out.println("--------------------"); //从0开始我们是明确的，但是为什么到5呢，我们是数了一下数组的个数 //继续看下个数组如何遍历 int[] arr2 = &#123;1,2,3,4,5,6,7,8,9,10,11,2,2,3,4,5,7,8,5,3,5,6,8,7,8,5,3,5,6,8,7,8,5,3,5,6,8,7,8,5,3,5,6,8,7,8,5,3,5,6,8&#125;; //而我们在很多时候，数组的元素不能靠数 //这个时候，数组就给我们提供了一个属性：length专门用于获取数组的长度 //格式：数组名.length 返回数组的长度 System.out.println(arr.length); System.out.println(arr2.length); System.out.println("--------------------"); //改进第一个程序 for(int x=0; x&lt;arr.length; x++) &#123; System.out.println(arr[x]); &#125; System.out.println("--------------------"); //我们如果想要对多个数组进行遍历，每个数组的遍历我们都把代码写一遍，麻烦不 //麻烦，所以，我们准备用方法改进。 //用方法改进后，请调用 printArray(arr); System.out.println("--------------------"); printArray(arr2); System.out.println("--------------------"); printArray2(arr); &#125; /* 遍历数组的方法 两个明确： 返回值类型：void 参数列表：int[] arr */ public static void printArray(int[] arr) &#123; for(int x=0; x&lt;arr.length; x++) &#123; System.out.println(arr[x]); &#125; &#125; //请看改进版本 public static void printArray2(int[] arr) &#123; System.out.print("["); for(int x=0; x&lt;arr.length; x++) &#123; if(x == arr.length-1) &#123; //这是最后一个元素 System.out.println(arr[x]+"]"); &#125;else &#123; System.out.print(arr[x]+", "); &#125; &#125; &#125; &#125; 4.10.2 获取数组最值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374java/* 数组获取最值(获取数组中的最大值最小值) 分析： A:定义一个数组，并对数组的元素进行静态初始化。 B:从数组中任意的找一个元素作为参照物(一般取第一个),默认它就是最大值。 C:然后遍历其他的元素，依次获取和参照物进行比较，如果大就留下来，如果小，就离开。 D:最后参照物里面保存的就是最大值。*/ class ArrayTest2 &#123; public static void main(String[] args) &#123; //定义一个数组 int[] arr = &#123;34,98,10,25,67&#125;; //请获取数组中的最大值 /* //从数组中任意的找一个元素作为参照物 int max = arr[0]; //然后遍历其他的元素 for(int x=1; x&lt;arr.length; x++) &#123; //依次获取和参照物进行比较，如果大就留下来，如果小，就离开。 if(arr[x] &gt; max) &#123; max = arr[x]; &#125; &#125; //最后参照物里面保存的就是最大值。 System.out.println("max:"+max); */ //把这个代码用方法改进 //调用方法 int max = getMax(arr); System.out.println("max:"+max); //请获取数组中的最小值 int min = getMin(arr); System.out.println("min:"+min); &#125; /* 需求：获取数组中的最大值 两个明确： 返回值类型：int 参数列表：int[] arr */ public static int getMax(int[] arr) &#123; //从数组中任意的找一个元素作为参照物 int max = arr[0]; //然后遍历其他的元素 for(int x=1; x&lt;arr.length; x++) &#123; //依次获取和参照物进行比较，如果大就留下来，如果小，就离开。 if(arr[x] &gt; max) &#123; max = arr[x]; &#125; &#125; //最后参照物里面保存的就是最大值。 return max; &#125; public static int getMin(int[] arr) &#123; //从数组中任意的找一个元素作为参照物 int min = arr[0]; //然后遍历其他的元素 for(int x=1; x&lt;arr.length; x++) &#123; //依次获取和参照物进行比较，如果小就留下来，如果大，就离开。 if(arr[x] &lt; min) &#123; min = arr[x]; &#125; &#125; //最后参照物里面保存的就是最小值。 return min; &#125; &#125; 运行结果： 4.10.3 数组元素逆序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879java/* 数组元素逆序 (就是把元素对调) 分析： A:定义一个数组，并进行静态初始化。 B:思路 把0索引和arr.length-1的数据交换 把1索引和arr.length-2的数据交换 ... 只要做到arr.length/2的时候即可。*/ class ArrayTest3 &#123; public static void main(String[] args) &#123; //定义一个数组，并进行静态初始化。 int[] arr = &#123;12,98,50,34,76&#125;; //逆序前 System.out.println("逆序前："); printArray(arr); //逆序后 System.out.println("逆序后："); //reverse(arr); reverse2(arr); printArray(arr); &#125; /* 需求：数组逆序 两个明确： 返回值类型：void (有人会想到应该返回的是逆序后的数组，但是没必要，因为这两个数组其实是同一个数组) 参数列表：int[] arr */ public static void reverse(int[] arr) &#123; /* //第一次交换 int temp = arr[0]; arr[0] = arr[arr.length-1-0]; arr[arr.length-1-0] = temp; //第二次交换 int temp = arr[1]; arr[1] = arr[arr.length-1-1]; arr[arr.length-1-1] = temp; //第三次交换 int temp = arr[2]; arr[2] = arr[arr.length-1-2]; arr[arr.length-1-2] = temp; */ //用循环改进 for(int x=0; x&lt;arr.length/2; x++) &#123; int temp = arr[x]; arr[x] = arr[arr.length-1-x]; arr[arr.length-1-x] = temp; &#125; &#125; public static void reverse2(int[] arr) &#123; for(int start=0,end=arr.length-1; start&lt;=end; start++,end--) &#123; int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &#125; &#125; //遍历数组 public static void printArray(int[] arr) &#123; System.out.print("["); for(int x=0; x&lt;arr.length; x++) &#123; if(x == arr.length-1) &#123; //这是最后一个元素 System.out.println(arr[x]+"]"); &#125;else &#123; System.out.print(arr[x]+", "); &#125; &#125; &#125; &#125; 运行结果： 4.10.4 数组基本查找1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768java/* 需求：数组元素查找(查找指定元素第一次在数组中出现的索引) 分析： A:定义一个数组，并静态初始化。 B:写一个功能实现 遍历数组，依次获取数组中的每一个元素，和已知的数据进行比较 如果相等，就返回当前的索引值。*/ class ArrayTest5 &#123; public static void main(String[] args) &#123; //定义一个数组，并静态初始化 int[] arr = &#123;200,250,38,888,444&#125;; //需求：我要查找250在这个数组中第一次出现的索引 int index = getIndex(arr,250); System.out.println("250在数组中第一次出现的索引是："+index); int index2 = getIndex2(arr,250); System.out.println("250在数组中第一次出现的索引是："+index2); int index3 = getIndex2(arr,2500); System.out.println("2500在数组中第一次出现的索引是："+index3); &#125; /* 需求：查找指定数据在数组中第一次出现的索引 两个明确： 返回值类型：int 参数列表：int[] arr,int value */ public static int getIndex(int[] arr,int value) &#123; //遍历数组，依次获取数组中的每一个元素，和已知的数据进行比较 for(int x=0; x&lt;arr.length; x++) &#123; if(arr[x] == value) &#123; //如果相等，就返回当前的索引值。 return x; &#125; &#125; //目前的代码有一个小问题 //就是假如我要查找的数据在数组中不存在，那就找不到，找不到，你就对应的返回吗? //所以报错。 //只要是判断，就可能是false，所以大家要细心。 //如果找不到数据，我们一般返回一个负数即可，而且是返回-1 return -1; &#125; public static int getIndex2(int[] arr,int value) &#123; //定义一个索引 int index = -1; //有就修改索引值 for(int x=0; x&lt;arr.length; x++) &#123; if(arr[x] == value) &#123; index = x; break; &#125; &#125; //返回index return index; &#125; &#125; 运行结果： 4.11 随机点名器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364javapackage cn.itcast.chapter02.task03;import java.util.Random;import java.util.Scanner;/** * 随机点名器 */public class CallName &#123; /** * 1.存储全班同学姓名 创建一个存储多个同学姓名的容器（数组） 键盘输入每个同学的姓名，存储到容器中（数组） */ public static void addStudentName(String[] students) &#123; // 键盘输入多个同学姓名存储到容器中 Scanner sc = new Scanner(System.in); for (int i = 0; i &lt; students.length; i++) &#123; System.out.println("存储第" + (i + 1) + "个姓名："); // 接收控制台录入的姓名字符串 students[i] = sc.next(); &#125; &#125; /** * 2.总览全班同学姓名 */ public static void printStudentName(String[] students) &#123; // 遍历数组，得到每个同学姓名 for (int i = 0; i &lt; students.length; i++) &#123; String name = students[i]; // 打印同学姓名 System.out.println("第" + (i + 1) + "个学生姓名：" + name); &#125; &#125; /** * 3.随机点名其中一人 */ public static String randomStudentName(String[] students) &#123; // 根据数组长度，获取随机索引 int index = new Random().nextInt(students.length); // 通过随机索引从数组中获取姓名 String name = students[index]; // 返回随机点到的姓名 return name; &#125; public static void main(String[] args) &#123; System.out.println("--------随机点名器--------"); // 创建一个可以存储多个同学姓名的容器（数组） String[] students = new String[3]; /* * 1.存储全班同学姓名 */ addStudentName(students); /* * 2.总览全班同学姓名 */ printStudentName(students); /* * 3.随机点名其中一人 */ String randomName = randomStudentName(students); System.out.println("被点到名的同学是 :" + randomName); &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的秋招进度表]]></title>
    <url>%2F2018%2F07%2F07%2F%E6%88%91%E7%9A%84%E7%A7%8B%E6%8B%9B%E8%BF%9B%E5%BA%A6%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[密码不能告诉你 Decrypt U2FsdGVkX1+1nzj5R+wnfm3L5QDTlmoOxf5aJ3p/DnQ2/HqAqRW15cdfguEu/eOIc12oE/7gYyIswdeLBY/mDqQ1siRUf6peAqedHkciQkRETKm2EeOCdnQT8cndgPpExRMx1mth5G8FgzegN9+DhZeVK/e58EqOrYEmfHLuyBczI/T3rhLYC4dlaQl1Hs0LpSNVFafOMr5CAreOAXe/fsu4hBHWnD/q9IuWWfzdKyRTZJbYv9VFTLta7ruh4GSvpbeZtBOKYupAhCvO2t6BhRgy7rBet+8fQZ3cOMm19FE5fd6rK4xHt0LEQwCq3udjDx9TodJI35QOqqX2oZYKJK5WjdJrSB34vRINRTChDth47I7fwtq3g7v43/bNTdcQAg540QwozTTXp9MAdSBf8ZWD/AxtdsHTP7T9YW/qbD72zKypkCCK1KRzSq+fskv/ZGNUW3EmSr5u4U1XptfrZrEapQG3RD+9eqwaVMXDrN9xV12Az4hR113g2oBa+LgD9KLDxMiFA6415O5ou3zhGGbiFEQL0dBCt6q1aA8c+jGtd2IZjTdsyoUy7hfrgTOMpxnRqDtcPAOkBz6kZlYBfIf6XoTjsYZTv1u9fxVrYS5vfAxYt3MMHPtP1+f8hrYKXUnZNuH87VeRWyMXdNj2DjA36qUPOKEcnk4JCiXbWxHFLTsk+c3VSNOAnq2KNe/EjwgZiw02U3ysgL4UjhR4bRERCvlTX6HRdrsqZIKBIs+e2nUw+N7A5Czdd/isYJ5QMpjN39mbzhFMaN9J6pG4dvkUWy1j/sPG4YplshOJYRlnZVwTA4J4TDGtsckon6efcsYNs77o0YizwBGiA5y3LvVgtHexEqI7bTj/9XeezyxL7U4Ews92TGdiJQE5MnyarwVBkrtEdDOYLVNxT+CMK3A4Ek6sF4iumvggIBHHZR5KXK4bYk5YxAcF9wDh+yj6hJ48Sc7142BN3b9oIk/w+PSV8t1mDs/wgrZwtKXcCfRTn4genhCW+7jqM1nRIx9LWSVymagolVJ1hwz0Zc5n9vT2YWnuP7hAzoza38lzCq+7rUjjPCpt/MT6GdZa6cusfrWz/G9a5VriSkeEi2BcPW0P6Kmlrm8g3kE67zOsLDk1bgEIJZ0eJG5kmgv6xLr4pYy1kwJ80zJa8rOvwT0GRT3Fb7dRXdQRI9Tt3/TZBTc2+gr49pMggcIHfw6fJE0NqfOx2ZNXC4C5uQW3rB05PKg/hih/u75wqV6+NuxG4lUAKrRRdTaIJRJ/LgMv0TJgJdWLoUrLQijmCVoi3rvVVExZd65d3nw3ISZcJtpADkKg46V74X8cMibtd452upI41gZ+gxSmCQ5jyAwflHQALk7WDBnwrEDM2QVcydm4jKJtcTSY2zDKPONQicVf9nmkWMpIQYmPNb3wKj+3vLtsc6Aa2HJVnKU/rEMZnEzZmy1Nj1pYkAkZ8a3/Ndn1IKKaB8iNK1XlNMqrM4nL5sB206GPGTzpqvs6ynXXIfOtOFsTp2EmI8GUZHlQjXPdz++Q8dYyh9z6KQrbAizANpZvZAcDRqckmRE15vT6ROppV/JCmqwk48BIGCHjM1LpIn34G46B3JqfZweU9bR+2ECaax9n/BClH2pgNMhBFOHwIE+JNzxIBqM3m7nhDcW2hXnU3RGNOu9UhaKGRxGl4x2qvZ5jXTuuArvMYnxFcwvJKUpq/ieTaJS3kPTy+wSVYJcShUREK7JaY6IOiz+bap0Nr6gVexi6mZ0AhiCuZaBC4XIcmPRWk58kOhRKJhUtCkQzjgiZ0MQKgkDTsQGwDObfGIZDsqk323rnGXkmSkxB6Ngy0nXwh14eX3a9Pr52pRC7oL7hCdWMnfRk3RcXPDx0fQ9gUp/HWQesp+91QWIewPl0/JLH883RXR/iGFeezmEdVgY4hi4rlOzS6l7kpc2A9v2nPufNE9LdGz9dedNVU3W9ZCJ2X4v7s7lHxHixaRmS6KEOFgJIMchkrP9wfcFTT83o6pZoINo1bHclSGJjJH+f5RmkCdcWEJPZe1d5PSg8NEIKblKAaFftESGNsR1uLjLhEfQLZaXP8QI/S8ehoVohMZepG0zNEPTc8XPv6FPpprH+UFtmkfdnc05IeLBPEOSE593/2yMBJHt4Dc8B1lBycP/qtoISS4FVwVS+LqQ2GaytqOUm4Ysobn3bLA43xCDMwXTI5VYiJIwtuK5Xyc5MomFAr/yDjjMI1mzzMeFtrJhIVU3HIgf7w6JEDNr5SufecHRjElkX8ypqLFqP210/iTr/gdQ5mKpuN4lPz0ifpf2RIeLjz0IOtnXL0T/Vb1AK4aBiIfk1v+jFZxPvvErDX5XTsC5CqLxlXScOwysgoeVchRbA8EhEaloNeW8Q0gMWO5K1OArvr91eee0zp9RKRhNaSnKneoqOBDkxvJ/nd8Jnt1+SiJJegIhHc4fbIdgEhZ2+iWN8itVUn/VFhjauk3E0gWPFslvNqtnVY02Xw6oevZ835LfL2EIQepW0g0tGjnB0flTDAIEPm94yjXmJDHsxd0XN1CJ+f7Z+3NK9QRRuGYSe229VpIZWNF7Gw3sAw6dH2UhMWGIZIDgeBwey9Y4X6hkD32rdpxWZtuUJKziZVgDBAO5/tiKrgbEpvN4nstW0ODIpHbwIMDm3/OTIUrejXQxVXhS306XX6NXidVthrOCs5J3eH0zPtoZFBfvmLky3p0wch2Isx3q2f9ctp3Xn7XBMerwIEB51FbEZVMTxCFr2bj7vBgppuKYcOHFSOdFztyQYoJgqrCM+1wfbd9udnUPbsH/fIS2yjTLWDA/v2QY8wE1xtkCJI6UZxgs14rD464BWd0rJ63kMzuM2+dqtqZY3EpXK0eTS7Jn9yAuFwGEnI+Ic4X3Q+gozBgkan42Kg3BcesON4XRixFx9dm9+wgZLXF0UTwXbgb6a9PzWkqgk50exd7H0eCe9l5SYSGdZt4n9abwQ8Gdm0DLLI94KDm1tcdainZ+jxJFRKHJ+pq7mXc45JGh51E+w1b/+2GMdxzHn7IhZQrD65EqvXOlg7k1u+fzzL5S0J6Q0rHJMKRRQfox11kWl9hwvHfG+V6NdZndj0t9/GLFMCPG//J1/+wFnWGZC9XaDmHrGaQt7Ve5JQQ/CQhw1YLl80IgDj5RCY54rcaojiYDbVTeWg/4qMy5o79aE8zFV0/4f4Nkr7aCGt+ZFNWc723QMdsKrt9BvTtntdXKuy+j+ArIfA7pvYmiw+1OPEbWVyThRyAkkCWyN1kgu0tYbgQZh4kipJvWlphwCcP82sIK2EOZxNUft7c2+w3KBNPNxZWD6cWmSUZDaSVD1Y8ZLWqiU8xL9WH2oB8JON5lgPFUlwSfLFFhcYXroGlUlEyJCrbh4PRbsS3iwwocP1/dRXaYcz0A1GUUkgimzcVe6LzDXgTyabhoR16Qe8B+xku5eFrV13dVPlVkaT81Qs/D19d4JUUBTAplPdCoa7l9uXyEqzzmdsxIoq6u5pDeQvAYYp+EBKJDEZZyha90LQy9s60tX88uQQy+Bt2mewixNApuEK/UmHfxB1zcNSMajEjqf+cUFjJzIRTLLDe6RyMWJhUvA2v3uUs4x9lcXqfaBjTdG6fFhaZaZRDcS31m2cG0iRTrIT1D9BVdscGmKEyf+oa7YSr7+E770BYDwUDlqdws3M1nHNyCpvG0DqZ6yrGtCB96oDK1OJJae5jdJ2MS4oldfvCOD4bGAZJRVNJ19aqKZWv10Gs0BBAyZcRAEaOVFV7G4xsw0ZCsoJxYjD0xrlCjCfAa1eJUxr2ye5wX7iqZfAe5/pYTAITxc3l8gGTfxLty96doysMxEOWaVTaU6EGkHxy87VTAAvbx7YnlzZtaLMJkikO+3bpE9KPb0mRmRZcmBUn+SabfLOB0cJ2AxJoBCG84CAJmt3xKQ3KO8TW+2Cc+zpXNX2K49n+kwtG+7xud50iu7vQsFYurEBYzup5GZiLfnHIuTFyPLG2+Lo2RR7IrZOHla+id28DisagTZMb21LgLRbB+DEeXB7sJHgzo2SVZVD6fKj7M5hFUmic7YDycaRvVFhrGyKbEqiKvlprldjGZAPcp03aGWy9j71N+mBPIdGDn3XzElGL6Qrkve+K2Hni0Jj3KGYhyXyjg+3x9YyneQ4NcbsJ+l7W7I2/m1fuv3xRK+iKPNj67jFlHd+rA2IY6pUqTDLJQt2lkGuiaPUzcLosbEDLqf6TePRMwWdRoIn8Vk8/hslyHoJABYGTdxFZ7K5JTwRQhcS4DdQSKzjDR/WdOlibUQmDjygWMbEnX762kbIv5dA9y25De4ZFbZ5+tZb7MhR2WSqRuBkvwoqvI1WrySHSxLTpNGvg7lIiFuFtYPvWSngj06CaQf+Nai7BhM2D8RGu8wL1/b8Ccwy1LgR2YiyNKkjT3bRSnBJ1iY5Bq8etJ5MOmtAFR0Xf1zIF1MGTSpS8FjZ3jK/i7Rk+AQlflRmlIh7kX9xf9ddpjqcv23tLF6NjQwV+/i7wXfj/cqwNRqlv7EDpXd1OIvaMfqVtMBsQc6TflBxA4XJZJiBPm3s/5zqHNjxIWga9PD1hgwBiGjO9N86b5fpmMhS8jlFmtRZYOdpvbCLMpA8gpa1HQHUaaVY65hcLZEEmul/ooK2HfWGxW4UUrj51gvzOU6eTaiBUMFV2ITatpcTy3Yh7hHlCmghEjAS+urh7W7kJuFDN/XO5hUDSCy7cb+wd1jWSz65l8l/Vf6hZCPV4ciszMF/esNKmM4hMn6OCaQHM4FD88YU4s25FW/CUvBOk0mEbuQZdXDQTBM27PVwe47KMNIqpzw9knCPvM+PK+sN7HUM4XJRbiVq8tkJqYkDbPz7Wzu9jYAUKVhop22VHhEq2yW5WfAS/OWEpfkt1bt+ErPhmJAcRwt9mZrc2gCn6jhRUpd5xtpCu4mjHYA+90FkFYsT+5cPJe/vV4UPu0ZsBrE/MsmvzO7NyPRrr20h4X0EBfzQRmUnP6z9flgfy9fnZzffJw+YCCkt93aBayVNXr5i4N4s2uWe7Ud5atRQJNeDkJtfa8PG2AbyUoUeoQXH8hU/oysokUjFJevG/NUD2y7k0tY9meKm3T+3tprwWjrnKj5FCXE31+gmEo0WksJSlKOkUHexXvxu1CdiXGeU+jt3DoIAzCBaBAdkcLqYPKMP59WIIsdEErQdUvsG+troCA5zkaP9xj17I6e53u69vK85jkJztZKxXPdC+HRIV3rnu1Me6NMtc2y458NqtzbMn5UhosdzmE6UG9DXP10dSrETeJC+122vA5aEtLV4dwhBDW42kEiplWJB2VjCrN5kc2vRixCCaokGjwAxldMvRYogAvMz49rwIPRMvLVuXUmCtOtRwnk55bu9LqVR4H2AeJkYQmVlbtaXMQ7fwqHYTa128wyFkb4e9Kp0EWnhpNzTzyOvOPi9P8KAJUf/JbbxvetaRVXUCMrpfZDuZrvr1gEiY2ev9SzyxIsF7g69cl3yTYsE+fVMbpu3JQoQn3Y8cSBfh3Iae7Pcly4CsEou8FbbZ2v01UmPJ4hB7cOssTmONUBwkKV/PMhyANBm2KNZ2cbZ7oVTwbGaIaS+JCAJCWio7j+VriAmaTWuWDrkzBtVyD9o3rS9VTSJoFV0gMnczV9YYzS8jHq8dBDu6dKQOy3KE+rgirAOvdvtMw6wPCz3Nw+UMjX0F5zmsPxJt4cFCdUc+rw0oqqzq6pDEyrhdjlOJiGX47zuBP5rwHLb4y8/NkdpWr615lXazEtYOzKPn8WMKte2HD4pwaHf7LYIgF2dIR0wIE6U8c9H2lpvpoA1lP5Rkpa6ZQ7x0O/UVxHqSRmMWh++0qug/iFfqkK3JLs87raqS6qK+imnlPgb5iIstFBMgLJ+txPUFGXe3J+6DZfqZCJqaa+2MV2HwK0fbS/f+jv1/HpBGs885imE04qHvzkVVRcOKGxwe3mqUpW3icCcIPqkbwrQKyjbku+FbWgCmsqAo1A3DQqkFBRJjVnt1iUasa4PzbqabillNPyjrnveMtVgtZ/XzHaC2jtivj+uf6OelBswVzt0yhWygSPMBq8TQGW0nvFAc7qN+iSJKqr/vcVaKkjkBLk48SfV+9H2w+klOrK5lrPQ7mDQ+b3yWhVPhhStkDaMQCabqjoDELFwyfcZVJrMHpD4st/c3Rg7tWyriv1HpTXeRm0bKKDxamQF0WqCvv56YOpI9hDmXxhAFXfOxmpUXupie1nSSaNBJZy3e7z+QBK1+AZ5u1MwgmlqSJtLCp1Ox1VwUOfBhY+vEkveT7rnwIQ2o3rn+oMq3B2qyQPRQlNBZ40JLXptLhNu3vIacE/4LUUrRsz40bfWO1GtoklYjlUdHi+lvIDTT4lhf7dBpCGFACuf6McLEWCtdzuZjY6w5hanr+/JS+DVwN0R2yl1SUsGKFpEG6+ORUFnSvvXVucq7NHZsNuVYT0fVMrafyFqKW4lpZysNe452mhbsFL4tCUKe1kXMTp9R5IM/6b10mDOjZjV6DfIC9CUIj1LXedBUbqeRaPaagksCUAFeHMdFp8WqSaiAg9fjXoRLzBWm55Q0NrM/BsR4wvKtoHXCWPniPTOr3XDVrD3nbkes9RuaP5KmhwYk7Ke+lc8Hc+zJdCmQ8cMDhshC7LAimJ7glHC5osVBomX+FL9GHLRb1hKwlejDvtTBOwuBCbOuAPJmM7u9nqlShpDX9QfXGrqEyWAxabgBHBcqWtbmiyyqQseLs+4Vmq9ByQQPch/+bjlTruTg8VmLJFLqoqV9E/lP53nijZVgL+DFTIziddHwLbM5/VuJ0w9t0FBCUOe5QdjLeG+WAa9pbKCZVCD3Dt5amVFdxjhjLRz9Rx6GUJYNF6l7ZG8WUSPLGc+znAnHN10udZP4zrR2/LIPVHZMdD/BicZklwmaYlFxgzDT76ShtOQEeeb3jgmLdTuBbS9fxSxBhm8bXxNSEgOwHkGz33BqyUzQZzF8YBymSRqX1QTth578jCkx8fr56fvzoYqc4lW7L0BfUmvP7p1k38saRItRTt22F2HiKMkWfMfQEHUqROIsBglGkah+wVhS8qir+lFcBn1Ge5a/EUMmt69jrWTHz7d0XKxU4AWGxF7iOrffWm/y/G9NwKlI+h9EeD/QkSHms+ewACawr/kPVx29hTRij0K1DsnBB7UwNMDDeiVj3cFrVD3S7TEA+BTa1wyA41EoOnCTVSlpmjS230GobELOEm/ulzoHJFmbLH/E7p/v7ZoEwOoG6ZnjOsBYdi0q/cS8dafa74zAfIArdhN9ppVhPfX4r9hsOWXYf9XKqUBTIZ/4jyqr6lCsZODu9KtI1xJz8YJvCvvgKMyQpP52cn97qBytuLy4jJUjK/WQ8XlFpbvRBZkwtGDwCkC+UnT5aoBIVyfrT8cstQqTqQJUF2tnjvtnkmBwsRoW38Hjy3AhqBnh0yQjOJTrURlifxL+LOqjgPcaf0TfBV6ArOsOwX4Ku9MhO+ynKUUsFvyaPiYfpQblHYgljon9t0f8OAHPTpXtwDiUbBOnZL0kp/x91zRpHjKLH61fNGzVOoPaYHt4Ri9h9bCgAIBElZHbdZThCcpXti+9kCBy+oIfxjKBsW8N+9Igg0mOMcT6RJP78QXJJ4PhjY+vttdjOp8UfdCtiJepTeumDN99RxgFNBxtAj16pG3b/P/IHiGyWPcX22JD5P9laNZ+B265IHS6ZL5rbLd7lH/fcElKSDkPoKGe+A1so+XRRWClBCKOrCuFIuZy3oMJXHJElSPVOsPhqgAxcTz1xT9bMPrCrdaRRI/aaZA7Hvko/S3skZDoPj3rirN/IzzCfUWOUHgYDmcW5ARUZJvhi+nya3D4OeE5iVWE69SV0kzCKjNZhsxJ4/FQNwQ3si3xmJkMjWhLLYudu5F1rha5EqTHxXV6Fz2HLcULKsa4NfNgFQKySx22j6HPY+guy3KuIrvA0XCW/Ntx7kQLmXTCweLJWkFDxmtG63LtShyiLmyRBjggNsCrsVaEeFOhKfpD+2euleiltxP5GoZds68niSQI7uTqqXRMcMDXDwxAXqhO7sU7u8rXlfXbjCIZ2sHi3/VqdMUEL6Zq1Yk5V0MZJ6io2Gew2wDRF2rdmzoVAyOhxJZraKBzh9NZmpaFyh1WsWoV1wgwX/0/WGttF6NbZmB6A2l5SVOtqYlDp+qaqHRE8MyCfPoOT8oqPVahYi4H+hhC/heNT7qbRSR1l6NOWVDHGYlX1oSRog3PPG20bbK0rYfb6CNz5pn3xIuClq94tZp452e/G3ZfxNBGU0+cwlnXlgoFeZD9cvt+3vqus1W9L5rCXo1VMsY6R7S28vKi3+aZCGouE9tr+hcZw99HtkDZmePQslKWipMKzc2+YeuJuSqLq/Gxuo28QDyNp19SC0DVEE6OWFxeDsg/ZkPIcfzyNhMTRtMl02nTKKuULJr5f4fSDxXcTxBa2pMz+mPHpxXEHNQBZdYe+DSs2Y1wCogqTln8oQaaNpBR/u1rb2RVC371O94OMnnBEftXBjCx8yzP7djP10K1wyFKia6nD/sdGSaF4ynP2Z/jlnukn2Lv3orT1vjlQnS8HCx9rtUpA6ex8mOti0B4L6gv66x7TIBHRILGdtTP6Eo7xASp/os9y0SzswXmPnYaqOQUn5owBbzH2fBXQCdlRJCFqg5VauRs8bmqqVKQmc5sPBfG3NSHsNOge/g261W6yHujZ3JChiFZIuVQmWw87QS8+iACFmelL+KDiKum96FDrwNn63CYusXFwHoxJEsU1ChorXeqH+fCILn69ng/9ThE8d3w1K9taLQGtd+alAwVNyktfYDQRmHHumokFuCkUELQ/+3uyJBLQHWPQ6hD3HP59hUf2+dR4dfwZ4X3Llb3DVl79/BphRN72HLbSu4SNd7wW5W0cHZAUlFWi2/ktGhtuhx5a9krZ48Xk8NApaM3NpXJRHRDye7NvBZWmtv32v2lOrAIH7wn/LjZe6yfkurpg2M3dIhZ2zuGj4zHi5iGijrWldEGf83ELQMAiNkMULAtPkWKNl/hgSz25HlpaucATDndOUp/RxOg8un/2gbef+jEUUguPRuYYfxa1QPERYgEiwDvbe2Ag6QCl0/L66oTW6I1uWCz9Uml2UjG+AplxGPYymPzikmD5XgsydvcmI4uvPwnYcjoOHr2bpt528LpM22oVjcNFneID4CZ96yqpaagIgud2d49E9J49AqrLFSmKdZSMohnkdG8oowoghfBv5KrEdqZhUjTSt58uFyDD9oz8lIpToA3bWzLsjmdTVC0TzTv6QrGqT63h/JymENN1ARwQczpA/XyK+Ysb3xO6JYl4LRRncdklOVk+wnS79ES5Fmr2sO3IyK6XWEo8nnhPJH/Zx2hGJMJCgLhP+vipn5QH5MeGH/NFcCNJ3nZ8fm2901NQNgIO574PHSxwhLGF70HiCOC3bghb23t3fvYvpfC+Bz96TjL5ABlr5SA15YQtgXei2Z3poY+PRHIt8CcDUrk4dOSoqUIcc1Ec3ro4xNwRuDwM+gN5hOw9A0rgZ2rGI8tRpgPBVK9XJ7GC4wePNKI05ko2yGia+jwt2Le2kMU/tHKKwDD0iw/aC8B8up1g0ux56/ooxh3kBCBqRSsJAzp5OVElWUxxi6XaDObcXuNZUID8eT2FfsLPF/rVJJIeN4uK/qor+XHsyd7fe8fI4p9JCFIT73faJCFWcS21N9l72ZRIqrY1PZcqw5rkWe8louOX8IgvsgIfoE+n8ueO7Mp2ZhT487z5rZNRjU+VeXMMn3YRR46o+K0RlRxwC06Adczv/S+M8rn4v7asp9RovY2q723YY94DYclXWq51OHfxafnlHOswM6KWWObfq9PYNKLGFIWWBK00havMdlmAG+1SHgU0TMN9IGEC+YlsA+UT63pLhbF0YRp7miUmy3OvTt4b8BTtUmvJ2//NMhHL7qKEBwxTSWLUncLb/J8L7Y7QNDCNY67LFQ4cPdQv73b+ovHz35X8gA6zoRxc9TPpaUihlHjgVtul65nSomROu1TEEgmxW0kyXqBPB30F1MUaN/6F1USqt63FKkoGt+autPqhyBQTe7g+G9SIoGO6+U1vxXDb0rBbUA/EejrKohkd75T2w3botMc+i4rw3voSD/nGEgipAZrBfEPCYZ5isfDdBEkyRDbfH4GgYrRralYMRf1z48SHjxEoV7yZAIDjEh+tjb/PucR894SaqrsnRT7rfXQy8GiYF4n6Bim2KWbJWsZ8toq7fvGHLy6euV/XJx73JU1aqydqpxTqvq1llBysmc02TQdVHQTSpt7AKTuB0Q7ZxbyeEOt/cn5x4nOSC2UUjzgDC8Wyiyj7LHq016Tt3PFymR4sEDKj+i0QP0NSwBkNHE9rVium6IX8uHjZ9kCum/gbbylSs5kJQbaGfTImWad2dIAKlA+mupfiw1S2yXO8pLULB9r+koJpDDRv79s3XWFu5MwKCescK9RFcGPdSXR38QdWl5Km4xrNsUyNCtPc+avSZnPYAe27xt+encRCHThcgGdpiafa5rr8ChDmeNDrtRCLA6p0Boc4cwkuK2qYUkkgmZgaVC/nAUHq6+FK/Olf0yABAi3hN/QSFbG8bX5LOZewICnH5aALybRRlRpXE2YTrstahusKg3Mjsu6xnVkzfJy/HWjieqiPXRsGxMuoqf8vV9y4byuIXB90mG1Fge7m4qW3YXrQ2tGoZT4UMfJbQuXqgLChRXVL7/5GPjP46KYbO6r7mQ1kUVyFinQ9JeqnY4jyrnboq6yIO/C0s1+NEDxTiiO3mLNvxVnGqYXVSE/15EOtH8F9Ba96Yy1O4rr+p/TsWU/0Y6Gpx6g5VR9n2jpDv+JYZYPR5q5zY84VkjdU5uI0GFCvSDEkC1Aihf9hKVyxqPrPkHrToqWnoLk7v50bK+Eespiy4omysVfPIkhxP1HOKqNXu4A2gLpE8ZDolMksOBIm4T+gh7FkM0qKBGMo35tsJljgwnvoIVxxm3mnkjb8WXfWxgy4ZqwtW4jEPtmGypRsUanhFVcb26avW839IUtwdKVich7Mwr3cpNoJirSoY7hh4/rBwMCn/hEkxkmkmoGbsiMpw9CCSChx8ABcg8UubrjYyOgGjtVV0YMxFdsrwU5krGabYZUBweFsBNyOPc5WF0BRTNs221qf4o3xpOoWHAbIJJHJtk2TD1Op5x1qXENgWs44+IMNvbhJZSKprpswMYnuryp20agH/rAT4iKT0A0ZUVrXJtd7me2s3brEk/oAGd8HlunU4oS+7/SmcXZ8DjcPf8iWx/qLcuTt/UmrgDV1xxG/ZehBKqvO3OZh4NJJrBi5HaIE7WTybZlrX9lsY26b6NcT+6d5fLX/4LIosjyxh3+Gf9K9W+zc8M0WcifE9r6UuVmVWn2PrQaEY1WwyGAB8ZyntZR8cClcDBTOo0CfOmix2pFRvR67EgZ+zRscJV0fG8439sPrjDRiRo15wFk85gfhw5rtx9rrB7lSBZi7bQtZaevRWBFNy2Vy6v3et9EEXGs7TeSE3tU7mrODZRWG3cXPOd0eG0FmjZEcJ6dL7nYCQp4O3Ut4jedRTHEtmhnnfwEm0RaMzYvr96qP1BUQNoXn3vYE2UpqAz/G8HHmdmoJPDPtAxL9S7mlDfCRp8oJPVGH8HE671ELOAzHRJMoU8MmspJF6kQUsYjo3/UnV5kfc4NZAxIIqfTka0ynHlJxNzvusi3QL3/Mei7toghQmGO1fTapVQzPDuJTdxLOiik2/ZKYbGYoMzVIGdfsZkK5bev91A9viYaxMNTpZv9z/BZephMsPRg4LiphLUjqhQKC2jAb3ACxBqVbLE0Oau/9qpEq5ukyA8Jr92MxEO2Q1irrBJomRpto8LU2hM4m5SDcRagYhAuU8NLwhSW8uOpM+B6GReXiSnjUXn1WOpkUlNY8x03Qq+/4lBwVXQoblp7lWenHO72nizFwrGN7BhGs/tl9WfMC4MyhwmX7TXQhNo/zu3Fvqpqa33AVet+LiJO+p5PPNrnoiG1zCmm/LK3A6kPXmU6XTOgvlOknCWAlGP0/IYuGkYB/NrQzTSHUroFHXG4rc8qiDN6MjhzZ8IUfE+7mjK0X90TLGTCtRGMQHI4F/BPjRa2+0swGyrn+sQQA3488nFUUJ5vMorNgTMiCd0uvK2gDC2sIzlj/xe8t+QKIPF114t6u35XCbM4h4/ip8VdaOKzQ60X0HMZriYMxJPKiiVI31lya3HgMeesK6OoOHX5GwWBnl437j5UH3FKNYikY4JDUTTVRCim3EbOx0DH5rhQHgWknEv8WtAUsRIHWwOJ26hkjU8PHpk+K8sXB82EiGnw31ZTzbqVqTgPTbc4nypSF0sryB7VCEk9Qfnlq3T+DkNzjtBj/AbICcaPhgWSz1weEbD6a+r6/Wu8w713RzjwCrDf2BsJBDL5Z4sdDA4LE+UEKZ10elQDlw28x866Dfi0+XhVQKO/i9GeiCBa8F6aJrWA0+82OdWYYbyN6nOQoNSz9Rpfm90KuKbs/4NRqacWsF5Ra2fzhPcVpaC0Alx/gODuhuqTCcxnpd0wRyxNhmO23XPex3g/4o0wwJ48c++P2/VGroMszQepARwcLD64plEHKagcyamq8ENgyHT6OBvmv0wsuqjvC6fS5q76AdCGsXDfI6YWd9GSNdST31VrdHtEBM0twwoJyL0jwX3l4ExVkv3ZXP1yfPsjZiWPoiUfl8qruw0Wg6ugyhZ9k4q1+c5VuAqHsp/VmskiEwu/DS9aX/L1cngthp8mDmSP4EirOMSmBMwldgBFKNbiTJ0jOJbf+6KEOvzPi6o57ZgldYi45t1vAf4E4iz9QM4MSf/QQZulqsTfpbySbcd6ao3d54jTPJ6iB7VjxFYLZfi1PGoRr7Of4PCU1hyEe1xkWTWv3lGTHsUl7qpmZXewmnSgmZBvwQvk732S4/KauZmWsMEuGOM3TAZTIbpPxcmcZQpGvHUmvMx8E0TQBhch8Z0/sQdWfgBFGHv1C+d5O8VDB82ggI/WpceissJDzJIithYUg19XIw/M9h5+W5ep03DheoTd4hruEt4B4EDt80Zgo90NNhML+XcKS1BwjsMT+Z6v4ZCC7oq7F0bAFVTllstzMt6liwZpD7qlruOVvT0xTamtzlxjEhYw9jhOrW8UYcPdnlyKHtXn4VWFuBqMc76V7iWUWYoMSjtbAucwKQP1cImGG9sP8/1GEExG728cXztVP3tlo+5f7vcs/x0BulVhwpUyMn1nM9iqRTLz7kKFHC4McA0xPqO0Es/mPGZ8xegf6CDrYe7oTeoOc0AgYvUA+P0ITXqY7N74d+MtIH0hezc5FOcjHqWCIfazgcIUTa/TKJk0raqWCdgFAxZ/4qx+ZZ82UUkxhsLhvhtjRqc4LkCEOcEp63zAIrVerT3MRcuZoQH6p0Es5OYyT6z1WprhZIAFcDO7SXiJArY4MqiRDmMjIvsMwb2klcdijGOo2UtsSOQZrCk2y829MBwqaktz5f+ey48dK0Y3u/Yav5wun1spg9Yc+vwXeRUsWDbucPJOTNgAiVT6ZY8iSajS1m1WgYZ/OdW7G4oFtIhb/1hyWgs2gtcYS7jT+/sOAisNA9HR+CX4jwH1YIYGyonL2M8I+OMAkKGJNLJ6JZnSPiDhEqDejGXSYyVvKyroodzw+OUoSZP/bCJO2GKFdhBpH3/7nSlfzSxODtLDPRsmjTJKGlaMEFnT6IJk7uNgTB2zeoyiodPaN5fLSqg40WVfYwy/i/w7aHJfrzIbJOB1I4gpfMD3VZ5jYSJXjuFt/XNTQ9ymUOSbnCGUKrP+YlRFhfYT6TrE0K8458MiM30UvvwxlHbjbdW58oEkd6cYVAblxAyKQuRn/oldT2SLFta5fhZ6rqc8C8+Fiq8BM7kCsO8la4LZj6sVR+Hn0r8Wy1Y+iqpfa27QEX+FrDeeYJZd8yQQ+LqNX//oWhacLNdEnMWwjWOyf1db3xMFGVoa+KQUsfc2PCQIs0ivLKAmyJrvT8UEiQzOnh5mtlfu0vj/lJMhOj9yl5pYTGca0GEEsdBFJjBSZ7DOMoXsls8expnRUA0oJzdWpcBpKk5ZqMiHx4dWptittU/Rsj7NiHpFSOsEc0IyTHoZIIN9RR717xtyrd8yRnQZNhMisMrfZScnM6xCAf15IU8ZoNQYklAkTsAbE9QgNf+3M/6jCmCG4nfV5VJ835C1HHXOvEJtXpLuVL9QZPL6qW7SEoDFsRX62ZJOst1w3VY705IDcVVFm4leKNWZdYyvMvISKjBkR16BT6NH13PFyYLYUhm0kXlLw2de4jNtu3SfQWvesVw8t6F0iH6dGC733FfWx7iL5VuhanFq8qVaoYIX2T5D5UxpkzOmAqIcAGpsRhV2wM9ODtati7OHSn9xFPkhvsmMoM+gmdWjXN8Aht8P8m1S5w2tfw7qInFMtPkK70kzylI80qJ31XcPeI2y5aV3Rw0cmnNSZE0zJzMWFkBpgi2DW5yJLmuPCJ6mROnviqtAtP9lJ2WBAyWvz1xvX5OiK0cYymm6XHUFzqcl5WWCRtDruYAqh5d5ecR5JZKacUwfRRYwU0qlcW29nHmCPwi/0j7Q4NZA9iqOVfVwySmXYt79QhUMZdNhrExH6YfuG4fWP55fv4gHtW+Fi2o1p56eNRuUsCAO+QFhqxM3eDQ3RyIyRi7VRAX8ILfD6Ddq+SnxNLz+fBsHyjqvZmtLHrP7ud+oD/wvlNdvag31wbi1IM783Urs9hsl03NOhTHafP8BPgO+JQYJCBxQ8lWQ4zkgJmdAIycmj6cRVkRr5fYNBqQl164ArLnnKtS4D4hWLC23RJnqJ4PtG6iADL17Y8nlaPa2cuWLHU6zqARy0vxWMRVTPKLlTxkKqqdZb2CCklTFKzFGiNEBK+9FKkFvqErFYtnaz+w0J85q+xaQSwpa9XOLtEYPbO+wtUez4kCyP2g0BxTFVCqPVWQhv40Kcr+eY+tgwEUUH2rP/qWZgezvAvHmyULZ3manrhqOunrXNBt93pjxO4gzBSzvKe/TIzCZ7gngDPfcCZcB0lVT5ccNCWCJDC6f82dGbwwYI8p+zOrtZ2+hZkSdT8ei/27W30plbOvmN825nq7+3E5QIxlAlzH2EKcqMImy7IPNI/PX7l5H4ttAB79Gi8GIK1DD68frXx113BTn0+684chTZBLdX/hQ1wjFukGi7I3HRPttWjGmDrqY2sAK74gyZg9kYni6y2YVGFK2cQB0OE1vMLvfNVizEJChaj8PJ7rqSg4VFBP3UDol8sKhAjhF7w+E/KbugGWUeJW8o2n5RROTM2oFtljNWvlVk0j/RvSydHKCbGkyl0pw4FDghgtSnHE6nx/lhu1y58dJLnrqq2FYYnDgd/BL9ZQFG+hXpYU5JxsjGlzZhLGLaGezeb98IaqOl86EYTLhIs6pI1rso3Wb8KiAuuMUxOqkpWb5zrZjRyGw+3K21HKfE3uaJJtj7cofyjJa6Cfn7D1oqTpKx2lTNxO9BB8BCfxjPoUeiV2KL0itFYMv9CAXrwwd6JqkpsSSLxDCiiscPA/VV2ggp8tEpAjQ7JAazWYm/fi9dZkGTp4RPlZHRIxSS9/oPwEwY/nWfWgTmO4aNLLN59hLLTmvMAs63NDpAwWb3i6Eo8Mcddq2WatLsWl83JMX/AYi3/blKziFZlktG2+A2dXgFGIXh33+CzFV0bJXjeuKHiN+U2Wv5rUIDqMWDoBJycd0d621HTRc8x0GxsGZTEJU1Lbod0BvvMpva3YqAfPdGEAEc2ooJoitUUHik1BNTII+g0Vq87T+gT7yhiJUl6/WnmXqd8uZqx5aDJYskhvb3F9uOfMXu6FUeafLHbhtREGaFhN3/CxIaW9a4Kb3UxoRJVxoFZbZiwsVHmIH8sujFcd8VanndFMK74BRap3jl6BfTu2yg1tS50IdpyUZOqxto6QvWYEpoQmXnQlw2uBingr0HUuVPk0q0JyZC3FLM4WQq8ZrPSj4TZR9C6gaY4Hr+WRSmwrgCHYy9tf0Az8Q/SJ35dP0x7WZNYDnWzpBC+R08ylBQNpN+NUczfVSv3q/5r9fxs+QdfCV/enR+sjnqKUatyHfkhCwwyVc94OB3QBKS7iFwmZP6MYsqCLVvKm1f5PA0DhtGAIdzdhzWbHL5Jtg4ZSyahYdnkjeyCZoqPDnj+EqDVGkpcWrjzJ3m84mKHM1LXSG5ahKBmnAT/BPEyrb6PI3YIiqkP1pbd3fJlpr/VZ0Aemg7yHjlIMV9tzOV9P3eJt03hf1jPw/CstifvKbwGgxT0/HHBPL9/SQ0rrap8JOuXoh6HlgqalFCG+3mSulkc2Lwq7hty9JdIb3XZOJvQdQpZB03DS0qIH5KJW6CIqK806TwNLSm1iaDrysvq4+mv7p+dcUXAzt7HK7mtN1LRY5j1BoEyK1nFMdIuLzbzuSGTNN/A18hlqx/LzNQ6QRmJ/919agR8TWv3YFiXePuNl16bP+nvqAfUhX2GwP0ugBc+weJiMhxT/tvMH0uGy8UCu8/YttDJLdls8oKxTmKdv+352yZTNan1edm2EjBUXLksDs8cftmhczr/COnjR0PpEhDBxTccG+mHsRzs1vwXPq3cI5lpwu7DrRCvz3bFWyF4Zp2R0r0ueXxJ7kAYUcHY/mwVWBRPwrfJRTKuqwpOrDK619G9Ym4Dh31LpaG5vzk6Zg3z9jh1xOOFIPpkAs6/EzSrHiNq9vZiD/VsCARlhCSHgN6tnxuCjxmtlQdQY2YY+Ui3YGo1NfDAO8Bl9zIZecbejuJCXYI/hyg629Rr5qenPiEFSgfvkA37PnLTavuLdwUbnXv4/PYwNsI15vY4HDDxf87izSbx5cjlM9m29hHknonIR4gS0OVSVO+ejjxyRXXUr8LNJLnNJRIrWSl5DOrCWOtZH41WRz+urWMOeLmp9uRejWr41P5KsUcZO6la5quysoqOddn5H2M5tfg+ZtOfKeqwGk+OTPEV9z6YOZ43BnSCtzPhUW8rGCtNhqNaa3c9ehW9wovP18S3rsGK8VlYeiOyQ51oBGGDIvsJEh6GlCOeIniUPPsA9XLaL/DfnNsHfU+415fFqFN5dcANMELgwvPtVJszktPXy+uAWZCy46xvxkIIv1KM5jImFUExbZyEgIQzYWiY+HCfjqcbIhITEsfDmFbjku1YTF+Nm2AVEEBII9OJ1e7unQCQRe0eIcN0bIY5Zv43250/WbTE2xAo45tAsghC20DVBz9mbVgVOrbtFH2is0L0gzx0SHRkA7aCeFyeTxMr3SOnz24YUkmTPi7kLWJl2Fstym5Sbvuf6cElauDIYHf1eAvYw/knhtLbe7PTQc3RBaQXDEQQR0rogu2ViC/dl5ss2nSp/4FywA0VJsW89aHXxdHk6+zvKLNGslQd8um8QUcta2ntDnC5QadjdSzLABJJPSEoKsXdhHRUNT+zbW8hslnTYvGeOyGAiqERqtHsoDF8gww9D19OHItSGenU2+VVruTbzqElPm8abow7ayGz+i3YmTDt85kB2L2fMIGYMuTia0Y4HFF/lmL0t++f1fDDaRH7XJ1Ki2sd+u9ii6GDwngKnVSFheyQgSAxCDlV5Ne5QbSCk0pLAxlBn6u+jz9OIEOQQ2t6EbSUprrFJFTuDMGCs2ShHwBhiTskk1VGzfco/EDXu9QLnT0F3v9YS1v7eafV0JT7aA09xMi66V3p8Z+6gJeakfxsannW0cmtDkW/nMH3XWWWTxk8ay12pONveUAdwJIBEcpD7/6kvXnJbjJi9n3qsHq1HMS73R7VuPA5eIEhWGDzfBz6X53wDRYhGiI/qpmhAJD4LhkXONtlRwPMwVpRh9G4Rw9v44eScMaF2MCKj5PxwHXS2dnpUQRQ1vBLYTNuyRoi/FoJ1xHqFQ0mT85SeORsj8wKI8UAd7UDMo3ffQdRo7bUEC4VT+rkHkj2pqm/x0nGilS7rq5VB+ssRc7G2vaWiXrdY7HyOxxyXcN+RAm91BciJ8wM3RkWoAUqaSlo3/PZ0oHGZ1EdRXw6l0aZ88QGgJ8rIXO6C3XGT1BXdLKijm3yqT7f985FB8/Ue4Y2ayd2BSxaTBN7Ny+I3/ZI0VMPQ0K6vMV6OydYCg3HaQu+8Cyrzwz6+K8J8ak+SpDLVQplTnwpzzY/qL1wm0Aee9Ex5+IFgpYrRCPIHMJdS+Ey+Ilni9WJm8C0aZsIld4nBaBrBoZIgfhkg0qemw6uNJBIBnTS0RXO3j6qO9TV0zhYzVVsJ2ySBEb2uHvi8F9FXM3ojHOd2j0JsysIa62bVqP3eC6dWzroggs1xx4M1KGLg0jDrw2pJefJbkw4vPCxhN7pPGmRo8lYairPtfa8QV7PT4fDCZuNfQk4zhqRA7R+zWFJBmEbDpwOiezvVyvnMzI8lDP4w34oUkIGzzIluZKyWm2/qHlv7h+CjNVv36bj+EqodwHMtMpCvCHnIxnJO2BVK+5LqXU+pZb2jyU1qLhCX2n5Io62ZtUmmPeRclkJ8mavL5XVY8UeyITTT7G83CjOOSuedUO4hJ6X5NLa//O7VWykd1jnID0eVPK3KfZlaAiYp1HfuSLFpPORJUnLzRq7qA4n/C0T315XR4z13zxsu4VqZKxBsKyj0SwkmJBXcSgo5OkWm5XAPKYtYVbwbYks4w/enEBP+39TcxD3q5Uv/8871gO757p1XHpdvKZOCrzYjm20eJ7CVHRfoDpXNoSQ0ITrofLZOuvZoG+Z1NGfEObU8haWC9ypDd3jer+8xPv1etVxRwVBdxH+3Zhu68rE6B8tueJ9OHsXMxTICBev6TeJ7EWMmhfCSgcEyGfskCyvSgEvjPLrWXaLvtnbtmsiiLsGtD9VYzuuvHJGmDRANRh8sXh5uBbf/W2/PKtMJLcLLC3fQc6scMhOpIBkKJA0iVsD3rckris4s0d1+v2iIk+ZnrzjUuOPKUeIdL/Q1MdOMakmWzXJfPSGtN4Mue8gRg/l6Qg7N6XO6bFXI06KreLZreILt7XnECtjw0fM+n8kR05a64cmJpkQIbELSgJvxZmIAIxXl2Sn5MQQb7Y9zGBK3NoEdhweIM6JclMsOY5WLRUhsi86ZrlVybY3ohIxhLImoxE4fVS6RBLw2gYookOy1/QDQZS9XOSNxMhz1xlduwazPMzRVINagNL6YZTzWdYIovO7VMRavWPh1pjk46jtss4NoLwluVZIyVwMNRDJv29K/f1rL1I582ZUn+s07J60GAU0nwAd3iwtCbvVujWMlcu4sx4E3Izyzovsy+mxh2do4RIS6dNv+LeYzy8tBWLdnhltFQEs77NJh4AFrVp/Y1Si7nLF1TCr2gFoUUEzULDkrOBewB5+/qTQ9ygub/FwnRUie8a67LXOBru5FMQbMPOcWhw010DzQtAHs65+21PbG9B+02qj5olWPt/feLSKT068FH5wIATh4ExHmAUKcwNAxMoZNTHXJd37QT13x6hiCF+MO/ogXd3nH5BP1L+rBTtijpfwjKbWaJPe+AbgAcyszIWcsHFri+q7uHEK9beU043GTgHoD37xONCFTZibBvi9W+yBVIkUCj8yidaSI4LDE975cAqdY4RYepAo93x4c641UDYIJx7HZMwROik3TB5UG/MHGfovdAZGeKleaQJ1fZL3tKai2oMwy1haLu8ebEEDyCjRy7HI8x6lDbOj2QYE6XA44EY+j8j4ZS9KpnpASO/qnk6TBuQX2LJGYw0V9hPdN1e00rYiOtQ2IXES64bNcoBuGi95lASzv7EslL19Iz9HZp0RyTKa4xQYml+AA13cwOJaZa+eTMoTgicSZNxnKtvahcNngYTTIj98ICkpFIqBbDf408WF8km5wohuG447SWEhHGbUMAKo7sWau86BXJlFengD4IIwixJFRxwtIOR3/HLLmYpUjCVjRlje/51oqkWLiDde6wPzZ3hNCj1LGIIkW6Ae5tNU+ml1x+aRZO+jiKu488G7mZIfIja4SxamlssGRkNZkYWqUbL1HySPLkhztimVYpmO8LPprxkuF9dd7GINXNqGvSwLjhXjg6zW5Ek/+bDX7f6YTS/3dAjRkjUI72MTzPxWI3l/xB40kqL4L8loUM3sIdI7KCb/Rabirjoq7obB5NrlS+RcJNJ7yDk6KMMyVfdM4sdLMwfhhDlsm8lj6/isww9UMj37xEB3nDdN7d/ni6hn5Wr4AqENfNGeBPaZ89YNwOIrZZ50pTGfzNbgmfkQifGFAPesarswuaKn4rv+BiSmXmvxjzgCjhCJl6gmKR2eABBzT3xl+/VROh8ruovpvPZv2sJl2GSjFKW6YqOgf1IuxzBzSfq3fbpP9OyaSheBEwQRtQ6++UAAAuv/LmR0/ImLVdfYzFQDChatX/JmIQx2YOKFRnaj3tOYhztxKbabo1cVml6IKz9srivIgcHY+egispVoqgWJcYhJWxtmR9Jkn/rAKC6GJoILSAt1VK8awuUibMeWMUkqOoXwOQw+O4UBkmWa0wQetQyY2ftlwvMvL/7+lfZwYyrcuvtWGbMS/NT6TBlEeVQHUOs/TEQJYLnB5RhU6YRtKigVyFdkxL6mJSXJxWjq5LgJT07RqDCQldZtEGWtTkXXylQ4pX/dl58s9V48FcM3HUiraBUqWO66th1YiawDSQ7bA/UWuqR0Wt0Hqe3m9MNxzc/fB1CteHlpau90aYDlUIf/ORNfGVQD8v9JJg6I9D80C8qpSpCQXZvJU4z7Cwj6CuS8Abt7rdvtMyIL2PPL3BoZxq2uRJTH9yax1ntwOjMDHzDHMmdQkf27PG0Gg1GPETP91GCU+TnrjE/NxweHn0x9qf7i97k83lN3wApq+w/hdjJYKX41NgJId2spkC+YFzXSxB/MnWl0QOAasHwbYqANtqt8snw+7GQ+TPfEGQdglkZ+YHfikq2uqM2l8yyQ7/WPGEVN3XihkEtnXQU4CG1bbEFkLxoxkrS5gqhG2jNF6jFZHGxsa/fDV6NL9sa3MBqwTDf2aS6u2TkSwNu8sr6gqx5d7ui9/kBcdhxTC/o36w/RD7UyfeP4yozUD17tLNW0MZ3vpwZH5qV3BKj5i8g78h/5UPD+LzH8Di5pbnr1PYb/pnLWmkEghgzw6bMmkGONwAyEzbiZ5iGG+5mxwnmDVHBu6txUi/nmQ0RHHCzrNWq+zJyyG4tSOCPpp6lvru2XXiznTeWhQGXQ1SJi/WXtwoD61VjVHXffc8hrG5cRcAlCaRIGkecCLTGSUrTf0lyHAUqyGXX3U3mh3dPb1AdZe8oz0ueYH2BebxTGLVmVDlQI7VHfgs5gPHy+/0rKqHcgvmOm7C+FtSSGCAUq7b0icBmyroO+G0Slvweo0T+Yxre3ybs5dGbQd7h1heRArZ9SBeT9KVWLpvSelDR0s0XcSxzonbnGYIS3HZSsL6Shja0TEw3pRfBN5k9kT34AbLymbhIRQaKXdBET0JSOynPncBCJYHAgl0TYiQiLdESdD7Ou6shLF3Be640bxhSs75rTFQEOLhTZbADM4yCgLWUf++7o7rOqSefQsts6RfG2sz1KFAmCVJFplc+AjfMpUGr0PXSBFZLCRsZ9Rog0Nt3LbwonGINSmeVbiO+kuAVLFvS2tFBOYt5cHeJN24SldbaTHnoPwUIu2oqX69Ok1T4h5sAEDMoVgxsGY401rzNU5rUlElHy1ImdS+64VP7O4/H22DHh63tlJlylWTenJMM3D+8CSXIB0V3VznvUAq8fZNs0cGNeAvin3ysWEy9/VBHeJHKXrfUNjpPhyhu0lYQDUJlZwryNPy4cNumhgB54Tw6BqldPQKpoUmkPOy+cvAe6C4LZliW3CBYIbzYzvlNtFLlE+lbNI1QKBNu2g9PNBw/Mkbj4UGYPkTqdBRwQrIyKKzIA3L3j9a6gN0KWjUiVKOUE1DWp5IOW39reI9VLZpbk1OGm6lglbwfrVXOZYE3OZjCOchp9umyA8qLc36c39sdqz5aw2DqPgNXAbbZAHmDacAvgtu29i2HY+Hucaa5Sfl/27ZFjUHwugcL6PG+/6JrfhYZmcnh54rKDV1Sw6gtA1o9StU2HQRcHmOElos7RKQqj8NnpJsVUYiUx1xdeNUcZ88MGp59unKxaT4ou23a2FWwjgjWVz/BjgrOGshWKuJV4V9OYjrT20mLSFheqsLHuC76dKXDxpNq77a4gWKh8UzHBlDh5unAjDhdcaqfjkbhe22+Zt43rFJH5mCXzoeTllhOwb/mSfuoifJzO1NSi2aoQpvsL6Do/f3/F2QitRLLAN3T24+LVh11uc4bVUNdJa/utI/+KLOT54lnVjlO5J1da2vdVaosjKlIn97g5C7+9n6zj6uL0UiC9dcOkIif1LeGwjhD6ETUnQuqri09OwEOsve40iwTmZ4ek/yDpA3GffCeab+dkbgqYOk+zVvKDg4Gjx/4G6ZDN7obYtSocqgY0Kz+sCGvQlVHdZg5YOPjvDKLllj4bnNkyrj39oURZYK9PNY3VtxwPJ+f5J9iGMQrbikGJAzbvDtSFCz9ZjEHsbB60DFS2t4qbSnrCW6AntNyg3l6OAN+H3vQXCUsM03u3E6jDNaK74FEzChJAJe/+5l9D9f/5q0pUhuBF2ebWgOtwubtVe6umnzpjTVke2c+rZXPvhgo5jBPaIUL1smNO1tyypdi3n7eZN9h8OrT+kLG2c+wcjxlPCv9oqTq+G5iIRim9KnbtQZQ8Tmxyth8MCtcibpt5qER8ZNtohhfYigoFvq2IpaXHpGFdoFvVN4HCQC5lMlSuoSooDryehKlKBEGczYFPYqdeMEvtJpmFafR12WeFq9W9nWhDR4SvsMeOuj/KeJvUhxXz2yvS3tYAdOWqkwK6HycaFZVZh96DNAck59BtmPWMMdVTKsDTcNZMYG3HRaFG6Aqv3uD5UqQ8QOs153E8FVIwIbBwMLPPNI7PluW6zbWKpZTvBIEeKruDUql5+gNdBQBWFeyeFkMuv166y7vSe8B9Dlhrn41r0AHJ7KHvXjIBjjmbzXoRZRo3lR0BSqCgPssm6YmAskhOrNAbG4sdt73k7iYwmB11dMN7soRU4mcaNeFO4Lx1sliVD/MsydH+cmqCupPBarnU/4s2QpZvkhhesZ0c78isi3+f0sivopJ7nwCK0QB2M989qvU8MaLhEuVvLBHOUSFJ+QgKc3yQp5EWJqHTZMPncmaEuXC2cFU02zNcknqjvASPLTecS3X+fqEFaIAfITs/i8hvd1jVIPjKl8b0NDzB0zmuGnRnGxrnveSXHT5lP88NmkWE6c5X0MnMe7Ze+X0LGf9TwH+cjsrjMwo7ANiWMhFJmqS2WhyVEBzyzY5nH8skC6HxNeuCSVMEj/Co5a6QCYB3o06aaxSkblhx/Dldo/Z+civGQ17OoP3IePMvHa4LuRcF7ZvTEA5VffFM+yyMUGO2gsoueOhp0LSKpoEp0DwrHg6TjM0jMxpnv8/GZJsgbDC2my7PKYcsl9kB8Ntad6p/XXoXYoM8+IJKqZK0cqQTXTNRAzbOx2pPS3VIXflxSW8SK14xEBrZRaRRFzryMh73BNj5QGCtPrtd34RPWWgU7inMiKWN33ZKtIW3dvqguIMfy3IzJxmT3BiQy4Wp6NIUCUsu8d1CFaSBAT1Pr8Ff+2VsLjphmy862lgmXDH2X+crtOSrbzbkKmurJ2ZGDGs6ExQ5NuLQgr42QErTWUZ0s10hbnjpNk5TgVzBui8IsolJ1x/gVWqh+PQIKYyr5Hlr3cr44iVIw9CbHleic0fe0Az3JbuWkh2dqpbHCaaLMouKEiZVhSTZLja3OqH0cMZB2ou6vFg8q0nV7Dqt23bEZg2IEhWh2ZbdkyOYfSEoe4KzQZdt96/cVxwgEJEcrkyM6Vcss4Mu2x9eJ6mBzcvpaogABZQu1ExhE93ah6bZUFKt0+iDWIMRgotinN7q8BHupiSW4eDIUWIak4Hde3wVy3kTj70V9JvrbuhR8As+dzShOGTbIjAyogunJ2GpfsrO07I/QM8mPXFpV6PpUM48yfKat9a+oqgn1jY5RSbjLxbM9EmZnsHN9A4bhg8AMqS+GqkhDhWaLAvkBfYjqduT2WdMq5jmZ01b4cCzmPKijCzldmIslEyuGxAOH2yxoGOgvYlQzWVh6raAAll+MIxtS2kQpKtAtn+D+wEpfk7TvzCh3LIrz+br3E94qAjv8j9iQnoApTaaCUPMyphE5mMGAT8obvLUocuv5uRZtbXTUvKlp9CL+YZCIuj9UvVKnDyfDaAh90d0wVZbr/BIH8Gq5Y2hnzV3pbhrSoQqk3vf5jfB2MUTidja0IzcI++EUcXlqY+lM3e1tjN8HuFPD1Ut7dramsJfVSoJ2VSjcoSwlTAXpNRBSI1lKLzSZCiECzy+e24Uo5JyDf518jO1Jhv4UFTZ4LSwwUDfX1hVmU+/Mit6iShy/EUKhvtmOphoNzAuImrUUH0cN2jyiXsyukJD/3Jk//H+OAYK+qr8eoKYeZne4lg8yISGFOlHOqT2Kl9z4Ypncn6ocWeOMLQNFTVZU5Y/ncTTsz2L82s5wYS5ZLOwOBsqeFuRXx7DNKChRWUsgF8HZw8LF4RPvU2cn53Vy1ivQjJdXG8DBc59kssWL6fzHkPbdZBKxcgsLPjyUu1ZwUDpAavFSlWEZDSPcEItBG0F562RSGfXZ+LuAbcr1ijxfO9+Od3jZu+a7NlTVvjOMwx2yXQrZ5+oK6fjatyCTnvABHd+RCu62FIV8q72eq2Z6M5ML6PwVn4kOw6Ql/ee1/yd77CUfCJtY2rQ7DnkAoF1XzEHELcCyzMu2uI4fqrRYdsc7mlpkzQyqBWJ3ZoTOt/z3XJDJhWrqO7l4+LPuiWTQPUsx+zkjtUkR3ho+2FAXEgTXkY1f3StJLgpHXoDmwuLyf9of3hYoZ+XOp7o0dZNqxp3CT8Y92IlRsyrMHXaSJD3E8yB7udSGWfn8L+cARxW6OkYwevFAHZsev3ap9tq0h2wcoeJlDzgEigc05SJXIZPzSRDBFPtYnCwisZkjfp0hQKdutpuk1XvlvR66o/yeMEu3hepuj6eOvAho5Zpt965/Aw4E85DCUFHcrfyLol1FIfjZp+rb2xjmjkrgOlYoIHTlI3/gBziv+RGlfixevn7kXSlWvBuEf+NVmJxhddAFDvkdQNZ6nsr28PrLTdJUmn8aeR7klcvuOJVj38gNGDI2QrML0Dvb9YuVbjJva3e+2bklMMgW2gzIk5yiiNSLyokkJjhhkAl62Lo+tIs8LIle8gZO4PYUt2iD6EppzEQDoQJLm7tN12qXI2n+AAN8WL/2CmlSseE8n9HWxl0DIlHwLsOnp4nqp1iZK4JX2w0Q3sW2V7jsUgGNi8mg67TCBY5H1GdPPml3aE1djm6lc23wmbNsJKP83vtW8rGi2hLNuvCOkC4Y4tH7/N92Xwd+d+um3Y7IGYZ36HvHo3XbZ7vTZkeD/XxW6RbTw+KORKeQJcDiBXLgkpd8Z7OWCo/exFtXCgC2J+wzvHiqbbFcSrnFSosXhxy+Xd5UmKesoRX2REMhNNNm1JTCkDZohA8zjnTkU4/LbmWmOY2v8QZMQxnIKgnwh9uwWNpX5koMmHNkLurejcqBkkeoSOjHKIIO5X5LEeDbvR5AHmLXTcH71/xYoGkiRScDI4Cqq+Zjav4PQo2ug8H6jx3AysEalw1Xnid8FIcITOVnxnWJTx+rU0o9jTFmCjhO8ODkojEz/i4kodtQJO3xs6gJiePgPeu7xLS1NTvT4bJlORDY4xA2Q9XROIjS/nqU95NDLI45znYs9y3FSqVBUBAAt9x/vEfu206xW/kurQgBJHts+6lS1RdzSQ544/3wGptJSg9JQBDGOjFQWcbPSdYiuKcxrvxN1uJOb7K8V97gDQtYA4KI9WyQW+0rWNCPDak8toNfwpPhk6lDSt8mfH798r6KE6UVR/qCdIBA1V/K4oL9+8SItK99DTFIyPsCvXol/5QLl/A3Xb/B+ZvDeHYXejobBTTq6LwItGdwV8SG9LH3foKuDlmjqwM/OyhJqSULv9Thr1gIBy+vFWsipjc9JycL3VwtQwp7ljjHRab0/kuyVgc3N1XXZxvgyloKDOvagECPwtqB3AOtw1W31WYkHPIKzY2DKIRy0kWEHZO8Uxurt6jz8Oxlch7hrI1+yaY4hvfP9AdqIRnhSTxmQim2LG+sIQzlPHYE1MqQYeTJtDvvsSFom1mXmkhImb/2PiF3souuYU4TDji/Kls1MZJacGKDhVM0M87zkqQ5ek030Il6ZqaYPT8jF8iFq8QbIoyiA7z+zKeqDXjtjpmGDk+FqiG1w8qtNh6CEJNYgvDO09uXqpyy3jLI+amNKmDMTTZl7sR0sdg996DCusNIIfis4TlOloRNp0Y5me2GD5HEEKcw9AXK2KwpIDZ3Cv2c4QBajeI5Gi1IGAeluEuvjiWSyuD+wu+LMrugUL3pMkeaNbspcOvKSg/v3NfMSdURj6swRRJ10/ZBbIeQx9oQnlzn24ArO0pHbWTDmZoUxvtrhdcOh1GsOh+A2ftJ5+wXC4FvDumqMoncWQ6Xztuk9MOB3MhcVnBIWg6M9Kmsx57BdA8VW8Dm3t0UES9rlZo5shihZ8l2EXAz9Xa4qDexv7S3qwFmhE/FvI2v+kJ9mId4HI2mZPP4crjRK6r+O5QyKpPhFDXgmL+OqYFLYsDxwIrVBuAzmfTQGzu4JnmFZW7ps4H9w4aHnSdg7A3SCsWQ/lBhJcJrb68aZgOcG1xSCJ8FMY5sJq4wm6vlah8GwjVB9yyia1noVr5z8S9Z1+3ob79qEuj8Aypdej9sg2Q/4ZKATEGGVC5tKXz9qZVVa7NhSZZQ/nvzPuIRDvyNdlt8K4CvV43TJ9PNb1yDBlqjjH0BIGE8KZo5zcbrY0rODmOpXKQfojzpbBH/YlGJ+DyuczpscaEuxvQOzQrX79iqx3tKy0RIMB2jVjCeld3VxZc3hvNZwR3WhhVia8ddp7klZ7k+1Q2wJW0WUZV97OE6jxuh+kJ0ok0wOIRp4jukCHdTuBTLoHKrC0cBzCLYI1dO11hShGI/C+naqLE5BLyrAMvoFjKSOHD+r0YlAR3PebAweB7mZURixLdu0+TfEUKVQjuyJlxM8dOv8F8TwNMq8dW0Zfa+RM525oNE9i9KPNTIs3aAYeFYuEfOKPRXVKZOuiyueZBBZEbEBapu7VwpOjcfC0Je6732kvSS7TJ0x0GZ7be6KcXSl7xFxrCN3+IAVfYBvHIdgzrFpC+ZsEQoynAwkWkM0Qp0TBe8gqJmFfXEh9Y1SbIZt2J15FJBai3St3mWEddpWOh0hsZ6JQlZQ55ZbWaGLbjz6ssu6lNSytEK4bR0fU2Tb5q5IOThDlQXAH5DvzBrcTtQhgvks/4pdbDc6fqnOC/8yjxH54M2So6MKXXpSgBxQFkXzP/RG0MvGPJjN+LhJaR/5FTCQOlpXIk7nkDaQUb37t3urOoU4zKvYxGuaHRtSPQZyrw5L3HdKWOUmE85+gG4daKLDnsCkCj9t/4qoAVM8PTpw2UITzRZCjArJiNq3DTyv1UI7IgB+emfzF526Ef1yOUDdlRWKaku9463scaKn5SwbRmBu6JOJnSE6iXDrJprus5+9IHLDcOa1RXx79o1LiL6wjjji3pPJMG3Ktzf9qkmyUj9VJoNOAIGHHOfdSJMOAyMuFGhWJuouFNPZBwVLqQDLih1XrKDy+hbte00rUNh+S8oILwmY9JDn3jdVp7AhTvkymhmbtffY/WFSjTS4etN0wFAWz7RAka6+GGDUV9MRSohnKBXIn82c0RRKb9UwyUfAlSitcIkiJG9M8kP5cQp5286oLGr8IC5/30DEBrUg/zQEUTl78b7rQGgZc+RuSMvfnL8D7fvTeMyWLmi8s2sHIWsNI0GcnCfoROV9Udp45LfHRjw/IvjXQdQUa2ZXmI87hNDSCNbxfB9+abnIHp61oHAFVMdsn385qsZnnpLohD49wlGDB4CaalcRHyORmfgSDw44+EZcx16gOqIsAenieWCcXq6j7NZdc/H//Xeqc9ULBFrq3AxiW8jKCaschdHTcee7MAlG9EJKhmA9TR5xuUo880CDtrbZZgHQKP/uO5X+79veR1SQhdeU2jDlF4UsI3rkeOY4FwwF5K+BhE43sVqFPlUFTwQ48AhhGL+hhYp/vNlwLOPDKE5+j/mvJB30BjUJRnNO8Am+2ridLEojfUsvZ3HOsXeUENgEbGn0w5FyBzbLgXpolmEMn693/Z5o+7PFRA0cDv69G84D70OJqg0o4vWZcaObXy0xHeCViMMUjvvX1EdStEEF+q3A57V9afvPmMzDAkfGRv5gxXy5HMfRGrbKZKxv8MuX8ZgAM5IF61wlmRxczrhpcZXUxwX4qljwqle7NPEjCLNq5gtMp9Gohnj1Gxnf4YAp9fgri68+puXSOUYaUPJoT/CcvTX6+d8Xf6XR72QrgpiF0gGq56rckcLBKvuDfn/+AtusOoq19gcxJH+OOL+bjXoQMRCm0CE8U0sOF1BPilMApAmbKM2EngNbgsWYJOY5uLF/73/jIjVDpSHWDITLVs1k2om/8vl06zEqX+PNtb7S9eLLoxOI3tUITYjOOSfzlPTsdU6s2lqgzroRbvE8yDKaa02M+jMRn38JUKUy2TPkvxYco+i6DxoOsHNKjpUfkWAgBlqKr79RijqDCZrO1XNVU8RQ99trpAuy+m3spSSHiTXxqyWGOjdJSFSwgaMFG3AUQqgh7LKuxL0rVRtjg0vmAQ31nEhT1U0Y0YjqDZtsnBWOirq2uOTZiMEyccLih79IAYANoKAzl1n43WGtRfpE+g7bkjL9189iAvgyf4oxW9HbJNWX6zjVQkUcoQqIv4eMf2Qqp1kHvHSx1On1HyJ45bCGx2AFDreTa2LmiWbkdykKvqjseAbDCJO7Tvw/HKJ0thSuZcSbZgKywQXoqJjN3jDAWCwM3Huv/aDjq3oMFG7Gx/dylnMKFrYyfkWxdP9negmbzPDHydgk5xOJ1wcLeClvxGYAGnNCX/jXYMUddEAXLLdyyVkly8pv6wCSGjEiwJMqIoMJZB2cejYznfFYCwkTmm5ro73z7q1ktKcdwdAbyAYFO0Nl5TTwN4ag9lV2IYgrWwX7pXwE7hlMbbIBj1kZ9VmMkEGAVys7obGet2N4uVbf/I+Fi5q2rvJr1zs67bT/TGc6pJKXELnsc1kGkXNn1x9+H0/DX/JduvMTWLYPTJ8iD/hZFSRViIcwz5b+YQ5F/1ajEzFwpOpjo6WOhTKMl0XN1qjqY3cvv9Meex7T5nRne41StzscwTj90u0bf9zbY/zETPXY6kJqFhlhpyFFUfEGFe9B0jtb/U2AfoMofT8DV7xtDHcervKT7z5ExoWTWQkMCjK+RXxQ2JsPJ9zQHlHtt1B6ugaASla1mWNb5rUXXFuS4X5EwW6X9XJHm3HaMRJYamT9eVyAwIP6o9KLMJwYweszWk2BJPB2q0XxFTuKVUMGpzX6Ugj+kHnbA9ooXGUwBidTh0/VkInocnB16a/Ihr8i36I3pEf+zIYTlWs8lkUHj3G5YprCLABxEN2umB25yw5lzB9B8WdNBkz43oDyZGllYTjfrofn1RGQDxXHS0QqujWnVxn7aeGFeTjJ+nTengetZzC6afgoZy0JCL+04tIpdi3mGBnzY3+sacGHraWgWE/rIuJow/FtLHb7hCa+YG30HOso8l5bd0W8xY3466Q+QSPMj39XDXqm03JVi+Okbbeg1uod495eWjr/47Uk3Qa4ssHcZoP6Q9RlAROag7au71/FBgRrQES/zrAJ8LLstHhj1ncuTNInQSuTIKoCX/jFagVNC+/F1joH4+VAhriC8U6lEhGrg+GMjv2WmC5HNjE1xK0Ge1xcepdw2VIUdTsQr+miRQ6bx64lVgHijIfwlkH+/z9HjKfiCVWyXWin3vHTvOgbm+ZUfbElS/KKLEhMIZwvMsr0lJPYmxa9Expv3ZWDUit06JODgYmyC0+6oLctRHFq3jv7LJOafuCqARNhWSQjEPI0xCJuS5Bqu+dO1FdCPigd1WAGna7r7MNrR6MXq2sW17qM6Rj83XzWdGB3q/L1EQLYi+v1bzA4L+8uUynzE4n3bTZKtqLBr3PsW5k8ERCCabSMYs16jq9tkwp0uWk4acaJEt5VNVGiVmwmta4zJcibpnQq48XTAOJdLV00w6RA3J/PmNTCXsazjt+kWVEAszvoRuoXidn7Ypsu5ysU6oQzcDMtOibpHNsdLZBKJb/ekX/AU7PR9ruUcZGSPgZTdWDzTOdsle/CXXwrlsF4wNLYKgrYCMDymXiGMbWJGJrlIuDWmrGJMpfpyPcJzbwjAJQMlMcmE/o8E+wa1Ob0xu1gAHO03czXKcyHFtM1xNwAMa0M9+c84VuqMmwCaSdE35lFFVuYqoX82lT1EXPeLcKHv7dNxAyZbSG41G1sFxvAJlY9q46DpCCWcWzihU9n5GuN1CF6R4J0nLny/k/pkPqE4tHn4DyX0h4SJTNXZxHhDLapVw0fXF4TQT8M4pUGiKVV4YamOLIiBsTEmO8qzRGani53XnNZDnUIL/jFl17BAMs7EXN2UrJGhHYsxepBiDHdt592a8Ya75jW8//NaRep3COauyG1t9b8iHpAbNKn+LPy2pOYg9JnfBzaZ/MCojCgtMWZvc4hrKArRFl2/8M//XfF9Htzqxmx78MdL38jpN9YMfsL70YlacTuLpFp0S2k/YhEOGBVP2cxBTFuh/7CoOCYX/vKYV8VClCbQxPK3LcsMtrEzcBM4U2nJ8yEFPz24eyR8mBcow1DpHC7SRzzZ9HrLoJKJTrluTfa2Brirmr5AhkscRqZ/C+5bEmcfTCBsdxI79xEQSEpMzJg1uE2/vwg9U9fEstjkRguif3P3+VUZCieNZ/X7u3he8MboaFXh17vnfUCdDeC1ny55K4Ow8A2hx2lN1sQgrpRVppT6/e4eBtuZMjlcrnL/UXLCH0y0tyDEjGd0kiNHN4BvPJAA6KwjI1ldS3gpUeTsJwfhZDpDRS0Mp7FMZnyI7btoQEZj+0GPzvWObsYbIS7Px39QI6/tuZEBDR1mdgTBIJuba+SDkLJwLqyoDM5H/H9IxNfpAPc1MJFeC2S38DtHQhV0AkpVuVp90xCaBNttBTjezMX5bBotiCUG/RTfn6bIvVgnwQZhzrfNhEDowrsQaE/o0PiPWvYT3RW2peDFOxMtm24PiQ0MqgfyZvv+9FI8GLwqVm2bBkshzd40hKUV/LvWZuCZjgfwRD7fGK9VGdAXLT61M+iscjYSABFtTmdbkcCJCBFLq0sOaZSlA9iQEfwmDB3Rn8cmx1s8clqUfG2zUH0ZGSZRYmi06vQie6n/0nFrRsjuxUeloBTIu/T+ncXXyMmyoTtOkqdm9a/2xrb/5BVDx9zcwkEaLlGwWS54DJEmhu9Pr4wZ8TzpFuiZE9EQ7/RF1IBrVyyVLMY0z73rtvO7WQHhmYv/ByJl/QLNac7w+lHGxztD8rnUIJZfO4XS8qdGt9/utxziVy2RD1bePq8RcPA9aVTf6EZxDSTKFT7TBXZnAh8UwIhIC9JmpazUEVa0jcVl4qvUmez8F2aZ041VT6zh4mHWNxtkFJn4yAw6midAUpP9r/XjMW5NChR3P8Xfl4gS064yX8JhBLALJo4PYtrmlBm59FydjWiPJdNSS5mt16+Sb/Ruli4xxysw7ALbI29tkyCfKPJJrkX7ezkagPLI9qHMNFd6swGYupeXzC9D/Rum5VLDA1/+1THAuJz3xbKgvetoSoWRshR0cnkV4yGr477M/rNCvy6KJ06Lsh6GeXXGEXC7IUKiVi51S0XjxpztJaUq+H1lvid8txl4aqnQnFKS3twL4Fhu8StqTTedDIbypj4Fhkfq+oH36nNToOPWnqzShf2zzOOnLHL5JTTtAQd+IK6tOKjL/3vybDxmxesBzLGadAt5ZFn2/AAsEHDZUds5RK2qknksNbp24l9H2QAeLHeiF6FfETv7kUhie/fXbPi2vrozNpu39xwfr1dY+8N3ZF78Zxd9veqi2z0ss49npbNZnEwHKVN8np+nr9Vmw9/Cc1CSMGpqODM1DceL0EDScvJpORsnBL3LboHN8X2j2CgBLE+7mPKpknMXCOoJwrXnZ67bW32mDBx44vQC/tZODOTBcKWzlO1dTsxCCIrQ4PosDHW2HpCybwxNnWruKFUzAMtMCVNO9Cu4EWJiTbC417rpUP64NGB2UX/NQNW40HC7W5TT73l6BEMqI56hsYPonlIfgrZssHSxtP1SbsXvZGbwe+tjRUVGtAGzAmUoLAynoocrTBcTjnwiW6LVmn7pjOzChhTWDYGTqh95GmFePKsLeXgqa8EcDUoccK74TsI9KyIUMk9JXwf3KnFA3YIFs15Ve7vTdhO82qTV3zN1Meh/sxBUoRdeIVdcDJm9vz3jGykV4/e36dw8t6rPKbuF6q4CAEftDewVLLLUUdEAf9aUZlAV77t8atktiS/AygNBRoVKWL81QAjrcw2JsaXfaEv/fA/s08jcRpSjMm/fzKCehcY4ynct+aMtl8gp9Jhjki1HGi9P8vVAfpdL0A6ZFX11GPIxwngwrVYFu2/xdI6GcYxwE3QYYQrsmOzvpp6sh9ysSz6dAID9y6fkJrFuDmW13hnPzT4oE1qlxWUiUGuJKn/+eqQVKEV45+9Coic6Vyp1zRfsn4rsGrf+fudGcexx5ABLnfjlaE7mNTW+25mE60ZzybQ+FhBDFfRUj0a5yuUeAHnXnRemksxFKcy82it1PQcDFJ9tm46rDQdudJLXRX6vyF+Njja+iRm/hsWwHCt8v2kCGFjp636gRnYXfu6oA09E1kzTXz0mql0BBWCsaKcaRfEuUkckU3jlyzyXAJWqw0EFs0KUvBXObD6krnvlplmxSdeQWtO24CMZSkeDQMkMm6AFCyKij5+MtbFJRBpNCOHjtUI1GAJ/ezqHSEKJRZdcBFET6Fzo9DUvYRgdDKbZ5rK7yJWz4lmffx0zd3p4yuR3VVHPe1m4e0DPQWtLLmZByHvIlsS9FuMAlldAcMGoy3VlKnRJo7uwHmCPyig+eiZdnU34dnkafg/pZNggcNOTX31Nm6jJdaXDz4cnLQZvsOW6pdyyOXxQk4hf3Yilbloxw4Pyf6Yej3m0xg1Fte/Zbx3jl1HfO5k3LMmYE63nnJZTe+5/b1tMvBI45jKCDVvzS2/umPBGdv6V3+NLEDQLLQL3oPBOk9SCIiOsPmeJtn1KWyLDHa4awN7lAgAx3VAa7ZkoVgppLJcnrk+uYZw/+re4t3RqPFm7PdXb3/ox4fsadK69cMQmTCnIFnxKdu02EtpeBjU7fiHzb0XXq8j3TswkyOSYrq0L4pwZ4sVs9EkV26+FGAWJclAfPL113vjan9j+HxRbktywUSHv0lRI0IgM18pLP/ThadPXYGrwaDRsB4SkEW2LzdzB3AOA+20QKTiluDUEdvimf46h99bewZNpOXnDZ70GrVpOwgZH7K2s4UFjRFs4cJKh21g4Qet/vZD1zhJtVzBf3pL9UItdcPPUQUdsKvCo9ZntQP5OxgcQsWEl7BC0YX9sb/IuHi6AFVx0yAW9zD7ZKgd/KUENP99Qellfk6fA6RXu/13915HWjBPR0SaebvbCTP6/MZb/xXunCpHVa1DMeu+7q7SE7a9l1Ru+Tl/1/7NY78mLSU5XGTwca4OByKC7KqKYCNQBnxclOEQ4QEWkN69UyefcfmRhgImxB8Jk0nVDox38UXDiNAoEVZX0FKs8XaGsH6aij+Za+3kg9SiX8QYUwiVVWMflssm8u67juRsOKK8gMABBX/wWKWJv3pRt751WY1AE+dtVqDCd39Hrr5TTeU+pV9XCj5VYDgzzeOkH8MGVAR8MX8IkIpnkaPGtzHJ806Vyc3MCKf3mEjZXB+rZghqNLo0a90T3j7cXz9vly37MJH2xcBw0YqaEn4jbjKO+GGHHtCi+pt0z6+GAooZTR0oACXU8IJsFozuLKGeUqjorr1VYIbeBvqwcBVZHbH64Clxlm2n93yqBYJWMfRuzXuOsWQyGb/NrwxdNXaOz5Mbh8F8D7wLQSmEYtZ5J8vvkF1Hn1jofHsvqtSgLc5IumrOu9VT8m2l+SMHPif6Nnxj1pekL2ZPSbQM4Egef3wIUxKx/AT9bqID3t3Gpk5xVKpsDv4+JTugnbG5HNVmON/TMfa+wH2/7zhtIGnNiYpHK6A3Y+JzWCXmG6IImFOTBv1LOr3Wg9BndbtEMtuMHwVrR0pqNnnW0cyHO0Rowl/9kKRQVKlP1JSMPHd8mUdN4X80eC7x3ym7VWuP2/ymf1+4m/cK706GSJ6BABMtjEVSiuzSTLNiYtedLuKfarZIS99gB6wz6AZbq7kyptNDYG3/DI/HKRL6T4iXYOsqGALLwbwFWJ9Mg9jtbHs2cBgcDU4kEtH5n85/ppbB0Rhf5JxoowNRoHHZzBBpwpN70y6NuzW/UQuBd1SGJlQbWuuKtwinlZ5KuwlGhzBc/YJhG0uSjC1W8BY5CURD9yk5A4uyXS74I1bf3tOOM2LJmNvVT1y5yuGu1rDtSQtjOmxejSwyjaOAJ65dTxs61hbI3Ku0cNXAQJptg/PUtZ/09+PL7pYgUHGcan5++Wt9BQ9F476jl8Bm8iYtav3VrwwPh76tycHngZUqws6/twDA7ie2Hr30OfCyiE60cUwJWJSnReS3yxTO9eMMBQ899mI6HHYvqvAJDLfev4maXeIWlsduAaZVjusk787WAKeurWg9ZNQ5pQ+NsTNygi3E26rMqbmLh8bk2SQGQbwIUVbzeD/YwoHh2o8M9M0MBo7ZPlyUg0xLQcvMUfZRNjyvgaFKdh/EVCSX/VfjSxy4Gv2eix5GuA8f+VxMsRCSdedZUq6EXXFsDjzZ3vZwyri7EFCGvNRTx80h0DfINW3JG6VLkqO02G0DqBknvjMIoJN2tecfaf2rMRIN0rRrgVoqvztoo0IMLRJ2kt1425oemFTKStUuFe/glN1H2kcqaC3OjSwX4tj8ZztIxbUd/n54qgA8O4e1B7q8yP7jAJUpyFssPgta//ozEZxE033I3hwIeHRvaGCEFRX7jQXXwtia1WROJGQuXyXpsm168JPRMs+IqzFgZ0jJmwSC8Hs+f/B97rOEGPr8Cf6/L7C+E8O9N1rx61Pb0Qn4kVSATeYQ3U9I3One5SoxVledwR8CkwpObPZJ8wfw5rc71sZKBCywlHb7ryDFesW0n2BtWtcyKQnT9K4XUo8Obf8dPUnk1+GV84cdR0+xvPkKvG0ZhxUB/OBQKLpaKndZ+Res4TmaNfH1YbWlaeMjovE1O38abREI2iQhNPPiwRk1Dyq4KtwroxaENI9wojaJSDQ8ZjwppOeUe0V9D1Q59boPkMIzrVRc1WzSnBld7bBot5h2v26MFinATWK3lxlavcdty4V3ity7fses0dwt+oCehldYRmzqOwhtRSAD4QuLy8dYzjRBJitwPzxZafddpHcX5IShTx91BecLncR8eENWffdneG5/7ooN/julN2DRV1+zFRXgWb4vfc3VqB6L8yxkeG4GYYArO2PEVqiypID/pxDdbuYxvldtHYH/92sQ9RgYfLRB96h9OkfETjsFgiTIiDdtrHp/BMZ5nUO3uCscDwV2Z8YTRmAL/36hUKn08PNcc1Ts1RexdNY+2ygszVzyoBG7tcwXsjirMDfW8G8HrirLbhMoclXQZ3eHrtDdP1tf4e3yfD0lBMDkqp/kCLp+54qg0L8nMbPvq/urxyDJZI/cdYU6MADl/PNIleVrrbKOrIm3X3wqB4tM6OUgPv+M+bN1lQN3gDKKjkawudzgFN74RB9Wad/3Q7iICOa0E9PWFrJPPF5dYWiAQw8NKZKULNlRoeKreEtz8TTMUWmYY/g8uiyjLOyCK7zh2kcNlC/+33u8WtzCqSvNfGZ9H+Zw7VhpSoLRXJkD8KPVKyNvfai5a064QjGXyL595nzYU3G4+86VVLLrgHXCbp2enly7GOOV10YiMiX4aDFJEMfNcxRNXf4UEayxHUNg5yTDDsEhCAQJe+7Y8vvIYXWyHEU5qX8prAj0ikQDI7CY2iXfZ0WlK7wO3L4RSIbuRPAWr4wY/AHMwOG6wzojhHXa5bOXqSa7V5kn/IHmnV0Aq68H7JdxpXhq+XGp14SNhkt6C0SFr/Fqv2VKjtkKMWhijlSucywJk82GQH4eHJqxkaOy4roVPBowlv8WydDyUwDG20LTT94NssD22JXtPYVr30PSqFb+ns/AWnkdYiUZ9/MCnspYACGPvOdup8p3ZlV0CmdcLYA/LipWwgTgUuOBxDLU3Lojqnxpn5R/LwRpoAVTsmHxv3/L81F9dM1JqJ6k0xA/nK9frJ/Z6TkXfHsD8vg2cgGozPAPGD3mK8K2MsrhPKaQsFEwQlXCuLgKjy7DJH2s7Ahmo5qvNRT1BqqxxbU5/w6DkShsabUQNPdpMBJoLlxabFpC7rRTfMZ1UUWl1gjIKIqbwz0uDicZNYWPOaHjSit7rsbXb/CUxXExLN1w4UeRs4slxijfndtuvhjIySiPZs7229s48FjsnDo5KkcznQP9zTRsiBz9C9zV1w7RvAcj2vdcXNJxYpjAnjSMyg4zM91s7uyysOUD7vGJICcYrtBKowDlarKnnevFjJqTDl38i0jwsag0ssPpwlxZNJSLomyDLQEtJNgdGwFI/RYO8Rv745JkWEii1LPN/t7TSJA5yX8g5WP1dRZZKfjbw9ZhLiNBLpRUfHKA8J1qlAMAlPlDv3pxCI56VmC67FVbTaqjeglgX45Ns91kT7PbFToOuKgdAIIyvW/x9X4wLxJjIIMvGc1bVUtF4wFNd24pxfLkHjGnE1DnWUGPWY6rVDIagfz38nfJa8MUO2KeitXkcry8xNJfirhm/SAeAGupJq/Tp9/t6ZMKEyYffbkfof3lwzWsW/04eTtpToPNG3wU7S0LmCcj8sLtaRhzIytfl+iZqYTAeBEyXaJbWl8LEY+11HCkAi5GgpAykJ05U+2Y97K1kWQRhg1iRk6ftc5KNGudeoCuQP6VcnFHpX87xYB9ZI4f++E6hp9N0lvZvg6LINipyJeimBlOcifuUPaPJ2nlNKN4jB8T3MXsrsVLlZtRw+dTyQTDD0HajL37ZQK2YI1caupCGSHCjY+OTlBrM9FxkxOqpfgArLRr++zpdSXZS4+E5wHyJR0ixPbFUwrMME/4yvkgaXTa3wsHzCB4fBRqxjQKw7qmiVZtC5JEWmWgYZ8e7HgQS07qLPnK0cLoBC3PGWHmCmHVERxw1OF/cEUNyOX10HMEPMS73EmmnZgjPFxRBoi3a196VaShYSvV559jI1ouBDdOHgOw7rEQ8cwYwRpbTSXkW3EOBZR6TDVXB2y0KOGvIU5ZAAwyXdTXJQKQy0Yv5eBkzSDqjXKHdi2zTj32aiK8sgZjXgeHRWQE0NUZANCc+9jQwMlu5Sxu9dSbYOIAWRbAliXLn5A4QK3WyfAK4PfZptTbop9wzGSEyKrSstNAzuTNTzFZquaDG7Rh0ccNH/MHFNbaGyMBEH691auSDB107bV02JCXm4QWIWgKZC7I56LAS0iLH1R4LMsd3zudHrS1uM7+B3HrP9P/58VOUMaqT+oTD1yPZwRgYOvYJ8gVdTe8d1qUkjQnvDZVDTSa3qcOnqetEJpuMZCc8qQPe9phjHq6l+xY3rgy+E/K2z/vyLo7ZxQ9znY8SkByZWDKJ8E1XXN7G+sXQvIUTxyUfK76R7kY4QFX8skLb4NuBkZLCjdGCF3WQP1M4NOaK7kt6c+ecDZw6/GdC/8H6Pn6fFhHz0y3s3Prj5UAVtl1/VdbNDSFIM9QLiM5iBHpqC9Yix4XJvN3PeaH13XPJ8BN08n0BWD8IePdBOjtL/5qwAWfQRjrMMqRNC0K85Msrm8003E5VR8iaK/BUKf4DpDXKObI4KaqkpCbeAgmJKoU+YWPiGxDZCGWMACrZMot/ygrwHZk6SYoXWEnvFpBnlWGU2+wc3ZH5FIHdUBJr3fpRUalm5sjX1ENLuYNJQGCApQkuJYFh7PJcFnSDB43FmUV5qmWmP5kjPHlEO/008qxkDNccHX9sxnWC6KZojFAMUSK0OQF99GXqPpbn49HTOXYmLD/8QhXrY8nJcZcuVK8wTBFrQH/OZy9L/9Oo3HKVjdJOiC1g/0ZxDXymMaHPy/JHLXKmyYLpALL+b106OG2LT9q5+W6Pdov3p6ZO7UuOtBg2yqpBT7ZTRAufAdU8GFnyEJNtMDM1M1tOFtsRCJIzFAXeDrS1qwyA9rcVlsjMxEw7x7Zp++kuK7YC03knnGj4D76+XtQZ/ntNx3Gp+aAinpppV6Wi0FbPrlG+wSBigFLD++Pb3sr/juSqeUb4clGDZdn+9as8SrOpkalGTqVoSn9WEEF+zSVNZ4KK7gw461+/5L1ekWhMdq8rYc5CVnjE1BP77H/EkLr4bGCQBOTz7Mmh8ri1b4jtPF+SCV0Gio9DxR1bRFuD0y08xq4rP5S05lWfPWv42aSrR4WJNrMCW3uPWrjKisOkLvOQ8z/mErG3kBYSycg6NZ52ZOeFoQzc15MBp9xrjzzld5eySuVBA2BPVWKDe/w+8bk3H2z2WBTAxGpWxZbJWnMQhcE203AO1kW3FNDL0R6mE1xfM9w5KjdJcIy6C+Nlyp4UQfVwQOZrd8qP8h0Hks2mUtLQuT6vB91kyLVKNvBrl5gp2rTdZGD6OBYt5/IPOxSkKNLCmJyfdLFvX+F+OS9AzN4bsQlP1f8A/SrSIxVpU/HIBMiDe1uBQfy9EiwGcxmQCFSdeHTRWo3kgymy3nlg/15o5lqCzQO1J3HcVijlccpIQLsyiI5Zbr0wJf392EaVyIT4jRnQ9nll9xyYn0QdeFgb13+xpE3+0vXPztYs5KPvK/yr0gBaB+byxq3Yz5eXlNiHhzIc22Lyg9r5e1ytzuBguArrRYVuwy0Ll+aMXLLCa8w4WLLwYOwEtp9DsKSOMVd6kmDEl4pFuksFMZN/yjsYvFhBMtqGO0E7iep08++A/ifv4MgnK5VckNXH8lC+S7ptQo60aGHYYmeAmVFmHNkwFqgiyWgrInMv33hDLKIq+9fomEaTOCdOvPqGliJ5ealQQj1zyePMR+o4KVZihis+SLHYBDQ7zxivdFoFJml00veb+2few1UmsHyaHWLlk0cYod3cCi9gGIsIvbsuyErLYLT1d7IFl4FBK8mBjhhbRnEgBrgLOa0nM6b8G2Cp+LtQ0DQJlwTNxk2Xfh30Z95bWZVV67b3Uljx4zrl1GyMun1VZ272rMiz4StAa3RMBTwSM/mmzc44KixX56EATyndBDsJzXs2RlS3kw8we22NJwkxOXpuPEkd53F2zwN4zzFh7a5n+mI/ofqtCRCpvPN4MZgF36n8ZIkOFppr8HvftnKPMt2pT1XNxkWb8MWNT5XtcEClHcKJQMS8wy2knHjSSz72vR6T88IliidlUhvvOO4YeS5uZY+Jsi+kEdnBBTKSf8rmLiEkgLUgpoLIYDxt5j9FcmZ/53goK33dIUcQXmTwVaOyYdsEqNDuV4o1v3F7tR86HswgzJF2cr8Ym19nbLFHV4y2bVOqOUGpVh4+SdznZMu/u6bGxkzOV6MooT/x0Dm+k69Wr9EeiBHC05XaESF6Xc2LaXtWoSn8/gP/HF5lLehkP0os9ao3DBmY0V+alGRf2A8MO9Sr9Okeo/WrASvBrIl+J5vt3BuIdIPZcL+P1u4/zqLV1hDPKNOkGFkY4k++86m1N9gztHnCKnsdLwdP1DDfGBCguPSGDgBmOBhMnhL5b7A2xcdRCiNQ0zXOsn4HdXTtCXy4qPRGiqsV6c1KKG2fcrk+h2iriMN64dyY/XY+iE3GwVnGQH7FsTJP4x4Pj9crkbOM8EPJPORGwlBCQusYjuluX271q4vP31Ag7o/ZBfwXmQjM1qS91A32SguSqQzvXetz29pHVqSvKIQCWjsN/mG2CKxbiGtpoeGqhUfaqPzWtExmq0ypWxelVgO3i3w9yRo9nCGW2preQdO9vF3kg8UFhe5vWDLFXXLw+qC7fy6fVJpeYR1SGt5ewZ08a6UyCfHwEBTh8RwKChr7vwy8ENNvqfvxmT2nN3V1qkFfGF2FDiRHv32fscMd2JsuOBEtqtDNgJQo7WaRC4oTurJLF0ucOOkMuoWmzLy1HBVVq2DZyf92V+wlH4fevivnIzdtj4oXhI7+bO3qQGMZPWGQlTYmr6Z7bqjMo5O48JK4oznFnfpUMwV1Hnaum1rBUBymEl2N5c2YW7p+B1Ue8JL2d1wOQL8LJh5xmr/0hxYqZUUooKqPj0JfXOIQZawPfyGxCqRQC2vADcNIpcRS04McmJ2WRE7ZBd943ANXqFUqccNjl2RBZSlHh6mLKZEPiqcnu1ANbU49ST+q3nJ3BELQbxD47YygBKCJL0clbTMvbvyRalt0+mSU45N9p6IVpP2wvDqNdDsGkOUl/W7O+QBgegtm4I3sdIFs5YV60/i2Lc2PV2aJTSZUoDnz4y6euXxiIG3Wuph4tuGAFov3/mLtuoH9ofskqtExVXjd9oLSnw5FqzhM0ZMdVBIM6TybvykfRFdQ9GaTCyoBeD/fAt/fP42PCcOFTj2fVa2v5k32JCetJUudnxoeFlq+Qh07OHf3M9a3TX+CrabI3kuFbmMLtBgcG+rSY175oUpUzreDoTMMQIMVvFvJ487dDSPHhYWDAGHKszvIxMnG0bsJxjZ2liRfn8BOpiXqHrCnAGmXWBskanbYoCyqMz2OYjAeZHdmgsd6dWpZnyiE2FHW9WWNqQaWFHUuB34ac4crjgx9IjLy0lAo+5gRfIp9AbBcXaoKd6kfH2wBztt9jyIuBjtTJj87P1LaLaPYWrGli6Lm1t8Vs5NsiY/dwh92Il5bU3AwQ/v0peXe8Wa8d89IHPS31k59VspLqc22+OBNgIr3tRl3UaBhSFAL26u0tezpdEaXcwCsLDv8wWUNMJAsyYG5NAIUi2LmiU5spd3QLkHbVshhs4wESvPZ9u+35a5c/+nWHpJB95yXn0loRdelcVqnyiu4ChvwFnsfaGcOZhjgynW0E3tohim4yxkVG5otaGXxmSkJdWGeBzXKDlANG2DcdM83NkNAqKr1e+CGk7gKrLqFV+zez3UTg6TPZVo3NFlUK0fYQ6AYhSqo7EDNce021CobVbVwS5VK/+4GCJIOE3fS4BlF4v4rg/+8BRGbW5zN7T+twgd2tvQwLk+dwGkwM+RbV3AWFBW6B6t+NX0CBd5msHjW32tYg0rd7IfqgJXxM9Ey8qr+MwTY0e7VmoysnM6kB9kUImh4OMwMhnyYik/xkp4dVIjkV4HSNINv6B1/bNXIcHLO8lbbS7WovgDueFqtA5sP7lTznPbmtiZnDFNhmt1LK3EyGeWqW4lbiU9la6Vm38pKoIDXWQALxYl5JG0g76EygEg/JIQL7AisT3mnMMLnaNQyvezGWytGsZXpSzOuYtc4WDwcx50nOyAz9nzkyXGB6vfVzR0B6lMxZkr1ZMPRV2OqZIH5gw9jQgrKMB57fMhRAknYuNJj2Wf2rPicz+0o0fzco9OZo6eyXc2B8L47hmqQWNUKJJ8hLF28W+HwEabjRwHMgmPDXMLhz9Q7y1fx8GNhOpH69lQtqUaT8BGpBZ+2VOkpXGDLCtC9m5zX5PTf+MXhbVOrGnOnudSLvoweGahleKM+BS5uY8woXT8fverO3jUmE2m8zwX8raGgPMdoMX+WrjvPbgHX052QXoQYkdolsA9rTwSHbhi7IvGtOTWIc1tmqwSiGGOaN+osz3wmUt67xsD+DB1F/EHWK+5pkpzuEicX8Vgq/ZswiVDQMelOszyw86owpQI4BdlKb4G3wIw8bncbgK/8FpdS+yyOXjpTzz/YVwngXQGF+GeMClKsfDPylrliLxreGoks9rQpeZOzaWcEytBuW+ir9rbttmBAEuXgPRoaR0zsUacPmD3yXeHXp0/prCk/yMKygGoW9WS+lPOfpz81bNVhxaq8EcNjz9E7HYn5EtJ8OMtTVwSTLprJQ0lbftTZB3nliJEuR10D1YvxPYn4FJAp+rs9QVd9RkjCMdMd+NkdrKKHjhXFcp9Xd7RQ6COzItkyxiUCcIONq5dWiORiERbzFbGr9ZNgKmmDVworyIsUqLjix9iudQnNSRqc0eG3ZGX84/mFD0l365iVDlX8SK8a+J2qZ/tB+i7TW9muF52MNFmLYChKIx29oH42pGm/MO/guPjsLS7qTCByGOstZrBzWO3seloHPe/8ZbUn305YA7R9bB9YkphjzTZMGZ7IgI23XTi7DWZgr9cfvoHqXghVp7b6/FYyyZs7s2diqfZHs+8atciJLshVVdpCFjsPgxQ0axgIevnDCUie2FIdYfIc6Y6joJvpbeqPR/J0LZqvYKDzXpKAzGg5U4pcS5SpJjxqvDOItMQt61UBhtB9SNvCTQTD/qqDinoSjJUDxgkeNHOejZnvlcJ+hRRgJ65WpPa006/JmMWnmWGTHs8+N1gsfiCB+x3QJ8Y3qzab6TgkaROBWI7vv3jf1DR0o8gFU5Dw/Yd0G+rYZm2RXrbmfkPkkz+LHw/j3sCZObMtTXb43sJzc1QaK6b73+YqwsuHC8BBp6KjJkMUO5G8MYR8cIBYBdDqqRxMgx492zq1Hsca31sjDVDzhyiNBTWOchGBXQJN3yK5vbocfwgiAAaHVJe+2DWL+vuaEV0ooapgC/O+Oby4oCL9cmh1foZBmzA/C25+Dw/C1HJhFQNp1S4M53cBdPXmcBP0fzjAxYUb2R3eCvTrqtQK4rGYJcT8RKpiJ8qwcAN2wwffEXHH9jQZNyVkLqc59xc+kFlQsXhXIZarJG4CeCu8nrXUhrf7xPuqjq27REUzCXO1XqbCqDalUSRIgCjc/d6XPTFelqGAU20rNn0mGTZIdvxsi8zX12726M0O22nXeDm4J1w/CeA68Gb689CBxhcGlAGRJ9tCI3PwFAkT6v473nWoVwXPA92eCCLNstjkfaDplRTMIs0zT6SywpHdQvtIMd39xJJKT9C/0DeIaCWTk4cPgz/ExQ3aKjnIa2fx2ksVhvbn6gFsEz0obSVLBHbQPwd/NCvywMGwQpL9puraHuVacu2DatJnJyKrPXxnturGVDl5TY45O/Us3Lptl5GNW23jJmZZxHjMQRfiFzNMZVeWD3OyLupYwxjxb2Mlm4zWsQGq6zt3vvROMNIBeMaLdcRZ0gMoqQ3DKe0tFJaNvM6XK3KnGEO6t8kk+x//xltWtkEOIeYBAP36VFy2AFEfT87UU4kBu+pu/Gs1L/r2FO9u1v4QQQ/kXEjkKfgYqRLqJmrdWu+nI5IzKT8RjCsA28kxZPAZmJa+1ydI66W1RZ0VZXoZqJhO9p8dh5WcZOC/FuspF3urLO12HRE1vKsEdNykm2IYZVfy6avqHcC73p5tqh7Z/Ymx3UGhcAFz+HJIm7pv3kyfnf9ZoLikGjbBEj0SLPBRUrIGTCPwx61unRc+tCs68YizYCEZMxWOwGn2Q1fmO9h2lPuyVfCbSmsin0xcUNaywme+DYDMxZHus9BxK9GcPyB/vZGTXFb7g+YmZc9x5pQ6T2KqJGwYirvf5te8zFpLEJDWz0rkHDMgEY0qNSkkSoMXSXI27PGln55ytg49mAJ4ua0SHvD4jFz0nHD6MbLI82H6wTaR0c2nCpnxR4SLRO22Y9JFLGJ/ZwtO71wDJT/PfE9Of6azcUEiuo68P2c2JRT5c380eEsvCptxX0gQwsmVJ/APHjhfJPKIcBaNAKZ7dOLsjUm94mW0KwwYPM7aUGXutFSJztcuptiF3NSEyLhSZbzhcodv6t/KG4cC8gqCw3ac3WMJfjbYtW7e20vvYPxZvJ1mUmiLh9iGDCb71XQzCxxgKuNYNXyyteCLDJ1g8VqYLaXgjA2MJbOD9YvT0iR2hxJ4ywxOPpa2MKotaVPIbMKeXSYTw6h0EDEOwc6r69vDNyiZVYO6ygU0qwOfy++oKCl/818VwBvsutItvKZs5w6oqns2rQt+phSROY17ExVJujaZTFak8ZSyvfn7BBsQg6r+OcbbcANdVNsYDQYQ3LgAW+cj/i87b8DAGVvyCA/hBegG8f21NkCYOktKYTK5uNMOQfBjVxAaT/UV1CV6gPmluYnlfG5uYHzDky34smXOdIOV6ofcnNQTyrd+miVEhUa9oaKovNgH9Ci2p4l/mKu9CvRS2wtZsvT6Obcvi9Y5z/X8v2+Be30mvIVuoAm7bQ3jqv0kwl4u26UMS5fDMG5Ace/geIVauJ8kaKuWJwjuXJEOU8SzjOmuW+ZwpxI2N8YrMd9Grm4XYmYpQfy9Gyx/lXEVbKCheaw96YMKaHgX8jZKWmmiYVlEBxL/u/jlpYpZLA8aXYioO9wdD2iKuwYBuITrhPW8oVXCPzXT5v8BPN7pnQumVQecIcmuFqO2ZR8yFCTslXTz6+KZtAo+Zj4DKC5wwUEblO96cjLjto3/UaVws/+eJv/J/voNjzgYcASHyIt862JYzLVn/2PfHelX+qSFojubM5vb6BWySgtojO4EHexyR5OgJn1X5MZdS1GvNDAz9C2kVOYSEGUB3Gvw4TUmGzyI/n9hOfveOesj01f7ovfjg3edK4kVubudW43ie4XnP6HmET7KSxmNTV8dcZO0yeplHOasOtxMdcfRM/Q5UcXTjlvR+QYN7J6jbyZfPKy+o4VbQAuu9W9l2601/IlAN95RxikJ1FjlwrY2H4AcKNLGNi5OX3qZuHshxeEBZsHuye4VIN+CTyitrwy+jgIxoWSawtj74HykkgpdX9vQ5HOm6AwBdUbWDmmCk3llwye2lqSqolA3ON/Kr+bC6TUtYf+qFCdlzBGFsw62ejH0AsRS+3WYc7hQL519w0stwfrXVu5Hogl2MWW1xXCNKUbzLJPiShYrKwiqB1nfWJsAxcbkoclN5Q6pZWKGbTumDtqV7YH2SDQAz6VycObIDYE1cYPP3Gd7453P4+K/JdMDUrTl8Cnqj0aq1zwCv8SZBgGR5L6GkFevxfWk4cxdGKu++TmFsCSIsU6i3Uc2D5SYP1soOrhNpygL1ObjAtbUVTVuUZqnXnd1v20qH//AZl7pFe8yPQJq8aAL9MmR5ndJDBhp2SCYQp436yaePWwtOsF41kNKH0+c//+3l9d/xuTmZ4pXRJktfY5jOcx2kbuFGJxpyXPW6Ru8p7R6tcvpf4PFhQpXhdciFMm4iaYV8pYLS3Op0rWFwYWhoCJw4FwS7x5TdQTdMFWvH1IbXLAJxMrqIu91ZrfEAQHlIQejYgnaa6R59rjMV2TY6Z5/+LvS8aP7i5L4haYFAdW0MwL8LgR/5TA7FbO6/NIvYYeJ8oyvUmiZXE/UxhyqSMVXVgT8trdxuShfZrYA0ryOq5/cewsLIa5Typ2B8XLcE+5N8h7STZ5ue9UuMX1/or/cEkmDx8ETtwzJDd7kx82+nnfLuXR3DujK1pRviY3ETBkR7W9n6lNjfSuQDbCE6jMlPhABeVk2dEqCICSm56VT6Fgx3fe5nadA9QnVWazeYEW6N8tZjyptCWVbXpW2ZcGFk5H0zDzQbLe/+ZCNymd+/fUtRrvykQvoyClJVzoQRwczXvHOe0+aPmy5OfHp6wWvdyKUlWGAkR3Tt+yjJvvvYTgaZ3XmsNCWaIra5wZfK0JJB8WFH6kuvqAG8Ccj47pW4A86rbXLgeyFSKqEgY51L2xHquA3WxoSLYBd78yk9TNWFCHPqa63aoVCYHXm47o1pnROPdjcVIODZUSnmV3DFYGrnhhpOqEWjdTuoTGM5zHZhXFgQ+dFR5+kuzj3QqzRbl/baD0sI1DsSp3sg8wXR+YtGBaDgOrRrHu4CtQxRny3Unm5rMpCLNm8Jr7M6UKUPa+T7clGGLI52jc8g+cfFRzN4zjuxCwDrhC90E6aC14ozlcXXDUYrhFT1OWZ5w6oRKyOMLI7MfELzy0HpSJtMeoRt28sgxAg6WYrwTJ1VuBwaeAapbU97zHbi00pv+XcD1NxA1ZX9p4N453/kIGZmLQEoTMdDt2GlNTfoeKRkbVcOWbC/yzbbeTn/BfWMFVXG8FyQtQU5adY/0Ltf3hIq7wgeiJEfGHn7qxGXmy1oRwcg0rvaP+SJc1KVoaJIF1kYN9QCMGkI5QyJpN++HzDVCLlcDW4RtSPvPR5CkjcAd7kc3rtNHeL767n7/qUlEKaQSiWlI0ixjJWQpWHvy5Y4x+fXHnNmcAEfaLgoRMN+j2MKKA+7hX7tynqww88pGd1ReLEehC0y1OqHKKj+qQ8TxoYaA7JXH3beuQ3o7EdtVKH/PfkQBd7ysA8odjSJIPQKMmQf+3S+uV2EGKdo7npRs5rQL6J2e+mrBv67s51/ncCLTh4ty7dN+fFFVLzAZiWFTNhse8wqO395FfNIK/hf5qZu1LI8yV+NGWeZIjWQEBpihtFnSW1ETMbT5TMGggfCeRtYL+Cu9/VKcjzRCm2JvdYZk2scSrMKP5I0K9w00YaXsvhoWsS/BPwRLhCWKYinrv4TkdntCvP2IFSM0jMHZy3olFfbqXUIdHe7KSDTgY8Hw1yZDi+wXB6DsXYm1Eb/BrXw0i7TeW4L8oPl8vd1OCv83qa5QJ8rYFQTNEI4FMv4XzfPrsWWngnISMMQiPeJeICUXlmK0D/ez09eq0Wbxb+uIm2uu+A7pQvRq4bu4+fkjd6hdhc2Eel9OpoF1EEjs82h09I0HH/V1UPcypzI3Ab0kUrscsip8ITjI9R8fUsOagvXAVMKyarp/wwrhB00ddVXb4oeApupsa+a7KeVxo2yoed/WtlNZkDOx+hffCD2Ar3XwNj4+6Lt3E/gaoc1huP23KMwN72A+LjErSq06jXdtO53BNa9qYJSC/4ospYUYOGNh2wlx7InAyPShiav/xm5fMvKB8coSlW8QvmgqteYFexwprFCSTf5zB7STdlY/1jDVnbazOBzrJkbhu4N3txhzK2FapnhdxSR2asHHB8vfFiJfLAiJQVkkK8a4coyFSRXgA/LjJuSE79HkkRJQWNhHjcx4HqklMFh4Bn3ZyfAeecvVmlr5zGFISErKr5MhaQk63+iSAYnDzTm27DiSEU+grFua1+wbmAyXHefODW0E8hmdSt12n9MWBlhByMEKm8AnT+8wFJqApsFLCiyvBuUY6HCWZr+ofWbJuzZSA4vdd+IRli9AkDFEmNFu+jK74ZVEaKGjSsghMnxamXQnVDIJDCUJtt/bMW6ABHlMyUD/Y691wSoIPvkUQxejFza9aJ7x/XrGBW/XehpXVZx8BR63Ei+uqfyGhyau/HZ488IuZSiEuGyo5rGC3faAwsvpRow7tAesIObtzEOFAr7oNU1hrq++o7mTg3le9D3g14gmBA8kaXBTPmXeBlsy++oKr+RMT2eJ9YTEqCJJMMrQp4oVe8g0r7eyjTFAkSqQbr7tcF/TV6svlnn/oVqbutTwk9SJF2u+TvxzKUQRLv1+r1+xxlkAbUreTi1Fp8na8RVWFqGQAlpQIv0uLlGt3rasOEeW2TZ6PqIkIZlFmoK+MFDqCSPKLv6MgP6C8DaTFtIC70Nmjn2XiIg9ojo3fj2npidtEp3IrzhBU6s5iAWkJwGWxy4nd7HMPH4fygHrEZTccdIi6LrBp6i94RzZzPACsSiLyOdmeZxLop3V21cS/m05nChrE9a5dhHkZPi/3pw/eKko6fZ7e3SAkfyxdQtbwzOKiwgS3W87DUguyvVzFiqNsmVIdENFbw0nu9K4OckR3oVTOrIOsgKsyxEryoLMt8gw9JPRr163UC6vL3azzfej40SpG6NAr7g9F2fzttB/Dg68yvg/sZQEce77QGPWMSEfRzDDfw0wpCbtRdywAp9mYzAlJ1P4O1scvKLiCAvFHLpWkscA2zobmEZij5Z5HolU1SwjHApYKUiN9g3S/kQS4/SuCZjowrA7OvbtlZdE3B8eiisxHEIp8Bkxyhf/ZdKF960ICbP0xaJTIMo09cHDU3iDcSTWi3ms7yS956+vVJV8kDAx1bKPzKb9iOAQgE+gW57rfnUxix9QE7LGvi/KWcjedgbpJP7S4LGOvN/fl+LjNTiZd8Sc1YkD7YNKI035987+SFuzfjOo+dBg9DXrxmw6H5pJdD/km8TF0EggMjWG+O0TJo6sP7YjINGqG/UddWV/k1AQgAIMWl3agnyF/cLiNthvJqUiAuszxwRoj1tKAOV8e2JOP1d/DAZ7pc9jGpACMHsUJfPNzBt6T+tP27tpXo4p4o8vU6G5weZkGSXLNusBB3LA86R0ZxJ0mhXOQxYz80N5uWNl9QdY2Nc4VahuuHoTkMiFfGlfhiMaJXszjycw42sS9/M/JuXWvGlDccIJr8WH95MgwWIDRrymCdiC/d2cew88SI5ASYsUiRAmxCUnQyxutEcPIJgjMk+UOg7xYdnnySJxli9ZhaSTFr04rXyEajWhFpV+w8nQq/+tD3OUhGbiqf6OBbzay1UzKNttraWRsUpebTVDQ8VgXTa9Piy66k2+PL9p+uKMADDQt2YlL2zjXWpMrgUk4SqRjAGIbLDgxvH4oIIFuA4h7QG9hJavgVgxfpX8aeJE9ZjOnoTvnxEGhWxuMx9lB1VHpmQCz8pQGwwiWwgDAJuZs+oiq7xrPT8vciTPGiGc0LqJvinSisxXpo/g0tMxHdq7FLxAmXzhK4JVrcUf1d/PPlNxUACx2zzdKRPqoKxbXYKrFMhQBJKsB1++h72faW/Cvy0s1qAOBR2gRWcOuuMhqrXMW3XBPKlG9N+6+UBohZbQt0DOgaNl8+iicOponOG92ARrAY9ucg7UfnWsAGV7keK2SFYtGt0FaimmvhM0ce36zDHjabRimXv/NaebW8GtqBLSDSrqraDkmP0pKMwg3hPaJd2+qNM3Esvd56yyabWTdo0LeFGKJ1/qwup1UNp/V58QMzUddPsVlfj5nausUN0//QnQCU/YrPq8idz06wsaRqeNBZTaJsVe9hEiRnFLGnX3kmjKqQk83PmAVSiqGyEA+mp3fWkTTOT45jLJnLrCml4TidtcVDDWmuEHKpCMUmQdNrg7HHbFDHWem/NMBt9oh5eOACFqYhEnyjSUiTMBaCLH0X+oBTM+sNvoVRa1SsGpUFWk9lj1WYEpQDhz8oDFzFXXEJWD6AHNOud1JPvuqLDk3lDgpiVK7ezy3EOfIDB7A5cJeX4251mzGvLZaBdI5EWoMUHdf/KtVDo7hnLlxjRqTreQSV9hep8cc/AaCMudnoWyyppxKHRVkW7CBhLOmsI2IC/AXHZOpHqIDdlHS8rQiVOyZiXr5KVOpQX7jffC2MqxlohGuTUeEFmDjcxR043fMCmNUZHJCCUK8JGd9KQOom7t0SFg8NheneEYpzWIEYuQVcrIoJ5L4vlGg8wV93L81DeNDvCoBFLs+1XAgGvg2vlBx6iURl6LqwuW2VCQLLlzYQ1kbQSrmRHH1uJXZWT4n3jlZiwEIq50jNKOMtkobawsUTWAcSBMCwOmkN8lVcB8j1E/HkAk2IhWPVnwZ/+dNJwgUNWLlXZ2HMCsioBpOSwblyO20uBmiERSLagKlwq2dIkPzvD2loBGcRrg6tIjPFxkQnDVoohs36Cy8Bg++8mbGSEb8nK51DwMQzqIGCYN6aoLjg4avNWa383fHdH0FK5NFMsTBsvvZNh9zP2BetyuXSRD5O9pGFglE7v6vkNQiqho8aOd8ZrVGxnZFDBomnNaAxitJ/escTdJzAmKNs2UFmFP8wHzLmh7FevUX4J8NF/q5L/3yqFUX/j+e0mngQ7ruDTIq3Q1i4hdvahrLYuKbf/97gb7EQTI2qhg3bHIdR6LWQ4feL0Ecz3s6bZFvXHJFoKEPAVGklJpUUm+PHtLJsqKr49F1ISPNqskBFlQnlSL9Edi4Whi70kgeGs+svDiVKL6hY+Rlwy725zG/rJjqxnTOJlOEp2Y3+53/7V4ZtJdQPtuuPga9LQCAqmm5zmrVUYL4oX2do/QBKZwTTx4JoA+mRM4Zvsjhps/XBY0Fwcft5fysrmqtRUjsfSysEY6jKOdkAC6AypW/geHA+gMxmdLjIq2O0hlKWYbBPDd+a/PNiRWzJvyD0owwZftP3zQMRrIhpoXKGvMXbd1eZpbM4HUDyqDyjL+rJeX05YYjtLmxBto3TdVtpVsbUKuKlczfPET3b8URtRdK3eiwMBxaVivjbvwH+NMumk8faFQel+U7jGeAZIYwTS3c+oGMkrbyJQ7FC6w0SeTRBZt4KDIWqefm+kUh1QXVRS1cDrflIWe2XYgbiN53rkSouv9d7VnHrZOImHIRYJFU9cm62ZD71AzhsVqxn9TdcUdSiMsLorJCCpQ4IV5xS6/on+3HGSidDXPr9pCwIB/JoiR1X9RzX9YCnH/UYo15+l2jb6CARYA45LuCT6Mxrk1T2CWiJgDexW2U185ungYlRFavGTHu9I0vnAw0QesJgU6UIZRljCA32Y64VsgdDbwPIR449p4/F+elpGEhmOyrBidxDbHWvc/d3mDYtqEBHUTzLHRdqEU4XS+ZiTIJNWXzRn8onVg7zI8aIkxpi7qUJyLN2j6UpwfEBo9H+ATauAawOGCBTQsLnxijuEi0lfAYmE/EmIGNrKOpzSM8Xve3y0tyJIt7cs1gHmUGqCwUsdWsD8Z5d/yEq4sHh+nXekmY21ealPWpONHtCpDQF1+UCiABykSPKToNmSQkPHL4UuzBH6hQdOtBX3FNUi5YhpfUyxmnFlVNXBAd/6s2eFTVY7xfw0F1R7hFeZXlpSzbA7KbDRni7pVCM1C1FT+4ctS6hydDuV4/tEaTm2eod3qQLUeoUoeJRAbcqH5dKHJDjOby3/rkpxKwAk02XPR0gTgi2EZKFyd3XH4IhO2ZW5No5SyauW+lLs3Wxrai3V5k+35lN8OW+3O0pyjhRhssL5ntZZokTanC6P2UoBi9MxJsL6OTsS0tXtik1kEq9gp/6lWVghHEmYm2unij1PUYZpu31z58K3nvJlWfx5exvn+bqEobu91Za7ZJcNfofDPD/8FTlGE2jKTwYirKahcKDcUs3fKyhJjFcQ7HFYxPYFV06+IF+XpiJ5RdZf59bbWai+PIRO3yFHNb/mPW2BK8ZLtZyhgoCYnu4bieZFViT31cppy36bf3Zsj6eYAuyOkXe+vJaCFf9IRlvtpB/Ny+Nqs0+Rh7RBT+LooOuRzyBSz7ALtNMcs4E4MHD6Z3PsVoM5uX+vld56OHA+BDpMhKFhCi5pmJZHY9qiBySWDU9dVM8m5EUPvRqutNnH5oxyt9eRb8kEyyoOe4v9fnLcqpcly3u83AgNeFTQgvOlCjaHjY8pwtbninAw73OzGWyJfYTnBgwbvRMqq1z06/FZBHGK1DLACC67F2bBB2Vgo96VHnkdPzXEnhmrf6QQkXMPfj6g9U0Sa+hHpjILmSxsz8nzegFgMZrMQz1r8EEomx/cZB+UCJQM7QOlDh8x0ORwzFURUc7A7K5PqHXoH/dofVm2XqqeFPdBw9EEoPe2aPGO9OluIGTZ9jXvN75YjERXQKLWKgbVB1VLtRDy1V1N2ABzB4ipVGWy3YFokxa2JlFfSsBh9ReDIfiGtivAauovcsKaVARYAXGBot4hcyRqRA8hO+GBFOpz9pwh5LpFjINRmO89pvOYrYDxbokn90fhbwJ3v3WupSzKOcRzHNGhot/2Ev8N/lwNmwEOPfoC3rMWAjtq6NK7ZTi2LX8IMo3BMQiSk68c1GUfu87bcQV7pRx9glGtt7gtteBhg54okjeGTMKLO+KnV2IOnUp5/d82J1LWxi5W2ZQHtGdzS//j5mBRD1zo0yKJc+ok9/fk0dDZtt6x496LhS6QtbDiqv3qm+m2KhCBZJvtnFUo81lRbaUkBntjM//OKG+5TYhxwK8snu3+gTZfgIBpXUNZznhJednjf5sdq8kbIAcoar48z7it6mYhXqRJfHQCPmlY0HRHCXkq4aNftyN1K35p1YTQ36GvX7X8RDexIIwhyl2OMHyG+0D4aEaydgRh4oASHw9PrbBIMmMUH69e90Ro4yiOoZos5IjfuKMK5nEEBP/CkATEHi16iGNT8S9MhPN9H2NkhkaRKoaOIMROgoWLRzwsri/yOIVUJVKPKt93hNYP1N0Qi+PU7K5Cx9nxHDhAkz7YchlFRQ4diFq8r82R5/3a6Sbq3usuXB3DOg/57GCjBjNeytRUsdCB/+m1JSE208XNqy6ZVtk+dLQdvuCbqdRT5sUlGZsPlBCzudDH687Y9ubeI5NRq+4/CTKNMcL/OODYkZUtor89Yf/RCymjuuprAJLiWyzMUjwY8lFMp1fXpsM9gjW7Ycmcax1dHd5Pcu9I7+Llo7enRHxpRopunwL0IDh71EKDzFTj2JNQnfgs2BoPmIIOSPgclE/K1U30j58AGoZ530mWX0TBkDeP75RmMcLKVvPNBqv5ivscXLQIDLgZ0XVKgefnZLzyMlNBHl2VUOoqdI8Gm4SzZ/oAb/bYDLJFA14pN1tJ1OR0lZiDDnzrQFNkpZvDo6B9LeZBbA5XbyzG6uALUrB1aQRLW0DIS71Ml9G0ZcCDP7AYyax7CRNuPIn4QL2qkIYj0UmBZEnSTHauC/2W97E9Nga2PDsYAmTK1GzCM+n5HQ3SFSKxCnxK6zUY/fdk9S5BtzREQoFl/nHKOmyMVxECXEPWxU44Xo6WenJOInkgWEXw4vBZmg/AiM1gYofLM7BboDVMDM6o5Mcf3h+cOXvPej4m8TPJMZM3LzYRYXraXY+jHiMrBlganAcszpeZ7bJ7oD9j1hPGGxcxQb+juI19Dj6340SC+cjJuMDsOST4R/ra4TfMvAA9Ksjc/K+xbvqmPoqD2CKezhAGBstd9w2jY9817I4yXtI7baeqzx6Ghp1lA7sl/eoXa+mS2sgSSG8HR4MR2bhMdKcipv0RQ2rji9v9iyOugTnruxLRnm2AsiUIYcBZPpzQvPiEF2xrCribfg3lYbQoN0dN8Yx6tErRHAjKZyjYdj7MKNyq3p6VDQwS8e8as72i0Rr9nr7SlXx9QjlhiQkj7GUmKg2A7pm+ptQaMCjCiuGsAtetqCJCeRpK/OsLyNty8pIMdMNQ0FaiGO1NbLJLfW6Pd/eFDgStHE9Y9Dfsq4hvd7hd4J5mhE6oCHv/0Hd/4YFVGaKsBc3A2a3mePBgDMIiOdfCB04OgHFksa1oN+EY0IFIPCxYolqCTQnk7dTlqQPQbW7R5Fmlu8t2Pzd8YUaiaQWX3Iu7XCi/e+WwTkQtgSrduE2RJmbdnS74A64UM8gNyWy2Kxt3Q7h0vSs7La/YI3PG74OI7wCnGiqO0T1Y9SbW6V4vgAfaWxaANtehN6K0cjYFVhZJaOchuxO50CFwP9SpEZiXJXvDPInWnyEswVwFBOkLn+75T4FITtepODE3gpIth2cJMJfEhponlu8d7Zi2X92Dimf8s0vZWLvHL9UXyL3vNe1vN7AB6qq3VIn827hbxIq/RmxslEXnQ/4td9/OBz+wyiU7SeYskpAbMzQYPIyxfwPqzupFEolttIUNUgsDXFi1iOmn0k0/Y3pej5Kzf0aHqPz9jEgrD5DOFOg9sFiknKWFkIxPd3AI6OMRyNWikV3/xYDpR9CSbx0h+315+VT7yxnjOACHsxP4x7Hdr/yuLHiNMil/A4sqyfEkELNgp7XRBYCnt2EUG8ziSs2tV2B1SrmGrrHpt7sXhXoOkhzHefukUoCI7KBX2KyNXJce3bMHWg3V5joZfG10fXxsD2OqhqFuoduSovve3CI4uZnT1ASS6S34u+IZnnpTeGSGN0c8bW12BedxOUr+hxQaoh8Ts4xr4a/Eq6EAueGMAes5RwNG+IFheBKtzS/sIh1yrfLFyNTmmDUVvfdB407t31usVXSxZr24Az6Kn7URrZhB2zoZE1w7s1dzzN1xV6CH/4g0Ko/iMovigROrI5hN0ghJceo1Jqbxq3Ym+VR7cXLr1T30adc0+DWZHpJTnrcTYmBJRODrVn6rZzyNU6rdiRlSPDyJMrdaK6uK+ubsUV6n+Xljj2WJ4BTCFWBCkWYHRhaH/cTaH1SCCgFdqZ8UHiQembTrZSvkwZYCSXOi+S71RGzil2uAl+lugsAOrOC1GMUkCycl6JDwmB7cy/w/Z28M2wTkwOV8HCQTo5ZvUEFTKDySMI692ft7SYCcpx2g0H/y+/jDgz4BBj6sGi64i4++90xS1t2d6ZftLnjX1XoKnAtYv8OxDPr+z86vUGzKH+3q82XY2fiXSdahmerPHfBa8y+TXu8Oaqb1nEzPrcMpD+r1HhE5ZQXd302CT+RqMcpmRcbtYdVA/6dQQdKXNwRt10fcHPMAOoqnhohVHNnfIDNHsctbPgyU92Z5qceODPE1o+6A8YlhOF+wQUYlccJNr+nbayWgjo5W/hDxXiaSVTG84Sy4kW81f0+VFPmQpsncaePTIu+KTKiCQGOUESqMfXJi0IUkhlCMpqBCCaJY2EZtPON7xAEKOa5/j0Ua236WfTMmKg0KiFJfdVwOT6tL7affshsuYqd0TcL2Im5hrA5zUgo7whON7VPUFZhBHy4IvVBSF7W2aTxDkxAbYyqOQGniSEUtyZPUrD9TuVxzxyQiHV/LNWob9/U9AsBWSqyRI+HljdXFHefGv0y8zVxmXFg8o8RNB0TS/mJjk9KwbuwOuRHY8QAIKeTYCnvJ8bhT9I0UiN6MqWrh7y016VHMuGCqmZgsuE82uwsbvWbk0iBKtAqXXiT6Vv+4fZqWL4RhiQ9hbZi4THhzcLgwIIlN4qwethrOFlxBJE7rfFoBf+h++6U0kiWZViE8dPF8/udoaXMOCaa6Fe5y63UrEhsd/IhgEC4kldjK49ixXTbJBMzCKwlnDCcjawbdud37HOHsgTSmEqlJy+n6ez6YP92MWDV7Yx7RfL2MC+XgM0to5EefGcCCr108QhIJloYuEzV/heoZcivObkWsgz/cyssYZdB4K17YOe40xLm2BwLeo/bXEDOvNHTj2n4fgDqnFhceHywihHQ+nwZf8/9LEvjYCQUl5ke7Gdqobixe4UzSwobyoODidQTaO2R9YXo9CdBytdZaTp3Zq5JNCkYXE5IRgQV3viKWhO355Iu0yk70pYIHY5jCPtIXN7qVdSex8IHlMgB2DdWRebql7vCMmLAQupi8Cs0SFxD3w+guXepRHbYGq1pptZBSgHT1dodiNUDZLlqwpGA4Pomq/jCbdAWfABp3Bxuu8D7oYgNo70o5NQu4kkg2b20ehU7lWeFMsMglsexeCSa/Jgcprgaj8wOhM57XqHIV8IMP+YgxlNySlw/X3ShEa4FzLEi9oI3BNtX3M7S3xkGpOCXAUJDHQnKenBLpOTcJDWSEKnNNnZqCoc+ZFYqOc6xdSqXmrNmNr1znCxg0LBqZ6hqJniFlgcmPwNaBh2Z9JCkLWCk1jZbFyPekxhlqbAzj5ruqFxPkFQ5I70WKPv/nVM8fWRQNm+pOHHTPK53m0b9b4P+pxJOqqoseOj3hFR99gd0DhWbjvBgXTaCgyeSklA6Omx/jrKv7K97U+5A+guhOsRsFQUxk3evjBu92GHEeuyhIoZJm3UUvqh3cFO1w2/4YvCG7ub1h9tWOQ1i0ym5mrLXfJlzWcB3kcIemaphl8+03dyla+EdI6FSjQ2oWF7gFBlQu4h0ko+UvNAjkpEdD1pTH8+r0jd3wmAT0EkK+aoEEUYt9HLqFwaVAXWzH6WduHo8WS5TJobl/GKc00NWfp6ogI+qKjp144Yt/cwIaXkBLlbcRoLnj6uj7CUVEgv74YgI7uks3GIzuqxdNfiYEq5z9AZWlnBnOgClVkCn4XtRA2MnMRukkpkUKBaz3P0Jpe/3n17XY5pQKqqkS2Oj6r/oqCazBiKik98lIRWUlXOtWiteUhYiVYU5fPio1hJ099rkiXcUW+vlrxF7Nu52wkwT/avu2AdIxEzV67a7ZpcW5CfEOctO3ntlceBhcIge7jB51rNazpGAg8jSxEe0g81x6bn+RPqYjfZovqY2ot18gVKYf+p07V73WVLffWrCvWQ4LQ6mNf5q+Z2TpO18KSG8U+8UY+T5WvXLTxoN60U2Q6A3jzof/D3vc5wljKuMy0e+VannIWr2Ob3LXcvUp45b0wtebuqeeU+hwIkAtjs37LCPTPHjUHAFEHQi7EsgXWspzCJ1L7GJN5iyw+Gtxydh8Q35Q9h0gRjpqGgUV8yniHr1ZwNQIkWWdi2+oahR3AHjRww+GC5Pi8IrCGSRgscXO7xssptg/fJHAsI2xytmZUCpYMmrlUBIK88WZDrR3Yp7M/ecMefd9gOTLdwSo5q2kd/cU2yJUWp+9Lu5VQsB+cUBAJMgyu/IGKP3gvSA9AosTrwcot0dSIEgzfDXoYGFfaO6rms5p64sVBttfB3bBmia6HeRy2wjwYKsPb55Ealg0oAROdHOuBf/Vv0kdsxygeP/B5bivfrXZ31m3HhpgSte3L39uhacb6iRyEj1x0du6X7WvWMWmd92f/3Yj7POWHbkuI8JXKc1z1bXhxjox+v0UVtMlqjAfDcH/DjkE7dt8mNaamRgdBdNs5t3v2EuUHZNTirnT6eabbTH+hw0vna0AqKJH5xCvQ7/mJOcmmZOYHU8oETLyHAhrbkQPi2pygswPgOc9gvQnug9R7L0nUtyqLov1kkvI7+LxAVaF3cHIL0zFXj+1zL/OlktrjVyCvYAE/7p0VfMSP9P1MZ8h3sW6c2FlIiiQgBQl6nojA3zhLdPP53lUxkmWIzuhCQMNnfpbh8gNaWOY58yCfgFeO8rYxaggIIpp+DQUHVjsfoEXOVF575wCXCd4oHRl/CHkUkbOcPdnxqTNEMRg/f7n6atGNz+slmlJj75pQNC+JSAaNuVA62M3KdcETFQ8d3MM7uQu8rEHhQ1KBK/OFyvWwk99YAjNLzRMl0f+jFLoF5EPxqSYbD8XKVJOY98hGpA46KE3xzgJ34QHMkjSDdvZLjltrXmWn3TE6W/7s5Yjpkuc1A3XJhFqOtGOnl5ZIaX9/XSnxCHQNkrk5T9TPbtpF0CC4yv8LK526E1X7kHVMB/Io3v6UKputX6CCGhw7IevXbAk3DphTW6IyIWWf6WBNDcz9JKe76yc19HcMDjNSnEQUm6upiB2sLdRUiZtLRGcRm55QZ/VRYviLahdVc+LbLpNZyks82/VHx1k3n3laERHLdvtCS8vcp+hEqAWBklEMg2sdSm/lpvFBpH25eky43wPCuNu8bp6/9Wje3S2zQ8WRMAPwBxE73csrCk3nKUOrUhRl0P2+84O82Zgk6/ZEGLRdJe3CtbI0+flhd6/Qj0jP9Xagex+MLhlAHDKm5ygyH2WdJlwKEkKeI5H8RpR3rjS6qfM8Qkzb30jW/JNhEoil4M2xeXSguYRuzDpMWu1BFxHbiZQ0c62Cla0+bqZncozyvlNCiiHv+IeX0NZ6HqRKHDF7gqlEgPmoY/sa3ta8Pilt3bMLd3XImsPmUw+xJ18tRlArkiIa7C9iVT8xtP9+A07Kxnjq1KNoMGAESaVhJ05Eu/q/1xFBXW7w8xayiMpsX8E/g5vVmPTfWH5y1hEB38uxD3chvw59PW704QUnY/wIO2hmviJGWHVO/V97lXOymT0/WJaAbhoufOIRYMaNCoZVdOgiI/+F65mMe2IWEE+w+RNWOu8Fbga/wDuWMvriL5giwTyede5mAGZaayB62+lS77V0ZsVMwSfFHHpF+cul1+uQvwkFpYx+1DzT2Hv4Mdoomsk9WfJdX5axTojf1DXKdL3cLPVF7o1xZNgxnth9UjtwkLMYN5kfXCGY8zEW4FlIyln2ONY2Tf0EwSd8FNtp4aVBbdoUckwx4Gp4M+3D1GMnpFQMcE9t/gH+Z4l5fiwOXVk73h3yka2WCNOMNGJzGmBLIlfTp+Q08rPNTfxb9n9fP9CdIgP+173+G7LrVEZQEgqUgkj3tWSkatxuTuqPw39ZsQxhEF0LXXSxDmyTXGUjifrE3s4tg1kZluiErmemTN/Y6t6vAjzg8P661pQ6nBIOJGxyAXqdz7y+25+jGo5BVgTIMqVUN0RWxriR8JpZEFBpg0vkN895c/p4kxkWh8s30resT4YZPaU14Ieu369Dq5m81V4sHCmkiMLspLerzaN+6hyxyByHCWu3es2cmS/0YECyo/qAtb8bCCcbBG9m+dVECosaaxITm38A39hvmW/tiORKOfQ364xBV/sm/eGrjKW9rMM42NQQ110MHE/DskufXtitUf8Ppar0HxXKj7edhFFUBhJqDapLJeCeG+zBKbLZxryX0XX9TLUAwAXX3avuyIzJIZq3MTJY014S5/gzJgN8/w1uNlrjx4F0KAPZbMe5gTa4CkJh9Iv8cNy5kKYlXKFG4hUPeJP8DnYD34i8qUJpcE2tvaVnAQB00BMYY3IxDgQIkmfHUMzch4SJ66OG179JMy4God9/y3CD7Jo3k6G6UqzvGcJUKzUX676cRqk9XIIrUpG/VHTofH4XldTbeo8IqIoY0uQiHRF45KqyaYc7N/VAOZHvdeWSIPAqKqpPo6tK3lhIlSBTLAJd1Bkx28VBi9vJiqBNN5KzxRbl3E1B2NduBmvG9ajFLu0Q2x+XNy1WZspKsTdMtpez+9hW/+X8Da8TSXzrmTUzEk8PU3ZmJR4rim9cH+0eFSKzsFn6M9dqxoKxlQD+1ZVvUq8qRE6Jg2Ddh5A/nSpyYi0q43cSJdldDs/z5An5k0vgjcrctMG5qGCTQMIPKX9B5WdsoW/ULh0Q7C6x4kMO0Fc/EghV94vS5D84I/+CUeZejlhjKj9JRJnOyetFXKqgFAv0qvyCt38l3uBavdr0osF2hrHfoLPsm6yYZN8pr6cBQ7Bcn7/Nizx70qhY18aqJl4q1FhZIGOx27nhRI+x39rBpk8CtwM3yUgOZmzfjF97XDu9voiRZNrS30AgMmTzpWFcffMZ+U3MxP7iCam82VMauSUclemgH3GQu+DwG62MdUtanixKOcUdAZCMzKVnFsQp8U4OLU03n3/eQzZQeuBy+VZnwu9VhyurqIb3Q2ELY0SoKvRXbyT4xwEjynwJTGea7r6AnuWEKKsRa7j0+raPgfgLBKokecxC9cFnNL7/cHX8TtYVDxw6BneiEk9G4khkafLb5rs/8CUns7AcKhKErw+/H7xWmvvi10YbNei12QOke62ZMvhGrZrKtGocir7xmVqucp0pDcfNzsE4hJ//9qo4ur2wg1w91jC343C2B1XZTa+gyfV6H7VXShqurKJshkWylqjY/JFJsUVEMwMlCRHAn4Fh7cEWjy/p80ySxGnv42P8iLDqlwb6eHhwC+WKWVxmSk2986nDKFKzbnpFTjCVQbqHlM9m+8MQSv8rDs7BvsuFXxpPhru+MqXHMh0Td+VakS2HJSXRc7/piJfqnWP67/156vRFCkdoeFugU96SXX3OkMLfF+tGhjtjklktlBN2WFuHXjfW303bE0kdAhZQbmJCnos5YrAMNp1OCO/bcKJPP8E2rx6GouSU/DziTvkMcNUCWNUg82vroigbs/e8anjVmFgtPmAjORDEL66uF9Q8KuZPbzMD5fxbFEozMlG6CLmC15sU0P3hHMC6yEtRd26oS2o6SUpHtBeJcx+oLhls+CxMPaiVlDlt2C7uZIpH/8mD6l+s2c+bFREdwJ8DJBambkMjfbtO1QkwklCTarvj3yu5UoqmZy6QRdtFf/6BRAgUm/Q1JMOajCnmwMswWPXOy399qv9UgtDQYGQI7h2NkwIzfES1yRFn5zzti6SaiCARJHuauaDuuuGbNnqibP1QxTnN+c7zl7WZpy1mihykZpzzviZgHiAeLuki/1DISY++Vx3ha4I/COJxtXZeW3A4G/aGTAYKURPAeaKnPt9wqvXz982wJOSxNSUuPhOBFL9cLNQgHRYY+r8/LhtNCsTx7bqNKKc+GaF4HsCdcgcWl7AwiyL4++m/Zj1jFUcCMnyYXAwTihsOHM0OM5CY72kyyHvNp06GH3Kd4x7OpzQqGjnQkE27f2sw7ghx40C+5NR4HHBc8aEquEn8cvbQaXGYjOB+2iXss9ehA2zf4s7oGJxrMcE48vMeL624pct5EhKujxfJWRoH2kquM4xZx0fCNHsZ7Mczza8kF/WbaFA9lu1XvpJ4GFDTukYvC/UiASWrUDjEX+XcZWStuudcUZnZkjPjQadG+no7jcPLtq6N5QGwRBQ35nAdGH5BXCWiHfx0ea3X7P09tnKKejydEC+ltJsFapWFqKd5NAX5RUwf2unmJQjSk2sXvEYPKAAOFFTqelDDOmr4IQr5VGLHUuTfIgXao18oha6MiSK5lxNAzgbpnht2+07ZrEblZwM4rnPMff4xFHD3IXj0gMDIQGE6V/FRZz5HEcaZiscRG9PEEeX8Ng84oOh5fRllEIkjF5IWOmjDiSEBSwgQHQiuvGHpZcZ62PZ+eFDvcfc6z3no/+cf8rXpa7QjpVA/QVO1oCFeBO3p8Vf4VqfW3pYznCSxP5iT1KyZQbyZiJEKC1l5Ocnw5MWlX6ne5nekrtkwC/zd89kK0+8bRPWZ0UQo6uKaaBPjGwS9lDNpMnkVMBZa8NGUn7jGUZcBhdWAv93+DLPgQv/DzZVuvWKFV5W+bZYMKIufXgnXtMo55MwrGzcJOhqedoH3uFix0LMK2HqWdwfqKuzFTBZXbyeN3NiYb1wp9p+GPTNProT3gBqWJIN5ztI1LboNqnmnZ2z4kxrCdwLnyj8uDHkpTgqYapgZKo6v4tapuiRtp6LMWEgGdk8Pnq8fdsWtC3Ry/ou3EUZ0JdAI/8WHHUfI895Ss3aLPOFRGRwzWe4a5KAfC4+40U9J4G4L142LWKAZXrLZ00sjRJCVtAci8qyVd5yDVv+E3CfemmQ1ddZzvjk7LIrpgPq8IGgxPqwZ7sEPOoKOkYv/3YxioeFBA5RTQWHA+tdKmDALGcB13Y9TOtgcDCc7SS0HmlneIwswxe//ayzJbF5iH38cJmHwD1d6ZlPIGwZ0frzg+cHIAiyqU3rdtUl3QeiTYmWXYZgAoNPv0WgMsDIYOau7bC1HMv940LYIt0XuHR3O9RMKX6lxIwPWNGwLsqrJKgs1tjkGX6asOaammDbcY6fMpUcBJDFVx2eUYHD3mgBfVbcb5BitawBwHAKhrJbmGkmfO1eX8qyMZjD8wrDnH3WLZrBm+dgjZxWBsdLWXxKvvbnsLzJxjgk2XAukI3l9l1xe30vfeFZth3O6hP32I5liXaGGh9Ir7K7k9+5q2QY3MbdDoYNbpixPiFum6QHm05bUhC6GxslBCQ7xRNyqoTdMCeYYEU7wefHmNqfxm//CfPvXTCONbges6uGlWDvs+m08SQr0TpBbtvTfui5+vjlUlwGUlyWMGeji4j+wjz+4Dh7odI1soJURythEOZkJ4tu79Q+N17n/s64/ZpWirdBl1tSPmRLKEC/RG8NESmxqlYLkGRsI+ExV1/ZfUqByuQ1AdvOE9fLxdZ6hl33PfK9/3ZA4upI72UW3RklY0n/lJZXWlCnF6oBKbh/FD7dWlXTHzNLmnKwXjKRMumT4Y7yIUSmWUUjvgTt2YNn27JS8nwE0OXqDy5Y3I6xF9YJ/C2YzV6kblTi5tAEaqVEOQJDlxAky4uv4+FuB0YUatb/x8j9ual7Ma92gBpzFVsh5Ek6ahBbrAopUSyzKbhwDhjXzlGAscgEjItQwOf+ZjXDUpKfa5Pv3Y0ZobGWZiFM8cC1FBk44SnFH6HKVxOPiodrqZeEl/1I2yyFSLptJIBY25derC+GH/1ZQc59hxVKBMKH1DyimiW4qf76uGf0TnbFOlC1cJA6N6MssPV22Bgcf/kpf0i4rXwL1jVCbPJg+5f5O+BKOn8Hv3htQHSuJMXzPvWwsctbTk1RitcqZkdAudKL2pBzo0Cwm1P0eS9t0AdCgRsucU+/e6eZxk4LnWCxBSK9BgnF5lXEgV6BO5yY3oWDe765FrtgN9YHgIBvC/yzqPoAHOp9enCR94Ie+U6VhYEaAdFz7X3dDJuUiXpB38P3svVLjKHsYLklxIalEh63hfgRULy9mG68YbCW0XEhq4rCkxUsHsD8J40LSomvMqk0ZvvOwdNnc2A4xnJStYEJlRz5avtpUbt3FsSk57OfBwdXAK9uYnDxYrkYBq8e+GbDBWr7jCxVQHjiwKyZGiG+dVGFpDkxN7QuQBOQfMaxmR0fsmDV2FvaoTzijZgqznAiP3naVoiUi/qx56S9bfgPT6+HzhXFK9dq7yJGZ+jlaODoZirvUtRGp6Gjcnhj5uJJhOBwnzvq5gHXchaXTv6YMUq4Al8u1x7YZT+QbbXkwLHMZnnBvhohFXO4Y7gbQMvvD4T438vSsF5NvWttLnZBaD/9uScttaUztmnMM5CYIj+u+09glQ1bXKL+pS0/3kmA0GTrrlQjsRtgVms68VFUb1+YkV9ZeECiWSKS+dp8pqwNqRTh6orfhBDlaQ+oYNLz+db+UYHGEGkfwu5sIlHqwJK7B6IEn803GMPckI5nI465OPiOaI0lZbsEMFB+UKPltA3CAcTnywYVXRplhjbOdKDzyJbGwVwI4P7O3wlC7QvZ12xumIfYwyaUJmotZYeziKa+btvZimsJKO/qcfa2b4IB2ArqsnlD4ekpL6LpqFqja/xpvsjKiO1o54MO6w5k80+JRKdxSjissYo8C0kxOu8SZlNzooSVn89T6+Ye5kEzJJHO+elifA9LoeWaEofJDXh+VZTxVZ7mBwSCRQXcjxgGgXK0ORUFt3dltAikmidBV3dqUEKp2121PE+sEmeMAqOhneSMP/l4pxv1jsfdhpqnOkrWxBJI44uC69OF2NEo3MBtMkyhlvuHF/NpUqIS4eCJoKSIqiQ8ve1E7yqEYnn9ntYx7hL1qwxyz934S/fM9Q3gWz4ynLw1yRHG7gc1zos76QF99aPC2Aty4vtZH0wLnjqWGz5vJMKegb7mbvR+Qkun0ehOGy2LEooztmIZaM7yvi9JiZMiGCl2I/zVON7cAXgRVUkDL5JLHeQjyEKME/8OycJ7q0VbyJiRv02JsR5FcU9sauoIysXfCYjWnesEhcQMPcFtfTFUYQp2c9+YbenVzvCAnLh5oIMaDVzuOvHDJ1CEBDaUmWRCvsnFezJLiGmAwhXAkKQU1GDn7++pcWg/KLdINPjE2FcPoNmPE3DlQ1vS+jFvKmA8wHH65sX+M/5ca6n0VbyYlyYPX+fbQ3UERU9T8ut++BICdpQfCwa2ruCzMSUg7aSu3WXUl0iaM99UUpRnlkRzF2KfVq2b2EXty/JLPCy/oXiLhcDMsHI9CFjgEsrvWtKe2NdreEpBVN3uAc8PWSIeiJG53LWsGjL0VKzkK+Q99qkcekH/J0G74IiGWxT80sUjO413Mj/TXS7M3U0HAaiwhzeMdV+ZurByr3LJpgToZgT5u9j3VPpmHWiqKEq7htYLrC6ZSafC2/PQGdIWICEgZmt/XbPMgeuq8P8TWZ1cRNoMHP/kM/qBkIBhY8kOYQKP6jCTtAyzELGfEFJDNCkS5bp4jAvGi8a0hSWtsXzyCLBe6TgAX+tl7Vd0BfDLNf1AvvUjlTmzzYuf8yTRxJi77Q3blE+bGHy4buG1ZCh/tFLL0dUS/33osHpORYPiJApLj6dYemV2MIIu2YOII5ISVgyiibcLwgV94ePOkhVcebsS7xSuzjkD0K7WYWe51PnCxtC/sJhcEDHZwPyjoYqf2GJPn+vUPgFoXMlVUHWFlOTW5+bYqFx0olh7z3uHM1xOjMlsdrcMLGMZnK9AUINZ8wS8mbLZ2n7Nbd2EEkAhtsQIOidKZXuRmYDvKvdYlv8W5syDdUGJR2dMYaX7IfHRsWdF7meP2uOWwa229M+2b4kiaEEF9S4x/oNsr1osa7u+8yWcb/i2WIx5WM1NZiX7du+hIC3VhqupskgqGlSfH4cJFRTG5yJT6w9K3agvtbnhsNjNN9CVq9FwI1mJL78I1Y1XnF0e1tC53nPv/UmDihrSFaLMs9yqE0iebIVG5qkmblngUOUYy/OABqoSdq+CW3Gh2Nn+xF8gsza4+ZuYwWVdpABO/8lynro0NojsNLuRxEwTi+S4KcLgk4eu1Q0gwpjvJE/A52/TornWjgbl+qTSPhz2kKwIdnLcgnR7INDsEeyQX1mPQgB69As=]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>找工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3五行代码实现缩短网址功能]]></title>
    <url>%2F2018%2F07%2F04%2F%E4%BA%94%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0Python%E7%BC%A9%E7%9F%AD%E7%BD%91%E5%9D%80%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[折腾了一晚上，百度和新浪的都试了，都不太好用。感谢国外的大牛。 需求最近一直在更新校招微信机器人，详情看这里叮！你的校招提醒微信机器人已上线！其中爬取的招聘信息链接太长了，本人是个强迫狂魔，这看起来太不美观了，必须缩短！123456789101112131415161718192021222324252627282930313233343536373839404142434445『睿思校园招聘信息，机器喵自动获取，仅供参考』阿里巴巴数据技术及产品部-校园交流﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951547&amp;extra=page%3D1&amp;mobile=2阿里-菜鸟2018年网络测试开发工程师部门直招﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951510&amp;extra=page%3D1&amp;mobile=2（散金币）百度搜索公司SRE团队2019年校招提前批﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951473&amp;extra=page%3D1&amp;mobile=2错投男儿胎，找个家教兼职都这么难（都要求女生）﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951464&amp;extra=page%3D1&amp;mobile=2阿里巴巴菜鸟 测试开发工程师 内推招聘﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951463&amp;extra=page%3D1&amp;mobile=2乐馨托管招聘作业辅导老师一名﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951461&amp;extra=page%3D1&amp;mobile=2[散金币] 西安葡萄城信息技术有限公司2019校园招聘﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951451&amp;extra=page%3D1&amp;mobile=2西安诺瓦科技2019届提前批校招开始啦，与独角兽一起开疆拓土~~~~~﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951338&amp;extra=page%3D1&amp;mobile=2平安租赁招实习生啦﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951331&amp;extra=page%3D1&amp;mobile=2新校区附近寻找初中家教找初中家教﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951299&amp;extra=page%3D1&amp;mobile=2拼多多技术校招内推﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951283&amp;extra=page%3D1&amp;mobile=2百度招实习生﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951276&amp;extra=page%3D1&amp;mobile=2【散金币】西安闻泰电子科技有限公司人力资源2018校园招聘﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951258&amp;extra=page%3D1&amp;mobile=2拼多多2019届 校招开始啦！﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951250&amp;extra=page%3D1&amp;mobile=2乐馨托管招作业辅导老师一名﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951246&amp;extra=page%3D1&amp;mobile=2【找家教】给高一的两个孩子找家教﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951235&amp;extra=page%3D1&amp;mobile=2「商务运营实习」「网联」「央行、阿里、腾讯、京东入股企业」「北京」﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951189&amp;extra=page%3D1&amp;mobile=2老校区附近想找份家教工作，初高中数学理综均可﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951184&amp;extra=page%3D1&amp;mobile=2招女生家教﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951181&amp;extra=page%3D1&amp;mobile=2招募一名会微信小程序的同学开发一个公众号，报酬丰厚﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951140&amp;extra=page%3D1&amp;mobile=2【金币】【招兼职老师】短期老师﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951096&amp;extra=page%3D1&amp;mobile=2【散金币】+家教咯，初三英语、数学、物理、化学﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951023&amp;extra=page%3D1&amp;mobile=2 实现在网上看了一大堆原理和各种API，然而用python3实现的不多，凑巧看到国外大神的，站在巨人肩膀搞定！看代码。先来导入包和使用try，保证鲁棒性。12345678910import contextlibtry: from urllib.parse import urlencodeexcept ImportError: from urllib import urlencodetry: from urllib.request import urlopenexcept ImportError: from urllib2 import urlopenimport sys 剩下的就是五行代码了。12345def make_tiny(url): request_url = ('http://tinyurl.com/api-create.php?' + urlencode(&#123;'url':url&#125;)) with contextlib.closing(urlopen(request_url)) as response: return response.read().decode('utf-8') 测试一下：1print(make_tiny("http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951443")) 输出：1http://tinyurl.com/y7we9xnu 用浏览器打开ok，完美！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[叮！你的校招提醒微信机器人已上线！]]></title>
    <url>%2F2018%2F06%2F13%2F%E6%8B%9B%E8%81%98%E4%BC%9A%E4%BF%A1%E6%81%AF%E6%8F%90%E9%86%92%E4%B9%8B%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[招聘季即将到来，如何实时的得知招聘信息呢？自然是爬虫+微信了。这几日在票圈和各微信群看到大家疯狂刷“京东”、“腾讯”等秋招类的“广告”，我对这些营销方式存怀疑态度，觉得一定不是官方的！总感觉有恶意营销在里面。有需求就有市场，为什么不自己写一个校招提醒机器人呢？简单的想了下，爬虫+微信模式应该是最好的搭配了。 使用方法先说使用方法，再讲原理。 打开微信扫一扫，扫描上方二维码 添加它为好友 接受它发出的群聊邀请(自动邀请功能暂时取消，请告诉它要进哪个群，后面统一拉) 每日更新招聘会信息（现阶段仅支持西电就业信息网招聘会信息） 效果 这是一个西电求职交流群，大家有更好的招聘信息也可以甩到群里。 原理原理主要分为两部分：爬虫+微信机器人。 爬虫讲道理西电就业信息应该挺好爬的吧，网站虽然丑一点，但是内容才是最重要的。就用最简单的请求方式去获取网站内容，居然Forbidden了。那好吧，只能伪装浏览器了。12headers = &#123;'User-Agent' : 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:29.0) Gecko/20100101 Firefox/29.0'&#125; req = urllib.request.Request(url=url,headers=headers) 这样就ok。 完整的抓取网站信息代码：12345678910def getPageContent(url): headers = &#123;'User-Agent' : 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:29.0) Gecko/20100101 Firefox/29.0'&#125; req = urllib.request.Request(url=url,headers=headers) try: res = urllib.request.urlopen(req) except urllib.error.URLError as e: return e page_content = res.read() page_content=BeautifulSoup(page_content,"lxml") return page_content 就业信息网长这样：北校区招聘会信息的table长这样：找到标签那就剥洋葱的爬呗：123456789def getJobInfo(page_content): job_content = page_content.find("table", &#123;"class": "zphTable"&#125;) rows = job_content.findAll("tr")[1:] job_info=[] for row in rows: for cell in row.findAll('td'): info=cell.get_text() job_info.append(info) return job_info 南校区的信息结构和北校区一样，同样试用上面的程序。 对于爬虫的招聘会信息还需做处理，用于后面微信发送。处理的代码：123456789101112def xdjob(jobinfo): urlN = 'http://job.xidian.edu.cn/html/zpxx/bxqzph/' urlS = 'http://job.xidian.edu.cn/html/zpxx/nxqzph/' page_contentN=getPageContent(urlN) page_contentS=getPageContent(urlS) job_infoN=["【北校区招聘会信息】"]+getJobInfo(page_contentN) job_infoS=["【南校区招聘会信息】"]+getJobInfo(page_contentS) job_info = job_infoS+job_infoN jobinfo='『本条由机器喵自动发出，是个机器人大家勿撩哦』'+"\n" for i in job_info: jobinfo=jobinfo+ "\n" +i return jobinfo 至此，爬虫的工作已完成。 微信机器人之前微信好友分析使用过itchat，真的是非常好的一个库。 这次要做的工作简单点，找到指定的群聊名，将爬取的就业信息发送即可。1234567891011def wx(jobinfo2): itchat.auto_login(hotReload = True)# 可设置hotReload = True i=itchat.get_chatrooms(update=True) name = "西电求职交流群" iRoom = itchat.search_chatrooms(name) for room in iRoom: if room['NickName'] == name: userName = room['UserName'] break itchat.send_msg(jobinfo2, userName) 具体的工作流程为： 登录微信 获取所有群聊名称 匹配要发送信息的微信群 发送指定信息 至此爬虫+微信机器人的工作均已完成。可是总不能天天手动去运行程序吧，那我为什么不去看就业信息网站上的信息呢。做程序员呢，最重要的就是一定要懒。设置一个定时器呗，每天运行一次。基本上就能满足需求了。123456def timer(n): itchat.auto_login(hotReload=True) # 可设置hotReload = True while True: jobinfo='' wx(xdjob(jobinfo)) time.sleep(n) 这样就行了，主程序运行timer(86400)，每日更新一波。最后再部署到云服务器就好了。 最后这点信息总感觉太少，还望大家多多提供点靠谱的招聘信息网站，有兴趣的也可以联系我，一起把这个功能丰富起来。方便他人，方便自己。 V1.2同学给的几点建议： 去掉过期的招聘会信息 增加交大、西工大的招聘会信息 增加应届生招聘网站上的信息 我是从西电就业信息网直接爬取，网站上的信息并为做过期处理。这样一想有没有可能从其他招聘网站上抓取第二手信息呢，他们应该做过处理。果不其然，海投网！直接解决了第一第二点的建议。上代码：1234567891011121314151617def xdjob(jobinfo): urlXD = 'https://xjh.haitou.cc/xa/uni-29' urlXJ = 'https://xjh.haitou.cc/xa/uni-27' urlGD = 'https://xjh.haitou.cc/xa/uni-28' urlEnterprise='http://www.yingjiesheng.com/2019/' page_contentN=getPageContent(urlXD) page_contentS=getPageContent(urlXJ) page_contentG = getPageContent(urlGD) job_infoXD=["--------------------"+"\n"+"【西电招聘会信息】"]+getJobInfo(page_contentN) job_infoXJ=["--------------------"+"\n"+"【西交招聘会信息】"]+getJobInfo(page_contentS) job_infoGD = ["--------------------"+"\n"+"【瓜大招聘会信息】"] + getJobInfo(page_contentG) job_info = job_infoXD+job_infoXJ+job_infoGD jobinfo='『今日招聘信息，以下数据为机器喵自动获取，仅供参考。有任何问题请艾特我群主爸爸@肖洒』'+"\n" for i in job_info: jobinfo=jobinfo+ "\n" +i jobinfo=jobinfo + "\n"+"--------------------"+"\n"+"【名企2019校园招聘进度表】" + getEnter(urlEnterprise) return jobinfo 完美！关于第三点，这个应届生的网站真心写的好乱。。不过不能扒的网站呢！上代码：12345678910111213141516def getEnter(urlEnterprise): page_content = getPageContent(urlEnterprise) job_content = page_content.findAll("div", &#123;"class": "s_clear tit floatl"&#125;)[2:] job_info = [] for div in job_content: url = div.a.attrs["href"] if url[:4] == "http": pass else: url = "http://www.yingjiesheng.com" + url info = div.get_text() + "\n"+ url job_info.append(info) jobinfo = "" for i in job_info: jobinfo = jobinfo + "\n" + i return jobinfo 最后现在的效果： V1.3遇到的问题西电这几日没有招聘会信息发布，所以西电部分的爬虫抛出异常。已解决，修改如下：12345678910111213141516171819202122232425262728293031def xdjob(jobinfo): urlXD = 'https://xjh.haitou.cc/xa/uni-29' urlXJ = 'https://xjh.haitou.cc/xa/uni-27' urlGD = 'https://xjh.haitou.cc/xa/uni-28' urlEnterprise='http://www.yingjiesheng.com/2019/' try: page_contentN=getPageContent(urlXD) job_infoXD=["--------------------"+"\n"+"【西电招聘会信息】"]+getJobInfo(page_contentN) except: job_infoXD=["--------------------"+"\n"+"【西电今日无招聘会信息哦】"] try: page_contentS=getPageContent(urlXJ) job_infoXJ=["--------------------"+"\n"+"【西交招聘会信息】"]+getJobInfo(page_contentS) except: job_infoXJ=["--------------------"+"\n"+"【西交今日无招聘会信息哦】"] try: page_contentG = getPageContent(urlGD) job_infoGD = ["--------------------"+"\n"+"【瓜大招聘会信息】"] + getJobInfo(page_contentG) except: job_infoXJ=["--------------------"+"\n"+"【瓜大今日无招聘会信息哦】"] job_info = job_infoXD+job_infoXJ+job_infoGD jobinfo='『今日招聘信息，以下数据为机器喵自动获取，仅供参考。有任何问题请艾特我群主爸爸@肖洒』'+"\n" for i in job_info: jobinfo=jobinfo+ "\n" +i # jobinfo=jobinfo + "\n"+"--------------------"+"\n"+"【名企2019校园招聘进度表】" + getEnter(urlEnterprise) return jobinfo V1.4遇到的问题由于itchat的问题，网页版微信并不能一直保持在线，导致定时发送服务总是因为掉线而抛出异常。解决办法：itchat在移动端微信保持稳定登录的情况下，30分钟内是可以保证在线的。所以想到每30分钟发一次信息，保持登录的状态，每24小时给求职群里发一次招聘会信息。具体实现方法：1234567891011n=0while True: itchat.auto_login(hotReload=True) # 可设置hotReload = True wx('TEST','别玩手机哦') timer(1800) n=n+1 print("循环到第："+str(n)+"次，还剩"+str(48-n)+"次即可触发爬虫") while n == 48 : jobinfo="" wx('西电求职交流群',xdjob(jobinfo)) n=0 V2.0增加睿思的招聘信息这几天已经用获得的招聘信息疯狂投递简历了。为了丰富招聘信息，根据之前的经验和代码，整合了下，抓取睿思校园招聘板块的信息，进行处理后进行微信发送。睿思板块抓取的程序：1234567891011121314151617181920212223242526272829303132333435def rs(): pageURL = set() job_rs = '『睿思校园招聘信息，机器喵自动获取，仅供参考』' for i in range(1, 2): pages = 'http://rsbbs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=554&amp;page=' + str(i) + '&amp;mobile=2' if pages not in pageURL: headers = &#123; 'User-Agent': r'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) ' r'Chrome/45.0.2454.85 Safari/537.36 115Browser/6.0.3', 'Referer': r'http://rsbbs.xidian.edu.cn', 'Connection': 'keep-alive'&#125; req = request.Request(pages, headers=headers) html = request.urlopen(req) bsObj = BeautifulSoup(html.read(), "lxml") tiezi = bsObj.findAll("ul") for tiaos in tiezi: for tiao in tiaos.findAll('a'): for person in tiao.findAll('span', attrs=&#123;'class': "by"&#125;): T = person.get_text().strip() [s.extract() for s in tiao.findAll('span', attrs=&#123;'class': "by"&#125;)] P = tiao.get_text().strip() + "﹝详细信息﹞:" job_rs = job_rs + "\n" + str(P) if 'href' in tiao.attrs: try: tiao_links = "http://rsbbs.xidian.edu.cn/" + tiao.attrs['href'] tiao_html = urlopen(tiao_links) job_rs = job_rs + "\n" + str(tiao_links) tiao_bsObj = BeautifulSoup(tiao_html.read(), "lxml") content = tiao_bsObj.findAll("div", &#123;"class": "message"&#125;)[0] R = content.get_text().strip() except (ValueError, IndexError) as e: pass pageURL.add(pages) time.sleep(3) # 设置时间间隔为3秒 return job_rs 得到的信息如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445『睿思校园招聘信息，机器喵自动获取，仅供参考』阿里巴巴数据技术及产品部-校园交流﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951547&amp;extra=page%3D1&amp;mobile=2阿里-菜鸟2018年网络测试开发工程师部门直招﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951510&amp;extra=page%3D1&amp;mobile=2（散金币）百度搜索公司SRE团队2019年校招提前批﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951473&amp;extra=page%3D1&amp;mobile=2错投男儿胎，找个家教兼职都这么难（都要求女生）﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951464&amp;extra=page%3D1&amp;mobile=2阿里巴巴菜鸟 测试开发工程师 内推招聘﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951463&amp;extra=page%3D1&amp;mobile=2乐馨托管招聘作业辅导老师一名﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951461&amp;extra=page%3D1&amp;mobile=2[散金币] 西安葡萄城信息技术有限公司2019校园招聘﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951451&amp;extra=page%3D1&amp;mobile=2西安诺瓦科技2019届提前批校招开始啦，与独角兽一起开疆拓土~~~~~﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951338&amp;extra=page%3D1&amp;mobile=2平安租赁招实习生啦﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951331&amp;extra=page%3D1&amp;mobile=2新校区附近寻找初中家教找初中家教﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951299&amp;extra=page%3D1&amp;mobile=2拼多多技术校招内推﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951283&amp;extra=page%3D1&amp;mobile=2百度招实习生﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951276&amp;extra=page%3D1&amp;mobile=2【散金币】西安闻泰电子科技有限公司人力资源2018校园招聘﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951258&amp;extra=page%3D1&amp;mobile=2拼多多2019届 校招开始啦！﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951250&amp;extra=page%3D1&amp;mobile=2乐馨托管招作业辅导老师一名﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951246&amp;extra=page%3D1&amp;mobile=2【找家教】给高一的两个孩子找家教﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951235&amp;extra=page%3D1&amp;mobile=2「商务运营实习」「网联」「央行、阿里、腾讯、京东入股企业」「北京」﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951189&amp;extra=page%3D1&amp;mobile=2老校区附近想找份家教工作，初高中数学理综均可﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951184&amp;extra=page%3D1&amp;mobile=2招女生家教﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951181&amp;extra=page%3D1&amp;mobile=2招募一名会微信小程序的同学开发一个公众号，报酬丰厚﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951140&amp;extra=page%3D1&amp;mobile=2【金币】【招兼职老师】短期老师﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951096&amp;extra=page%3D1&amp;mobile=2【散金币】+家教咯，初三英语、数学、物理、化学﹝详细信息﹞:http://rsbbs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=951023&amp;extra=page%3D1&amp;mobile=2 遇到的问题之前循环时间，然后触发程序有些鸡肋。进行了新的改动。123456789101112131415161718while True: # itchat.auto_login(hotReload=True) # 可设置hotReload = True jobinfo = "" time_now = time.strftime('%H%M',time.localtime(time.time())) if int(time_now) == 1000: wx('西电招聘信息发布群1', xdjob(jobinfo)) time.sleep(30) wx('西电招聘信息发布群1', rs()) time.sleep(30) wx('西电招聘信息发布群2', xdjob(jobinfo)) time.sleep(30) wx('西电招聘信息发布群2', rs()) time.sleep(30) elif int(time_now) % 10 == 0: wx('TEST', time_now) time.sleep(60) else: timer(60) 采用检测本地时间来进行触发。Itchat有个问题不好处理，会时长掉线，查过很多资料好像并不能很好的解决这个问题。所以，为了保证网页版微信的登录状态，每隔十分钟会给一个TEST群里发送信息。这个方法可以保证一段时间的登录状态。但是还是会一段时间后LOG OUT。现在的原因还未能知晓，此bug需要后面解决。 V2.1是什么驱动要一直去写代码，有一大部分是强迫症！！！上面招聘信息的链接也太长了吧，在微信里看起来好烦。所以，缩短的网址，看这里。Python3五行代码实现缩短网址功能实现的效果：123456789101112131415161718192021222324252627282930313233343536373839404142434445『睿思校园招聘信息，机器喵自动获取，仅供参考』客服﹝详细信息﹞:http://tinyurl.com/y77mdy7q阿里巴巴数据技术及产品部-校园交流﹝详细信息﹞:http://tinyurl.com/y7vmoaqr阿里-菜鸟2018年网络测试开发工程师部门直招﹝详细信息﹞:http://tinyurl.com/yc9xe4eu（散金币）百度搜索公司SRE团队2019年校招提前批﹝详细信息﹞:http://tinyurl.com/y753gupt错投男儿胎，找个家教兼职都这么难（都要求女生）﹝详细信息﹞:http://tinyurl.com/y7fdybjh阿里巴巴菜鸟 测试开发工程师 内推招聘﹝详细信息﹞:http://tinyurl.com/ybwj6dq8乐馨托管招聘作业辅导老师一名﹝详细信息﹞:http://tinyurl.com/y73cuhfv[散金币] 西安葡萄城信息技术有限公司2019校园招聘﹝详细信息﹞:http://tinyurl.com/y8w43yap西安诺瓦科技2019届提前批校招开始啦，与独角兽一起开疆拓土~~~~~﹝详细信息﹞:http://tinyurl.com/y85atskf平安租赁招实习生啦﹝详细信息﹞:http://tinyurl.com/y77fak6z新校区附近寻找初中家教找初中家教﹝详细信息﹞:http://tinyurl.com/ya9lxcvw拼多多技术校招内推﹝详细信息﹞:http://tinyurl.com/ya2plpp7百度招实习生﹝详细信息﹞:http://tinyurl.com/y9bpe4z2【散金币】西安闻泰电子科技有限公司人力资源2018校园招聘﹝详细信息﹞:http://tinyurl.com/ybgurcyz拼多多2019届 校招开始啦！﹝详细信息﹞:http://tinyurl.com/y94ypr6b乐馨托管招作业辅导老师一名﹝详细信息﹞:http://tinyurl.com/yc67fjvp【找家教】给高一的两个孩子找家教﹝详细信息﹞:http://tinyurl.com/yc9lldzl「商务运营实习」「网联」「央行、阿里、腾讯、京东入股企业」「北京」﹝详细信息﹞:http://tinyurl.com/ycvh4qdc老校区附近想找份家教工作，初高中数学理综均可﹝详细信息﹞:http://tinyurl.com/y9tbfxkv招女生家教﹝详细信息﹞:http://tinyurl.com/y7u63n68招募一名会微信小程序的同学开发一个公众号，报酬丰厚﹝详细信息﹞:http://tinyurl.com/y9c6zwkz【金币】【招兼职老师】短期老师﹝详细信息﹞:http://tinyurl.com/ybo7araq]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python100Days]]></title>
    <url>%2F2018%2F06%2F05%2FPython100Days%2F</url>
    <content type="text"><![CDATA[这可能是我目前发现最好最好的Python教程了，故整理至我的博客。原项目GitHub地址https://github.com/jackfrued/Python-100-Days 初识PythonPython简介Python的历史 1989年圣诞节：Guido von Rossum开始写Python语言的编译器。 1991年2月：第一个Python编译器（同时也是解释器）诞生，它是用C语言实现的（后面又出现了Java和C#实现的版本Jython和IronPython，以及PyPy、Brython、Pyston等其他实现），可以调用C语言的库函数。在最早的版本中，Python已经提供了对“类”，“函数”，“异常处理”等构造块的支持，同时提供了“列表”和“字典”等核心数据类型，同时支持以模块为基础的拓展系统。 1994年1月：Python 1.0正式发布。 2000年10月16日：Python 2.0发布，增加了实现完整的垃圾回收，并且支持Unicode。与此同时，Python的整个开发过程更加透明，社区对开发进度的影响逐渐扩大，生态圈开始慢慢形成。 2008年12月3日：Python 3.0发布，此版不完全兼容之前的Python代码，不过很多新特性后来也被移植到旧的Python 2.6/2.7版本，因为目前还有公司在项目和运维中使用Python 2.x版本的代码。 目前我们使用的Python 3.6.x的版本是在2016年的12月23日发布的，Python的版本号分为三段，形如A.B.C。其中A表示大版本号，一般当整体重写，或出现不向后兼容的改变时，增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（如修复了某个Bug），只要有修改就增加C。如果对Python的历史感兴趣，可以查看一篇名为《Python简史》的博文。 Python的优缺点Python的优点很多，简单的可以总结为以下几点。 简单和明确，做一件事只有一种方法。 学习曲线低，与其他很多语言比上手更容易。 开放源代码，拥有强大的社区和生态圈。 解释型语言，完美的平台可移植性。 支持两种主流的编程范式，可以使用面向对象和函数式编程。 可扩展性和可嵌入性，可以调用C/C++代码也可以在C/C++中调用。 代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。 Python的缺点主要集中在以下几点。 执行效率低下，因此计算密集型任务可以由C/C++编写。 代码无法加密，但是现在的公司很多都不是卖软件而是卖服务，这个问题慢慢会淡化。 在开发时可以选择的框架太多，有选择的地方就有错误。 Python的应用领域目前Python在云基础设施、DevOps、网络爬虫开发、数据分析挖掘、机器学习等领域都有着广泛的应用，因此也产生了服务器开发、数据接口开发、自动化运维、科学计算和数据可视化、聊天机器人开发、图像识别和处理等一系列的职位。 搭建编程环境Windows环境可以在Python的官方网站下载到Python的Windows安装程序（exe文件），需要注意的是如果在Windows 7环境下安装需要先安装Service Pack 1补丁包（可以通过一些工具软件自动安装系统补丁的功能来安装），安装过程建议勾选“Add Python 3.6 to PATH”（将Python 3.6添加到PATH环境变量）并选择自定义安装，在设置“Optional Features”界面最好将“pip”、“tcl/tk”、“Python test suite”等项全部勾选上。强烈建议使用自定义的安装路径并保证路径中没有中文。安装完成会看到“Setup was successful”的提示，但是在启动Python环境时可能会因为缺失一些动态链接库文件而导致Python解释器无法运行，常见的问题主要是api-ms-win-crt*.dll缺失以及更新DirectX之后导致某些动态链接库文件缺失，前者可以参照《api-ms-win-crt*.dll缺失原因分析和解决方法》一文讲解的方法进行处理或者直接在微软官网下载Visual C++ Redistributable for Visual Studio 2015文件进行修复，后者可以下载一个DirectX修复工具进行修复。 Linux环境Linux环境自带了Python 2.x版本，但是如果要更新到3.x的版本，可以在Python的官方网站下载Python的源代码并通过源代码构建安装的方式进行安装，具体的步骤如下所示。 安装依赖库（因为没有这些依赖库可能在源代码构件安装时因为缺失底层依赖库而失败）。 1yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 下载Python源代码并解压缩到指定目录。 123wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tar.xzxz -d Python-3.6.1.tar.xztar -xvf Python-3.6.1.tar 切换至Python源代码目录并执行下面的命令进行配置和安装。 123cd Python-3.6.1./configure --prefix=/usr/local/python3.6 --enable-optimizationsmake &amp;&amp; make install 创建软链接，这样就可以直接通过python3直接启动Python解释器。 1ln -s /usr/local/python3.6/bin/python3 /usr/bin/python3 MacOS环境MacOS也是自带了Python 2.x版本的，可以通过Python的官方网站提供的安装文件（pkg文件）安装3.x的版本。默认安装完成后，可以通过在终端执行python命令来启动2.x版本的Python解释器，可以通过执行python3命令来启动3.x版本的Python解释器，当然也可以通过重新设置软链接来修改启动Python解释器的命令。 从终端运行Python程序确认Python的版本在终端或命令行提示符中键入下面的命令。 1python --version 当然也可以先输入python进入交互式环境，再执行以下的代码检查Python的版本。 1234import sysprint(sys.version_info)print(sys.version) 编写Python源代码可以用文本编辑工具（推荐使用Sublime、Atom、TextMate、VSCode等高级文本编辑工具）编写Python源代码并将其命名为hello.py保存起来，代码内容如下所示。 1print('hello, world!') 运行程序切换到源代码所在的目录并执行下面的命令，看看屏幕上是否输出了”hello, world!”。 1python hello.py 代码中的注释注释是编程语言的一个重要组成部分，用于在源代码中解释代码的作用从而增强程序的可读性和可维护性，当然也可以将源代码中不需要参与运行的代码段通过注释来去掉，这一点在调试程序的时候经常用到。注释在随源代码进入预处理器或编译时会被移除，不会在目标代码中保留也不会影响程序的执行结果。 单行注释 - 以#和空格开头的部分 多行注释 - 三个引号开头，三个引号结尾 12345678910111213141516"""第一个Python程序 - hello, world!向伟大的Dennis M. Ritchie先生致敬Version: 0.1Author: 骆昊Date: 2018-02-26"""print('hello, world!')# print("你好,世界！")print('你好', '世界')print('hello', 'world', sep=', ', end='!')print('goodbye, world', end='!\n') 其他工具介绍IDLE - 自带的集成开发工具IDLE是安装Python环境时自带的集成开发工具，但是由于IDLE的用户体验并不是那么好所以很少在实际开发中被采用。 IPython - 更好的交互式编程工具IPython是一种基于Python的交互式解释器。相较于原生的Python Shell，IPython提供了更为强大的编辑和交互功能。可以通过Python的包管理工具pip安装IPython和Jupyter，具体的操作如下所示。 1pip install ipython jupyter 或者 1python -m pip install ipython jupyter 安装成功后，可以通过下面的ipython命令启动IPython。 当然我们也可以通过Jupyter运行名为notebook的项目在浏览器窗口中进行交互式操作。 1jupyter notebook Sublime - 文本编辑神器 首先可以通过官方网站下载安装程序安装Sublime 3或Sublime 2。 安装包管理工具。通过快捷键Ctrl+`或者在View菜单中选择Show Console打开控制台，输入下面的代码。 Sublime 3 1import urllib.request,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()) Sublime 2 1import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp)ifnotos.path.exists(ipp)elseNone;urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read());print('Please restart Sublime Text to finish installation') 安装插件。通过Preference菜单的Package Control或快捷键Ctrl+Shift+P打开命令面板，在面板中输入Install Package就可以找到安装插件的工具，然后再查找需要的插件。我们推荐大家安装以下几个插件。 SublimeCodeIntel - 代码自动补全工具插件 Emmet - 前端开发代码模板插件 Git - 版本控制工具插件 Python PEP8 Autoformat - PEP8规范自动格式化插件 ConvertToUTF8 - 将本地编码转换为UTF-8 PyCharm - Python开发神器PyCharm的安装、配置和使用我们在后面会进行介绍。 练习 在Python交互环境中下面的代码查看结果并将内容翻译成中文。 123456789101112131415161718192021import thisBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those! 学习使用turtle在屏幕上绘制图形。 123456789101112import turtleturtle.pensize(4)turtle.pencolor('red')turtle.forward(100)turtle.right(90)turtle.forward(100)turtle.right(90)turtle.forward(100)turtle.right(90)turtle.forward(100)turtle.mainloop() 语言元素指令和程序计算机的硬件系统通常由五大部件构成，包括：运算器、控制器、存储器、输入设备和输出设备。其中，运算器和控制器放在一起就是我们通常所说的中央处理器，它的功能是执行各种运算和控制指令以及处理计算机软件中的数据。我们通常所说的程序实际上就是指令的集合，我们程序就是将一系列的指令按照某种方式组织到一起，然后通过这些指令去控制计算机做我们想让它做的事情。今天我们使用的计算机虽然器件做工越来越精密，处理能力越来越强大，但究其本质来说仍然属于“冯·诺依曼结构”的计算机。“冯·诺依曼结构”有两个关键点，一是提出了将存储设备与中央处理器分开，二是提出了将数据以二进制方式编码。二进制是一种“逢二进一”的计数法，跟我们人类使用的“逢十进一”的计数法没有实质性的区别，人类因为有十根手指所以使用了十进制（因为在数数时十根手指用完之后就只能进位了，当然凡事都有例外，玛雅人可能是因为长年光着脚的原因把脚趾头也算上了，于是他们使用了二十进制的计数法，在这种计数法的指导下玛雅人的历法就与我们的不太一致，而按照玛雅人的历法，2012年是上一个所谓的“太阳纪”的最后一年，而2013年则是新的“太阳纪”的开始，后来这件事情被以讹传讹的方式误传为2012年就是玛雅人预言的世界末日这种荒诞的说法，今天我们可以大胆的猜测，玛雅文明之所以发展缓慢估计也与使用了二十进制有关），对于计算机来说，二进制在物理器件上来说是最容易实现的（高电压表示1，低电压表示0），于是在“冯·诺依曼结构”的计算机都使用了二进制。虽然我们并不需要每个程序员都能够使用二进制的思维方式来工作，但是了解二进制以及它与我们生活中的十进制之间的转换关系，以及二进制与八进制和十六进制的转换关系还是有必要的。如果你对这一点不熟悉，可以自行使用维基百科或者度娘科普一下。 变量和类型在程序设计中，变量是一种存储数据的载体。计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多中类型，除了数值之外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python中的数据类型很多，而且也允许我们自定义新的数据类型（这一点在后面会讲到），我们先介绍几种常用的数据类型。 整型：Python中可以处理任意大小的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。 浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 字符串型：字符串是以单引号或双引号括起来的任意文本，比如&#39;hello&#39;和&quot;hello&quot;,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。 布尔型：布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 &lt; 5会产生布尔值True，而2 == 1会产生布尔值False）。 复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。 变量命名对于每个变量我们需要给它取一个名字，就如同我们每个人都有属于自己的响亮的名字一样。在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。 硬性规则： 变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。 大小写敏感（大写的a和小写的A是两个不同的变量）。 不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。 PEP 8要求： 用小写字母拼写，多个单词用下划线连接。 受保护的实例属性用单个下划线开头（后面会讲到）。 私有的实例属性用两个下划线开头（后面会讲到）。 当然，作为一个专业的程序员，给变量（事实上应该是所有的标识符）命名做到见名知意也是非常重要的。 变量的使用下面通过几个例子来说明变量的类型和变量使用。 12345678910111213141516171819"""使用变量保存数据并进行算术运算Version: 0.1Author: 骆昊Date: 2018-02-27"""a = 321b = 123print(a + b)print(a - b)print(a * b)print(a / b)print(a // b)print(a % b)print(a ** b) 123456789101112131415161718192021"""使用input函数输入使用int()进行类型转换用占位符格式化输出的字符串Version: 0.1Author: 骆昊Date: 2018-02-27"""a = int(input('a = '))b = int(input('b = '))print('%d + %d = %d' % (a, b, a + b))print('%d - %d = %d' % (a, b, a - b))print('%d * %d = %d' % (a, b, a * b))print('%d / %d = %f' % (a, b, a / b))print('%d // %d = %d' % (a, b, a // b))print('%d %% %d = %d' % (a, b, a % b))print('%d ** %d = %d' % (a, b, a ** b)) 1234567891011121314151617181920"""使用type()检查变量的类型Version: 0.1Author: 骆昊Date: 2018-02-27"""a = 100b = 12.345c = 1 + 5jd = 'hello, world'e = Trueprint(type(a))print(type(b))print(type(c))print(type(d))print(type(e)) 在对变量类型进行转换时可以使用Python的内置函数（准确的说下面列出的并不是真正意义上的函数，而是后面我们要讲到的创建对象的构造方法）。 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 运算符Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，我们会陆续使用到它们。 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &amp; 按位与 ^ ` ` 按位异或，按位或 &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &amp;= ` =`^= &gt;&gt;= &lt;&lt;= （复合）赋值运算符 说明：在实际开发中，如果搞不清楚优先级可以使用括号来确保运算的执行顺序。 下面的例子演示了运算符的使用。 123456789101112131415161718192021222324252627282930313233"""运算符的使用Version: 0.1Author: 骆昊Date: 2018-02-27"""a = 5b = 10c = 3d = 4e = 5a += ba -= ca *= da /= eprint("a = ", a)flag1 = 3 &gt; 2flag2 = 2 &lt; 1flag3 = flag1 and flag2flag4 = flag1 or flag2flag5 = not flag1print("flag1 = ", flag1)print("flag2 = ", flag2)print("flag3 = ", flag3)print("flag4 = ", flag4)print("flag5 = ", flag5)print(flag1 is True)print(flag2 is not False) 练习练习1：华氏温度转摄氏温度。1234567891011121314"""将华氏温度转换为摄氏温度F = 1.8C + 32Version: 0.1Author: 骆昊Date: 2018-02-27"""f = float(input('请输入华氏温度: '))c = (f - 32) / 1.8print('%.1f华氏度 = %.1f摄氏度' % (f, c)) 练习2：输入圆的半径计算计算周长和面积。1234567891011121314151617"""输入半径计算圆的周长和面积Version: 0.1Author: 骆昊Date: 2018-02-27"""import mathradius = float(input('请输入圆的半径: '))perimeter = 2 * math.pi * radiusarea = math.pi * radius * radiusprint('周长: %.2f' % perimeter)print('面积: %.2f' % area) 练习3：输入年份判断是不是闰年。123456789101112131415"""输入年份 如果是闰年输出True 否则输出FalseVersion: 0.1Author: 骆昊Date: 2018-02-27"""year = int(input('请输入年份: '))# 如果代码太长写成一行不便于阅读 可以使用\或()折行is_leap = (year % 4 == 0 and year % 100 != 0 or year % 400 == 0)print(is_leap) 分支结构分支结构的应用场景迄今为止，我们写的Python代码都是一条一条语句顺序执行，这种结构的代码我们称之为顺序结构。然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的通关条件是玩家获得1000分，那么在完成本局游戏后我们要根据玩家得到分数来决定究竟是进入第二关还是告诉玩家“Game Over”，这里就会产生两个分支，而且这两个分支只有一个会被执行，这就是程序中分支结构。类似的场景还有很多，给大家一分钟的时间，你应该可以想到至少5个以上这样的例子，赶紧试一试。 if语句的使用在Python中，要构造分支结构可以使用if、elif和else关键字。所谓关键字就是有特殊含义的单词，像if和else就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名（事实上，用作其他的标识符也是不可以）。下面的例子中演示了如何构造一个分支结构。 12345678910111213141516171819"""用户身份验证Version: 0.1Author: 骆昊Date: 2018-02-28"""username = input('请输入用户名: ')password = input('请输入口令: ')# 如果希望输入口令时 终端中没有回显 可以使用getpass模块的getpass函数# import getpass# password = getpass.getpass('请输入口令: ')if username == 'admin' and password == '123456': print('身份验证成功!')else: print('身份验证失败!') 唯一需要说明的是和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于是一个执行的整体。 当然如果要构造出更多的分支，可以使用if…elif…else…结构，例如下面的分段函数求值。 $$f(x)=\begin{cases} 3x-5&amp;\text{(x&gt;1)}\x+2&amp;\text{(-1}\leq\text{x}\leq\text{1)}\5x+3&amp;\text {(x&lt;-1)}\end{cases}$$ 12345678910111213141516171819202122"""分段函数求值 3x - 5 (x &gt; 1)f(x) = x + 2 (-1 &lt;= x &lt;= 1) 5x + 3 (x &lt; -1)Version: 0.1Author: 骆昊Date: 2018-02-28"""x = float(input('x = '))if x &gt; 1: y = 3 * x - 5elif x &gt;= -1: y = x + 2else: y = 5 * x + 3print('f(%.2f) = %.2f' % (x, y)) 当然根据实际开发的需要，分支结构是可以嵌套的，例如判断是否通关以后还要根据你获得的宝物或者道具的数量对你的表现给出等级（比如点亮两颗或三颗星星），那么我们就需要在if的内部构造出一个新的分支结构，同理elif和else中也可以再构造新的分支，我们称之为嵌套的分支结构，也就是说上面的代码也可以写成下面的样子。 12345678910111213141516171819202122"""分段函数求值 3x - 5 (x &gt; 1)f(x) = x + 2 (-1 &lt;= x &lt;= 1) 5x + 3 (x &lt; -1)Version: 0.1Author: 骆昊Date: 2018-02-28"""x = float(input('x = '))if x &gt; 1: y = 3 * x - 5else: if x &gt;= -1: y = x + 2 else: y = 5 * x + 3print('f(%.2f) = %.2f' % (x, y)) 说明：大家可以自己感受一下这两种写法到底是哪一种更好。在之前我们提到的Python之禅中有这么一句话“Flat is bettern than nested.”，之所以提出这个观点是因为嵌套结构的嵌套层次多了之后会严重的影响代码的可读性，如果可以使用扁平化的结构就不要去用嵌套，因此之前的写法是更好的做法。 练习练习1：英制单位与公制单位互换123456789101112131415161718"""英制单位英寸和公制单位厘米互换Version: 0.1Author: 骆昊Date: 2018-02-28"""value = float(input('请输入长度: '))unit = input('请输入单位: ')if unit == 'in' or unit == '英寸': print('%f英寸 = %f厘米' % (value, value * 2.54))elif unit == 'cm' or unit == '厘米': print('%f厘米 = %f英寸' % (value, value / 2.54))else: print('请输入有效的单位') 练习2：掷骰子决定做什么1234567891011121314151617181920212223242526"""掷骰子决定做什么事情Version: 0.1Author: 骆昊Date: 2018-02-28"""from random import randintface = randint(1, 6)if face == 1: result = '唱首歌'elif face == 2: result = '跳个舞'elif face == 3: result = '学狗叫'elif face == 4: result = '做俯卧撑'elif face == 5: result = '念绕口令'else: result = '讲冷笑话'print(result) 说明：上面的代码中使用了random模块的randint函数生成指定范围的随机数来模拟掷骰子。 练习3：百分制成绩转等级制123456789101112131415161718192021222324252627"""百分制成绩转等级制成绩90分以上 --&gt; A80分~89分 --&gt; B70分~79分 --&gt; C60分~69分 --&gt; D60分以下 --&gt; EVersion: 0.1Author: 骆昊Date: 2018-02-28"""score = float(input('请输入成绩: '))if score &gt;= 90: grade = 'A'elif score &gt;= 80: grade = 'B'elif score &gt;= 70: grade = 'C'elif score &gt;= 60: grade = 'D'else: grade = 'E'print('对应的等级是:', grade) 练习4：输入三条边长如果能构成三角形就计算周长和面积1234567891011121314151617181920212223"""判断输入的边长能否构成三角形如果能则计算出三角形的周长和面积Version: 0.1Author: 骆昊Date: 2018-02-28"""import matha = float(input('a = '))b = float(input('b = '))c = float(input('c = '))if a + b &gt; c and a + c &gt; b and b + c &gt; a: print('周长: %f' % (a + b + c)) p = (a + b + c) / 2 area = math.sqrt(p * (p - a) * (p - b) * (p - c)) print('面积: %f' % (area))else: print('不能构成三角形') 说明：上面的代码中使用了math模块的sqrt函数来计算平方根。用边长计算三角形面积的公式叫做海伦公式。 练习5：实现一个个人所得税计算器。12345678910111213141516171819202122232425262728293031323334353637383940"""输入月收入和五险一金计算个人所得税Version: 0.1Author: 骆昊Date: 2018-02-28"""salary = float(input('本月收入: '))insurance = float(input('五险一金: '))diff = salary - insurance - 3500if diff &lt;= 0: rate = 0 deduction = 0elif diff &lt; 1500: rate = 0.03 deduction = 0elif diff &lt; 4500: rate = 0.1 deduction = 105elif diff &lt; 9000: rate = 0.2 deduction = 555elif diff &lt; 35000: rate = 0.25 deduction = 1005elif diff &lt; 55000: rate = 0.3 deduction = 2755elif diff &lt; 80000: rate = 0.35 deduction = 5505else: rate = 0.45 deduction = 13505tax = abs(diff * rate - deduction)print('个人所得税: ￥%.2f元' % tax)print('实际到手收入: ￥%.2f元' % (diff + 3500 - tax)) 说明：上面的代码中使用了Python内置的abs()函数取绝对值来处理-0的问题。 循环结构循环结构的应用场景如果在程序中我们需要重复的执行某条或某些指令，例如用程序控制机器人踢足球，如果机器人持球而且还没有进入射门范围，那么我们就要一直发出让机器人向球门方向奔跑的指令。当然你可能已经注意到了，刚才的描述中其实不仅仅有需要重复的动作，还有我们上一个章节讲到的分支结构。再举一个简单的例子，比如在我们的程序中要实现每隔1秒中在屏幕上打印一个&quot;hello, world&quot;这样的字符串并持续一个小时，我们肯定不能够将print(&#39;hello, world&#39;)这句代码写上3600遍，如果真的需要这样做那么我们的工作就太无聊了。因此，我们需要循环结构，使用循环结构我们就可以轻松的控制某件事或者某些事重复、重复、再重复的发生。在Python中构造循环结构有两种做法，一种是for-in循环，一种是while循环。 for-in循环如果明确的知道循环执行的次数或者是要对一个容器进行迭代（后面会讲到），那么我们推荐使用for-in循环，例如下面代码中计算$\sum_{n=1}^{100}n$。 1234567891011121314"""用for循环实现1~100求和Version: 0.1Author: 骆昊Date: 2018-03-01"""sum = 0for x in range(101): sum += xprint(sum) 需要说明的是上面代码中的range类型，range可以用来产生一个不变的数值序列，而且这个序列通常都是用在循环中的，例如： range(101)可以产生一个0到100的整数序列。 range(1, 100)可以产生一个1到99的整数序列。 range(1, 100, 2)可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。 知道了这一点，我们可以用下面的代码来实现1~100之间的偶数求和。 1234567891011121314"""用for循环实现1~100之间的偶数求和Version: 0.1Author: 骆昊Date: 2018-03-01"""sum = 0for x in range(2, 101, 2): sum += xprint(sum) 也可以通过在循环中使用分支结构的方式来实现相同的功能，代码如下所示。 123456789101112131415"""用for循环实现1~100之间的偶数求和Version: 0.1Author: 骆昊Date: 2018-03-01"""sum = 0for x in range(1, 101): if x % 2 == 0: sum += xprint(sum) while循环如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环，while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True循环继续，表达式的值为False循环结束。下面我们通过一个“猜数字”的小游戏（计算机出一个1~100之间的随机数，人输入自己猜的数字，计算机给出对应的提示信息，直到人猜出计算机出的数字）来看看如何使用while循环。 1234567891011121314151617181920212223242526272829"""猜数字游戏计算机出一个1~100之间的随机数由人来猜计算机根据人猜的数字分别给出提示大一点/小一点/猜对了Version: 0.1Author: 骆昊Date: 2018-03-01"""import randomanswer = random.randint(1, 100)counter = 0while True: counter += 1 number = int(input('请输入: ')) if number &lt; answer: print('大一点') elif number &gt; answer: print('小一点') else: print('恭喜你猜对了!') breakprint('你总共猜了%d次' % counter)if counter &gt; 7: print('你的智商余额明显不足') 说明：上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环，这一点在使用嵌套的循环结构（下面会讲到）需要引起注意。除了break之外，还有另一个关键字是continue，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。 和分支结构一样，循环结构也是可以嵌套的，也就是说在循环中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个九九乘法表。 1234567891011121314"""输出乘法口诀表(九九表)Version: 0.1Author: 骆昊Date: 2018-03-01"""for i in range(1, 10): for j in range(1, i + 1): print('%d*%d=%d' % (i, j, i * j), end='\t') print() 练习练习1：输入一个数判断是不是素数。1234567891011121314151617181920212223"""输入一个正整数判断它是不是素数Version: 0.1Author: 骆昊Date: 2018-03-01"""from math import sqrtnum = int(input('请输入一个正整数: '))end = int(sqrt(num))is_prime = Truefor x in range(2, end + 1): if num % x == 0: is_prime = False breakif is_prime and num != 1: print('%d是素数' % num)else: print('%d不是素数' % num) 练习2：输入两个正整数，计算最大公约数和最小公倍数。12345678910111213141516171819"""输入两个正整数计算最大公约数和最小公倍数Version: 0.1Author: 骆昊Date: 2018-03-01"""x = int(input('x = '))y = int(input('y = '))if x &gt; y: (x, y) = (y, x)for factor in range(x, 0, -1): if x % factor == 0 and y % factor == 0: print('%d和%d的最大公约数是%d' % (x, y, factor)) print('%d和%d的最小公倍数是%d' % (x, y, x * y // factor)) break 练习3：打印三角形图案。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849"""打印各种三角形图案*************** * ** *** ********* * *** ***** ****************Version: 0.1Author: 骆昊Date: 2018-03-01"""row = int(input('请输入行数: '))for i in range(row): for _ in range(i + 1): print('*', end='') print()for i in range(row): for j in range(row): if j &lt; row - i - 1: print(' ', end='') else: print('*', end='') print()for i in range(row): for _ in range(row - i - 1): print(' ', end='') for _ in range(2 * i + 1): print('*', end='') print() 函数和模块的使用在讲解本章节的内容之前，我们先来研究一道数学题，请说出下面的方程有多少组正整数解。 $$x_1 + x_2 + x_3 + x_4 = 8$$ 事实上，上面的问题等同于将8个苹果分成四组每组至少一个苹果有多少种方案。想到这一点问题的答案就呼之欲出了。 $$C_M^N =\frac{M!}{N!(M-N)!}, \text{(M=7, N=3)} $$ 可以用Python的程序来计算出这个值，代码如下所示。 123456789101112131415161718"""输入M和N计算C(M,N)"""m = int(input('m = '))n = int(input('n = '))fm = 1for num in range(1, m + 1): fm *= numfn = 1for num in range(1, n + 1): fn *= numfmn = 1for num in range(1, m - n + 1): fmn *= numprint(fm // fn // fmn) 函数的作用不知道大家是否注意到，在上面的代码中，我们做了3次求阶乘，这样的代码实际上就是重复代码。编程大师Martin Fowler先生曾经说过：“代码有很多种坏味道，重复是最坏的一种！”，要写出高质量的代码首先要解决的就是重复代码的问题。对于上面的代码来说，我们可以将计算阶乘的功能封装到一个称之为“函数”的功能模块中，在需要计算阶乘的地方，我们只需要“调用”这个“函数”就可以了。 定义函数在Python中可以使用def关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过return关键字来返回一个值，这相当于数学上说的函数的因变量。 在了解了如何定义函数后，我们可以对上面的代码进行重构，所谓重构就是在不影响代码执行结果的前提下对代码的结构进行调整，重构之后的代码如下所示。 123456789101112131415161718def factorial(num): """ 求阶乘 :param num: 非负整数 :return: num的阶乘 """ result = 1 for n in range(1, num + 1): result *= n return resultm = int(input('m = '))n = int(input('n = '))# 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数print(factorial(m) // factorial(n) // factorial(m - n)) 说明：Python的math模块中其实已经有一个factorial函数了，事实上要计算阶乘可以直接使用这个现成的函数而不用自己定义。下面例子中的某些函数其实Python中也是内置了，我们这里是为了讲解函数的定义和使用才把它们又实现了一遍，实际开发中不建议做这种低级的重复性的工作。 函数的参数函数是绝大多数编程语言中都支持的一个代码的“构建块”，但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载，因为我们在定义一个函数的时候可以让它有多种不同的使用方式，下面是两个小例子。 12345678910111213141516171819202122232425262728293031from random import randintdef roll_dice(n=2): """ 摇色子 :param n: 色子的个数 :return: n颗色子点数之和 """ total = 0 for _ in range(n): total += randint(1, 6) return totaldef add(a=0, b=0, c=0): return a + b + c# 如果没有指定参数那么使用默认值摇两颗色子print(roll_dice())# 摇三颗色子print(roll_dice(3))print(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))# 传递参数时可以不按照设定的顺序进行传递print(add(c=50, a=100, b=200)) 我们给上面两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用add函数，这跟其他很多语言中函数重载的效果是一致的。 其实上面的add函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定，我们作为函数的设计者对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下所示。 1234567891011121314# 在参数前使用*表示args是可变参数# 也就是说调用add函数时传入的参数个数可以是0个或多个def add(*args): total = 0 for val in args: total += val return totalprint(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))print(add(1, 3, 5, 7, 9)) 用模块管理函数对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。 123456789def foo(): print('hello, world!')def foo(): print('goodbye, world!')foo() # 输出goodbye, world! 当然上面的这种情况我们很容易就能避免，但是如果项目是由多人协作进行团队开发的时候，团队中可能有多个程序员都定义了名为foo的函数，那么怎么解决这种命名冲突呢？答案其实很简单，Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数，代码如下所示。 module1.py 12def foo(): print('hello, world!') module2.py 12def foo(): print('goodbye, world!') test.py 1234567from module1 import foofoo() # 输出hello, world!from module2 import foofoo() # 输出goodbye, world! 也可以按照如下所示的方式来区分到底要使用哪一个foo函数。 test.py 12345import module1 as m1import module2 as m2m1.foo()m2.foo() 但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个foo，因为后导入的foo覆盖了之前导入的foo。 test.py 1234from module1 import foofrom module2 import foofoo() # 输出goodbye, world! test.py 1234from module2 import foofrom module1 import foofoo() # 输出hello, world! 需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“__main__”。 module3.py 123456789101112131415def foo(): passdef bar(): pass# __name__是Python中一个隐含的变量它代表了模块的名字# 只有被Python解释器直接执行的模块的名字才是__main__if __name__ == '__main__': print('call foo()') foo() print('call bar()') bar() test.py 123import module3# 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__ 练习练习1：实现计算求最大公约数和最小公倍数的函数。123456789def gcd(x, y): (x, y) = (y, x) if x &gt; y else (x, y) for factor in range(x, 0, -1): if x % factor == 0 and y % factor == 0: return factordef lcm(x, y): return x * y // gcd(x, y) 练习2：实现判断一个数是不是回文数的函数。1234567def is_palindrome(num): temp = num total = 0 while temp &gt; 0: total = total * 10 + temp % 10 temp //= 10 return total == num 练习3：实现判断一个数是不是素数的函数。12345def is_prime(num): for factor in range(2, num): if num % factor == 0: return False return True if num != 1 else False 练习4：写一个程序判断输入的正整数是不是回文素数。1234if __name__ == '__main__': num = int(input('请输入正整数: ')) if is_palindrome(num) and is_prime(num): print('%d是回文素数' % num) 通过上面的程序可以看出，当我们将代码中重复出现的和相对独立的功能抽取成函数后，我们可以组合使用这些函数来解决更为复杂的问题，这也是我们为什么要定义和使用函数的一个非常重要的原因。 最后，我们来讨论一下Python中有关变量作用域的问题。 1234567891011121314151617def foo(): b = 'hello' def bar(): # Python中可以在函数内部再定义函数 c = True print(a) print(b) print(c) bar() # print(c) # NameError: name 'c' is not definedif __name__ == '__main__': a = 100 # print(b) # NameError: name 'b' is not defined foo() 上面的代码能够顺利的执行并且打印出100和“hello”，但我们注意到了，在bar函数的内部并没有定义a和b两个变量，那么a和b是从哪里来的。我们在上面代码的if分支中定义了一个变量a，这是一个全局变量（global variable），属于全局作用域，因为它没有定义在任何一个函数中。在上面的foo函数中我们定义了变量b，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在foo函数的外部并不能访问到它；但对于foo函数内部的bar函数来说，变量b属于嵌套作用域，在bar函数中我们是可以访问到它的。bar函数中的变量c属于局部作用域，在bar函数之外是无法访问的。事实上，Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些隐含标识符min、len等都属于内置作用域）。 再看看下面这段代码，我们希望通过函数调用修改全局变量a的值，但实际上下面的代码是做不到的。 123456789def foo(): a = 200 print(a) # 200if __name__ == '__main__': a = 100 foo() print(a) # 100 在调用foo函数后，我们发现a的值仍然是100，这是因为当我们在函数foo中写a = 200的时候，是重新定义了一个名字为a的局部变量，它跟全局作用域的a并不是同一个变量，因为局部作用域中有了自己的变量a，因此foo函数不再搜索全局作用域中的a。如果我们希望在foo函数中修改全局作用域中的a，代码如下所示。 12345678910def foo(): global a a = 200 print(a) # 200if __name__ == '__main__': a = 100 foo() print(a) # 200 我们可以使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么下面一行的代码就会定义变量a并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域，请大家自行试验。 在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收)。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在函数调用结束后依然可以访问，这时候就需要使用闭包)，这个我们在后续的内容中进行讲解。 说明：很多人经常会将“闭包”一词和“匿名函数”混为一谈，但实际上它们是不同的概念，如果想提前了解这个概念，推荐看看维基百科或者知乎上对这个概念的讨论。 说了那么多，其实结论很简单，从现在开始我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。 1234567def main(): # Todo: Add your code here passif __name__ == '__main__': main() 字符串和常用数据结构使用字符串第二次世界大战促使了现代电子计算机的诞生，当初的想法很简单，就是用计算机来计算导弹的弹道，因此在计算机刚刚诞生的那个年代，计算机处理的信息主要是数值，而世界上的第一台电子计算机ENIAC每秒钟能够完成约5000次浮点运算。随着时间的推移，虽然对数值运算仍然是计算机日常工作中最为重要的事情之一，但是今天的计算机处理得更多的数据都是以文本信息的方式存在的，而Python表示文本信息的方式我们在很早以前就说过了，那就是字符串类型。所谓字符串，就是由零个或多个字符组成的有限序列，一般记为$${\displaystyle s=a{1}a{2}\dots a_{n}(0\leq n \leq \infty)}$$。 我们可以通过下面的代码来了解字符串的使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def main(): str1 = 'hello, world!' # 通过len函数计算字符串的长度 print(len(str1)) # 13 # 获得字符串首字母大写的拷贝 print(str1.capitalize()) # Hello, world! # 获得字符串变大写后的拷贝 print(str1.upper()) # HELLO, WORLD! # 从字符串中查找子串所在位置 print(str1.find('or')) # 8 print(str1.find('shit')) # -1 # 与find类似但找不到子串时会引发异常 # print(str1.index('or')) # print(str1.index('shit')) # 检查字符串是否以指定的字符串开头 print(str1.startswith('He')) # False print(str1.startswith('hel')) # True # 检查字符串是否以指定的字符串结尾 print(str1.endswith('!')) # True # 将字符串以指定的宽度居中并在两侧填充指定的字符 print(str1.center(50, '*')) # 将字符串以指定的宽度靠右放置左侧填充指定的字符 print(str1.rjust(50, ' ')) str2 = 'abc123456' # 从字符串中取出指定位置的字符(下标运算) print(str2[2]) # c # 字符串切片(从指定的开始索引到指定的结束索引) print(str2[2:5]) # c12 print(str2[2:]) # c123456 print(str2[2::2]) # c246 print(str2[::2]) # ac246 print(str2[::-1]) # 654321cba print(str2[-3:-1]) # 45 # 检查字符串是否由数字构成 print(str2.isdigit()) # False # 检查字符串是否以字母构成 print(str2.isalpha()) # False # 检查字符串是否以数字和字母构成 print(str2.isalnum()) # True str3 = ' jackfrued@126.com ' print(str3) # 获得字符串修剪左右两侧空格的拷贝 print(str3.strip())if __name__ == '__main__': main() 除了字符串，Python还内置了多种类型的数据结构，如果要在程序中保存和操作数据，绝大多数时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典。 使用列表下面的代码演示了如何定义列表、使用下标访问列表元素以及添加和删除元素的操作。 12345678910111213141516171819202122232425262728293031323334def main(): list1 = [1, 3, 5, 7, 100] print(list1) list2 = ['hello'] * 5 print(list2) # 计算列表长度(元素个数) print(len(list1)) # 下标(索引)运算 print(list1[0]) print(list1[4]) # print(list1[5]) # IndexError: list index out of range print(list1[-1]) print(list1[-3]) list1[2] = 300 print(list1) # 添加元素 list1.append(200) list1.insert(1, 400) list1 += [1000, 2000] print(list1) print(len(list1)) # 删除元素 list1.remove(3) if 1234 in list1: list1.remove(1234) del list1[0] print(list1) # 清空列表元素 list1.clear() print(list1) if __name__ == '__main__': main() 和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表，代码如下所示。 1234567891011121314151617181920212223def main(): fruits = ['grape', 'apple', 'strawberry', 'waxberry'] fruits += ['pitaya', 'pear', 'mango'] # 循环遍历列表元素 for fruit in fruits: print(fruit.title(), end=' ') print() # 列表切片 fruits2 = fruits[1:4] print(fruits2) # fruit3 = fruits # 没有复制列表只创建了新的引用 # 可以通过完整切片操作来复制列表 fruits3 = fruits[:] print(fruits3) fruits4 = fruits[-3:-1] print(fruits4) # 可以通过反向切片操作来获得倒转后的列表的拷贝 fruits5 = fruits[::-1] print(fruits5)if __name__ == '__main__': main() 下面的代码实现了对列表的排序操作。 12345678910111213141516171819def main(): list1 = ['orange', 'apple', 'zoo', 'internationalization', 'blueberry'] list2 = sorted(list1) # sorted函数返回列表排序后的拷贝不会修改传入的列表 # 函数的设计就应该像sorted函数一样尽可能不产生副作用 list3 = sorted(list1, reverse=True) # 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序 list4 = sorted(list1, key=len) print(list1) print(list2) print(list3) print(list4) # 给列表对象发出排序消息直接在列表对象上进行排序 list1.sort(reverse=True) print(list1)if __name__ == '__main__': main() 我们还可以使用列表的生成式语法来创建列表，代码如下所示。 12345678910111213141516171819202122232425import sysdef main(): f = [x for x in range(1, 10)] print(f) f = [x + y for x in 'ABCDE' for y in '1234567'] print(f) # 用列表的生成表达式语法创建列表容器 # 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间 f = [x ** 2 for x in range(1, 1000)] print(sys.getsizeof(f)) # 查看对象占用内存的字节数 print(f) # 请注意下面的代码创建的不是一个列表而是一个生成器对象 # 通过生成器可以获取到数据但它不占用额外的空间存储数据 # 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间) f = (x ** 2 for x in range(1, 1000)) print(sys.getsizeof(f)) # 相比生成式生成器不占用存储数据的空间 print(f) for val in f: print(val)if __name__ == '__main__': main() 除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现一个生成斐波拉切数列的生成器。所谓斐波拉切数列可以通过下面递归的方法来进行定义： $${\displaystyle F_{0}=0}$$ $${\displaystyle F_{1}=1}$$ $${\displaystyle F{n}=F{n-1}+F_{n-2}}({n}\geq{2})$$ 1234567891011121314def fib(n): a, b = 0, 1 for _ in range(n): a, b = b, a + b yield adef main(): for val in fib(20): print(val)if __name__ == '__main__': main() 使用元组Python 的元组与列表类似，不同之处在于元组的元素不能修改，在前面的代码中我们已经不止一次使用过元组了。顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组。 123456789101112131415161718192021222324252627282930def main(): # 定义元组 t = ('骆昊', 38, True, '四川成都') print(t) # 获取元组中的元素 print(t[0]) print(t[3]) # 遍历元组中的值 for member in t: print(member) # 重新给元组赋值 # t[0] = '王大锤' # TypeError # 变量t重新引用了新的元组原来的元组将被垃圾回收 t = ('王大锤', 20, True, '云南昆明') print(t) # 将元组转换成列表 person = list(t) print(person) # 列表是可以修改它的元素的 person[0] = '李小龙' person[1] = 25 print(person) # 将列表转换成元组 fruits_list = ['apple', 'banana', 'orange'] fruits_tuple = tuple(fruits_list) print(fruits_tuple)if __name__ == '__main__': main() 这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？ 元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。 元组在创建时间和占用的空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间. ! 使用集合Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546def main(): set1 = &#123;1, 2, 3, 3, 3, 2&#125; print(set1) print('Length =', len(set1)) set2 = set(range(1, 10)) print(set2) set1.add(4) set1.add(5) set2.update([11, 12]) print(set1) print(set2) set2.discard(5) # remove的元素如果不存在会引发KeyError if 4 in set2: set2.remove(4) print(set2) # 遍历集合容器 for elem in set2: print(elem ** 2, end=' ') print() # 将元组转换成集合 set3 = set((1, 2, 3, 3, 2, 1)) print(set3.pop()) print(set3) # 集合的交集、并集、差集、对称差运算 print(set1 &amp; set2) # print(set1.intersection(set2)) print(set1 | set2) # print(set1.union(set2)) print(set1 - set2) # print(set1.difference(set2)) print(set1 ^ set2) # print(set1.symmetric_difference(set2)) # 判断子集和超集 print(set2 &lt;= set1) # print(set2.issubset(set1)) print(set3 &lt;= set1) # print(set3.issubset(set1)) print(set1 &gt;= set2) # print(set1.issuperset(set2)) print(set1 &gt;= set3) # print(set1.issuperset(set3))if __name__ == '__main__': main() 说明：Python中允许通过一些特殊的方法来为某种类型或数据结构自定义运算符（后面的章节中会讲到），上面的代码中我们对集合进行运算的时候可以调用集合对象的方法，也可以直接使用对应的运算符，例如&amp;运算符跟intersection方法的作用就是一样的，但是使用运算符让代码更加直观。 使用字典字典是另一种可变容器模型，类似于我们生活中使用的字典，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。下面的代码演示了如何定义和使用字典。 1234567891011121314151617181920212223242526272829def main(): scores = &#123;'骆昊': 95, '白元芳': 78, '狄仁杰': 82&#125; # 通过键可以获取字典中对应的值 print(scores['骆昊']) print(scores['狄仁杰']) # 对字典进行遍历(遍历的其实是键再通过键取对应的值) for elem in scores: print('%s\t---&gt;\t%d' % (elem, scores[elem])) # 更新字典中的元素 scores['白元芳'] = 65 scores['诸葛王朗'] = 71 scores.update(冷面=67, 方启鹤=85) print(scores) if '武则天' in scores: print(scores['武则天']) print(scores.get('武则天')) # get方法也是通过键获取对应的值但是可以设置默认值 print(scores.get('武则天', 60)) # 删除字典中的元素 print(scores.popitem()) print(scores.popitem()) print(scores.pop('骆昊', 100)) # 清空字典 scores.clear() print(scores)if __name__ == '__main__': main() 练习练习1：在屏幕上显示跑马灯文字1234567891011121314151617import osimport timedef main(): content = '北京欢迎你为你开天辟地…………' while True: # 清理屏幕上的输出 os.system('cls') # os.system('clear') print(content) # 休眠200毫秒 time.sleep(0.2) content = content[1:] + content[0]if __name__ == '__main__': main() 练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。123456789101112131415161718import randomdef generate_code(code_len=4): """ 生成指定长度的验证码 :param code_len: 验证码的长度(默认4个字符) :return: 由大小写英文字母和数字构成的随机验证码 """ all_chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' last_pos = len(all_chars) - 1 code = '' for _ in range(code_len): index = random.randint(0, last_pos) code += all_chars[index] return code 练习3：设计一个函数返回给定文件名的后缀名。123456789101112131415def get_suffix(filename, has_dot=False): """ 获取文件名的后缀名 :param filename: 文件名 :param has_dot: 返回的后缀名是否需要带点 :return: 文件的后缀名 """ pos = filename.rfind('.') if 0 &lt; pos &lt; len(filename) - 1: index = pos if has_dot else pos + 1 return filename[index:] else: return '' 练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。123456789def max2(x): m1, m2 = (x[0], x[1]) if x[0] &gt; x[1] else (x[1], x[0]) for index in range(2, len(x)): if x[index] &gt; m1: m2 = m1 m1 = x[index] elif x[index] &gt; m2: m2 = x[index] return m1, m2 练习5：计算指定的年月日是这一年的第几天12345678910111213141516171819202122232425262728293031323334353637383940def is_leap_year(year): """ 判断指定的年份是不是闰年 :param year: 年份 :return: 闰年返回True平年返回False """ return year % 4 == 0 and year % 100 != 0 or year % 400 == 0def which_day(year, month, date): """ 计算传入的日期是这一年的第几天 :param year: 年 :param month: 月 :param date: 日 :return: 第几天 """ days_of_month = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ][is_leap_year(year)] total = 0 for index in range(month - 1): total += days_of_month[index] return total + datedef main(): print(which_day(1980, 11, 28)) print(which_day(1981, 12, 31)) print(which_day(2018, 1, 1)) print(which_day(2016, 3, 1))if __name__ == '__main__': main() 练习6：打印杨辉三角。12345678910111213141516def main(): num = int(input('Number of rows: ')) yh = [[]] * num for row in range(len(yh)): yh[row] = [None] * (row + 1) for col in range(len(yh[row])): if col == 0 or col == row: yh[row][col] = 1 else: yh[row][col] = yh[row - 1][col] + yh[row - 1][col - 1] print(yh[row][col], end='\t') print()if __name__ == '__main__': main() 综合案例案例1：双色球选号12345678910111213141516171819202122232425262728293031323334353637383940from random import randrange, randint, sampledef display(balls): """ 输出列表中的双色球号码 """ for index, ball in enumerate(balls): if index == len(balls) - 1: print('|', end=' ') print('%02d' % ball, end=' ') print()def random_select(): """ 随机选择一组号码 """ red_balls = [x for x in range(1, 34)] selected_balls = [] for _ in range(6): index = randrange(len(red_balls)) selected_balls.append(red_balls[index]) del red_balls[index] # 上面的for循环也可以写成下面这行代码 # sample函数是random模块下的函数 # selected_balls = sample(red_balls, 6) selected_balls.sort() selected_balls.append(randint(1, 16)) return selected_ballsdef main(): n = int(input('机选几注: ')) for _ in range(n): display(random_select())if __name__ == '__main__': main() 说明：可以使用random模块的sample函数来实现从列表中选择不重复的n个元素。 综合案例2：约瑟夫环问题1234567891011121314151617181920212223242526"""《幸运的基督徒》有15个基督徒和15个非基督徒在海上遇险，为了能让一部分人活下来不得不将其中15个人扔到海里面去，有个人想了个办法就是大家围成一个圈，由某个人开始从1报数，报到9的人就扔到海里面，他后面的人接着从1开始报数，报到9的人继续扔到海里面，直到扔掉15个人。由于上帝的保佑，15个基督徒都幸免于难，问这些人最开始是怎么站的，哪些位置是基督徒哪些位置是非基督徒。"""def main(): persons = [True] * 30 counter, index, number = 0, 0, 0 while counter &lt; 15: if persons[index]: number += 1 if number == 9: persons[index] = False counter += 1 number = 0 index += 1 index %= 30 for person in persons: print('基' if person else '非', end='')if __name__ == '__main__': main() 综合案例3：井字棋游戏123456789101112131415161718192021222324252627282930313233343536373839404142import osdef print_board(board): print(board['TL'] + '|' + board['TM'] + '|' + board['TR']) print('-+-+-') print(board['ML'] + '|' + board['MM'] + '|' + board['MR']) print('-+-+-') print(board['BL'] + '|' + board['BM'] + '|' + board['BR'])def main(): init_board = &#123; 'TL': ' ', 'TM': ' ', 'TR': ' ', 'ML': ' ', 'MM': ' ', 'MR': ' ', 'BL': ' ', 'BM': ' ', 'BR': ' ' &#125; begin = True while begin: curr_board = init_board.copy() begin = False turn = 'x' counter = 0 os.system('clear') print_board(curr_board) while counter &lt; 9: move = input('轮到%s走棋, 请输入位置: ' % turn) if curr_board[move] == ' ': counter += 1 curr_board[move] = turn if turn == 'x': turn = 'o' else: turn = 'x' os.system('clear') print_board(curr_board) choice = input('再玩一局?(yes|no)') begin = choice == 'yes'if __name__ == '__main__': main() 说明：最后这个案例来自《Python编程快速上手:让繁琐工作自动化》一书（这本书对有编程基础想迅速使用Python将日常工作自动化的人来说还是不错的教材），对代码做了一点点的调整。 面向对象编程基础活在当下的程序员应该都听过“面向对象编程”一词，也经常有人问能不能用一句话解释下什么是“面向对象编程”，我们先来看看比较正式的说法。 把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。 之前我们说过“程序是指令的集合”，我们在程序中书写的语句在执行时会变成一条或多条指令然后由CPU去执行。当然为了简化程序的设计，我们引入了函数的概念，把相对独立且经常重复使用的代码放置到函数中，在需要使用这些功能的时候只要调用函数即可；如果一个函数的功能过于复杂和臃肿，我们又可以进一步将函数继续切分为子函数来降低系统的复杂性。但是说了这么多，不知道大家是否发现，所谓编程就是程序员按照计算机的工作方式控制计算机完成各种任务。但是，计算机的工作方式与正常人类的思维模式是不同的，如果编程就必须得抛弃人类正常的思维方式去迎合计算机，编程的乐趣就少了很多，“每个人都应该学习编程”这样的豪言壮语就只能说说而已。当然，这些还不是最重要的，最重要的是当我们需要开发一个复杂的系统时，代码的复杂性会让开发和维护工作都变得举步维艰，所以在上世纪60年代末期，“软件危机”、“软件工程”等一系列的概念开始在行业中出现。 当然，程序员圈子内的人都知道，现实中并没有解决上面所说的这些问题的“银弹”，真正让软件开发者看到希望的是上世纪70年代诞生的Smalltalk编程语言中引入的面向对象的编程思想（面向对象编程的雏形可以追溯到更早期的Simula语言）。按照这种编程理念，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为“对象”，而我们解决问题的方式就是创建出需要的对象并向对象发出各种各样的消息，多个对象的协同工作最终可以让我们构造出复杂的系统来解决现实中的问题。 说明：当然面向对象也不是解决软件开发中所有问题的最后的“银弹”，所以今天的高级程序设计语言几乎都提供了对多种编程范式的支持，Python也不例外。 类和对象简单的说，类是对象的蓝图和模板，而对象是类的实例。这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。 定义类在Python中可以使用class关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。 123456789101112131415161718class Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print('%s正在学习%s.' % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是很多程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_av(self): if self.age &lt; 18: print('%s只能观看《熊出没》.' % self.name) else: print('%s正在观看岛国爱情动作片.' % self.name) 说明：写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。 创建和使用对象当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。 1234567891011121314def main(): # 创建学生对象并指定姓名和年龄 stu1 = Student('骆昊', 38) # 给对象发study消息 stu1.study('Python程序设计') # 给对象发watch_av消息 stu1.watch_av() stu2 = Student('王大锤', 15) stu2.study('思想品德') stu2.watch_av()if __name__ == '__main__': main() 访问可见性问题对于上面的代码，有C++、Java、C#等编程经验的程序员可能会问，我们给Student对象绑定的name和age属性到底具有怎样的访问权限（也称为可见性）。因为在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。 1234567891011121314151617181920class Test: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print('__bar')def main(): test = Test('hello') # AttributeError: 'Test' object has no attribute '__bar' test.__bar() # AttributeError: 'Test' object has no attribute '__foo' print(test.__foo)if __name__ == "__main__": main() 但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来“妨碍”对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是“We are all consenting adults here”。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。 123456789101112131415161718class Test: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print('__bar')def main(): test = Test('hello') test._Test__bar() print(test._Test__foo)if __name__ == "__main__": main() 在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻，关于这一点可以看看我的《Python - 那些年我们踩过的那些坑》文章中的讲解。 面向对象的支柱面向对象有三大支柱：封装、继承和多态。后面两个概念在下一个章节中进行详细的说明，这里我们先说一下什么是封装。我自己对封装的理解是“隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口”。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道方法内部的实现细节（方法的内部视图）。 练习练习1：定义一个类描述数字时钟123456789101112131415161718192021222324252627282930313233343536373839404142434445class Clock(object): """ 数字时钟 """ def __init__(self, hour=0, minute=0, second=0): """ 构造器 :param hour: 时 :param minute: 分 :param second: 秒 """ self._hour = hour self._minute = minute self._second = second def run(self): """走字""" self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def __str__(self): """显示时间""" return '%02d:%02d:%02d' % \ (self._hour, self._minute, self._second)def main(): clock = Clock(23, 59, 58) while True: print(clock) sleep(1) clock.run()if __name__ == '__main__': main() 练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from math import sqrtclass Point(object): def __init__(self, x=0, y=0): """ 构造器 :param x: 横坐标 :param y: 纵坐标 """ self.x = x self.y = y def move_to(self, x, y): """ 移动到指定位置 :param x: 新的横坐标 "param y: 新的纵坐标 """ self.x = x self.y = y def move_by(self, dx, dy): """ 移动指定的增量 :param dx: 横坐标的增量 "param dy: 纵坐标的增量 """ self.x += dx self.y += dy def distance_to(self, other): """ 计算与另一个点的距离 :param other: 另一个点 """ dx = self.x - other.x dy = self.y - other.y return sqrt(dx ** 2 + dy ** 2) def __str__(self): return '(%s, %s)' % (str(self.x), str(self.y))def main(): p1 = Point(3, 5) p2 = Point() print(p1) print(p2) p2.move_by(-1, 2) print(p2) print(p1.distance_to(p2))if __name__ == '__main__': main() 说明：本章中的插图来自于Grady Booch等著作的《面向对象分析与设计》一书，该书是讲解面向对象编程的经典著作，有兴趣的读者可以购买和阅读这本书来了解更多的面向对象的相关知识。 面向对象进阶在前面的章节我们已经了解了面向对象的入门知识，知道了如何定义类，如何创建对象以及如何给对象发消息。为了能够更好的使用面向对象编程思想进行程序开发，我们还需要对Python中的面向对象编程进行更为深入的了解。 @property装饰器之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。 1234567891011121314151617181920212223242526272829303132333435363738class Person(object): def __init__(self, name, age): self._name = name self._age = age # 访问器 - getter方法 @property def name(self): return self._name # 访问器 - getter方法 @property def age(self): return self._age # 修改器 - setter方法 @age.setter def age(self, age): self._age = age def play(self): if self._age &lt;= 16: print('%s正在玩飞行棋.' % self._name) else: print('%s正在玩斗地主.' % self._name)def main(): person = Person('王大锤', 12) person.play() person.age = 22 person.play() # person.name = '白元芳' # AttributeError: can't set attributeif __name__ == '__main__': main() __slots__魔法我们讲到这里，不知道大家是否已经意识到，Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 12345678910111213141516171819202122232425262728293031323334class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = ('_name', '_age', '_gender') def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): if self._age &lt;= 16: print('%s正在玩飞行棋.' % self._name) else: print('%s正在玩斗地主.' % self._name)def main(): person = Person('王大锤', 22) person.play() person._gender = '男' # AttributeError: 'Person' object has no attribute '_is_gay' # person._is_gay = True 静态方法和类方法之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839from math import sqrtclass Triangle(object): def __init__(self, a, b, c): self._a = a self._b = b self._c = c @staticmethod def is_valid(a, b, c): return a + b &gt; c and b + c &gt; a and a + c &gt; b def perimeter(self): return self._a + self._b + self._c def area(self): half = self.perimeter() / 2 return sqrt(half * (half - self._a) * (half - self._b) * (half - self._c))def main(): a, b, c = 3, 4, 5 # 静态方法和类方法都是通过给类发消息来调用的 if Triangle.is_valid(a, b, c): t = Triangle(a, b, c) print(t.perimeter()) # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数 # print(Triangle.perimeter(t)) print(t.area()) # print(Triangle.area(t)) else: print('无法构成三角形.')if __name__ == '__main__': main() 和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445from time import time, localtime, sleepclass Clock(object): """数字时钟""" def __init__(self, hour=0, minute=0, second=0): self._hour = hour self._minute = minute self._second = second @classmethod def now(cls): ctime = localtime(time()) return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec) def run(self): """走字""" self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def show(self): """显示时间""" return '%02d:%02d:%02d' % \ (self._hour, self._minute, self._second)def main(): # 通过类方法创建对象并获取系统时间 clock = Clock.now() while True: print(clock.show()) sleep(1) clock.run()if __name__ == '__main__': main() 类之间的关系简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。 is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。 has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。 use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。 我们可以使用一种叫做UML（统一建模语言）的东西来进行面向对象建模，其中一项重要的工作就是把类和类之间的关系用标准化的图形符号描述出来。关于UML我们在这里不做详细的介绍，有兴趣的读者可以自行阅读《UML面向对象设计基础》一书。 利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。 继承和多态刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则。下面我们先看一个继承的例子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Person(object): """人""" def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): print('%s正在愉快的玩耍.' % self._name) def watch_av(self): if self._age &gt;= 18: print('%s正在观看爱情动作片.' % self._name) else: print('%s只能观看《熊出没》.' % self._name)class Student(Person): """学生""" def __init__(self, name, age, grade): super().__init__(name, age) self._grade = grade @property def grade(self): return self._grade @grade.setter def grade(self, grade): self._grade = grade def study(self, course): print('%s的%s正在学习%s.' % (self._grade, self._name, course))class Teacher(Person): """老师""" def __init__(self, name, age, title): super().__init__(name, age) self._title = title @property def title(self): return self._title @title.setter def title(self, title): self._title = title def teach(self, course): print('%s%s正在讲%s.' % (self._name, self._title, course))def main(): stu = Student('王大锤', 15, '初三') stu.study('数学') stu.watch_av() t = Teacher('骆昊', 38, '老叫兽') t.teach('Python程序设计') t.watch_av()if __name__ == '__main__': main() 子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。 12345678910111213141516171819202122232425262728293031323334353637from abc import ABCMeta, abstractmethodclass Pet(object, metaclass=ABCMeta): """宠物""" def __init__(self, nickname): self._nickname = nickname @abstractmethod def make_voice(self): """发出声音""" passclass Dog(Pet): """狗""" def make_voice(self): print('%s: 汪汪汪...' % self._nickname)class Cat(Pet): """猫""" def make_voice(self): print('%s: 喵...喵...' % self._nickname)def main(): pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')] for pet in pets: pet.make_voice()if __name__ == '__main__': main() 在上面的代码中，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。 综合案例案例1：奥特曼打小怪兽123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190from abc import ABCMeta, abstractmethodfrom random import randint, randrangeclass Fighter(object, metaclass=ABCMeta): """战斗者""" # 通过__slots__魔法限定对象可以绑定的成员变量 __slots__ = ('_name', '_hp') def __init__(self, name, hp): """ 初始化方法 :param name: 名字 :param hp: 生命值 """ self._name = name self._hp = hp @property def name(self): return self._name @property def hp(self): return self._hp @hp.setter def hp(self, hp): self._hp = hp if hp &gt;= 0 else 0 @property def alive(self): return self._hp &gt; 0 @abstractmethod def attack(self, other): """ 攻击 :param other: 被攻击的对象 """ passclass Ultraman(Fighter): """奥特曼""" __slots__ = ('_name', '_hp', '_mp') def __init__(self, name, hp, mp): """ 初始化方法 :param name: 名字 :param hp: 生命值 :param mp: 魔法值 """ super().__init__(name, hp) self._mp = mp def attack(self, other): other.hp -= randint(15, 25) def huge_attack(self, other): """ 究极必杀技(打掉对方至少50点或四分之三的血) :param other: 被攻击的对象 :return: 使用成功返回True否则返回False """ if self._mp &gt;= 50: self._mp -= 50 injury = other.hp * 3 // 4 injury = injury if injury &gt;= 50 else 50 other.hp -= injury return True else: self.attack(other) return False def magic_attack(self, others): """ 魔法攻击 :param others: 被攻击的群体 :return: 使用魔法成功返回True否则返回False """ if self._mp &gt;= 20: self._mp -= 20 for temp in others: if temp.alive: temp.hp -= randint(10, 15) return True else: return False def resume(self): """恢复魔法值""" incr_point = randint(1, 10) self._mp += incr_point return incr_point def __str__(self): return '~~~%s奥特曼~~~\n' % self._name + \ '生命值: %d\n' % self._hp + \ '魔法值: %d\n' % self._mpclass Monster(Fighter): """小怪兽""" __slots__ = ('_name', '_hp') def attack(self, other): other.hp -= randint(10, 20) def __str__(self): return '~~~%s小怪兽~~~\n' % self._name + \ '生命值: %d\n' % self._hpdef is_any_alive(monsters): """判断有没有小怪兽是活着的""" for monster in monsters: if monster.alive &gt; 0: return True return Falsedef select_alive_one(monsters): """选中一只活着的小怪兽""" monsters_len = len(monsters) while True: index = randrange(monsters_len) monster = monsters[index] if monster.alive &gt; 0: return monsterdef display_info(ultraman, monsters): """显示奥特曼和小怪兽的信息""" print(ultraman) for monster in monsters: print(monster, end='')def main(): u = Ultraman('骆昊', 1000, 120) m1 = Monster('舒小玲', 250) m2 = Monster('白元芳', 500) m3 = Monster('王大锤', 750) ms = [m1, m2, m3] fight_round = 1 while u.alive and is_any_alive(ms): print('========第%02d回合========' % fight_round) m = select_alive_one(ms) # 选中一只小怪兽 skill = randint(1, 10) # 通过随机数选择使用哪种技能 if skill &lt;= 6: # 60%的概率使用普通攻击 print('%s使用普通攻击打了%s.' % (u.name, m.name)) u.attack(m) print('%s的魔法值恢复了%d点.' % (u.name, u.resume())) elif skill &lt;= 9: # 30%的概率使用魔法攻击(可能因魔法值不足而失败) if u.magic_attack(ms): print('%s使用了魔法攻击.' % u.name) else: print('%s使用魔法失败.' % u.name) else: # 10%的概率使用究极必杀技(如果魔法值不足则使用普通攻击) if u.huge_attack(m): print('%s使用究极必杀技虐了%s.' % (u.name, m.name)) else: print('%s使用普通攻击打了%s.' % (u.name, m.name)) print('%s的魔法值恢复了%d点.' % (u.name, u.resume())) if m.alive &gt; 0: # 如果选中的小怪兽没有死就回击奥特曼 print('%s回击了%s.' % (m.name, u.name)) m.attack(u) display_info(u, ms) # 每个回合结束后显示奥特曼和小怪兽的信息 fight_round += 1 print('\n========战斗结束!========\n') if u.alive &gt; 0: print('%s奥特曼胜利!' % u.name) else: print('小怪兽胜利!')if __name__ == '__main__': main() 案例2：扑克游戏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116from random import randrangeclass Card(object): """一张牌""" def __init__(self, suite, face): self._suite = suite self._face = face @property def face(self): return self._face @property def suite(self): return self._suite def __str__(self): all_suites = ('♠', '♥', '♣', '♦') if self._face == 1: face_str = 'A' elif self._face == 11: face_str = 'J' elif self._face == 12: face_str = 'Q' elif self._face == 13: face_str = 'K' else: face_str = str(self._face) return '%s%s' % (all_suites[self._suite], face_str)class Poker(object): """一副牌""" def __init__(self): self._cards = [] self._current = 0 for suite in range(4): for face in range(1, 14): card = Card(suite, face) self._cards.append(card) @property def cards(self): return self._cards def shuffle(self): """洗牌(随机乱序)""" self._current = 0 cards_len = len(self._cards) for index in range(cards_len): pos = randrange(cards_len) self._cards[index], self._cards[pos] = \ self._cards[pos], self._cards[index] @property def next(self): """发牌""" card = self._cards[self._current] self._current += 1 return card @property def has_next(self): """还有没有牌""" return self._current &lt; len(self._cards)class Player(object): """玩家""" def __init__(self, name): self._name = name self._cards_on_hand = [] @property def name(self): return self._name @property def cards_on_hand(self): return self._cards_on_hand def get(self, card): """摸牌""" self._cards_on_hand.append(card) def arrange(self, card_key): """玩家整理手上的牌""" self._cards_on_hand.sort(key=card_key)# 排序规则-先根据花色再根据点数排序def get_key(card): return (card.suite, card.face)def main(): p = Poker() p.shuffle() players = [Player('东邪'), Player('西毒'), Player('南帝'), Player('北丐')] for _ in range(13): for player in players: player.get(p.next) for player in players: print(player.name + ':', end=' ') player.arrange(get_key) for card in player.cards_on_hand: print(card, end=' ') print()if __name__ == '__main__': main() 说明：大家可以自己尝试在上面代码的基础上写一个简单的扑克游戏，例如21点(Black Jack)，游戏的规则可以自己在网上找一找。 案例3：工资结算系统123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101"""某公司有三种类型的员工 分别是部门经理、程序员和销售员需要设计一个工资结算系统 根据提供的员工信息来计算月薪部门经理的月薪是每月固定15000元程序员的月薪按本月工作时间计算 每小时150元销售员的月薪是1200元的底薪加上销售额5%的提成"""from abc import ABCMeta, abstractmethodclass Employee(object, metaclass=ABCMeta): """员工""" def __init__(self, name): """ 初始化方法 :param name: 姓名 """ self._name = name @property def name(self): return self._name @abstractmethod def get_salary(self): """ 获得月薪 :return: 月薪 """ passclass Manager(Employee): """部门经理""" def get_salary(self): return 15000.0class Programmer(Employee): """程序员""" def __init__(self, name, working_hour=0): super().__init__(name) self._working_hour = working_hour @property def working_hour(self): return self._working_hour @working_hour.setter def working_hour(self, working_hour): self._working_hour = working_hour if working_hour &gt; 0 else 0 def get_salary(self): return 150.0 * self._working_hourclass Salesman(Employee): """销售员""" def __init__(self, name, sales=0): super().__init__(name) self._sales = sales @property def sales(self): return self._sales @sales.setter def sales(self, sales): self._sales = sales if sales &gt; 0 else 0 def get_salary(self): return 1200.0 + self._sales * 0.05def main(): emps = [ Manager('刘备'), Programmer('诸葛亮'), Manager('曹操'), Salesman('荀彧'), Salesman('吕布'), Programmer('张辽'), Programmer('赵云') ] for emp in emps: if isinstance(emp, Programmer): emp.working_hour = int(input('请输入%s本月工作时间: ' % emp.name)) elif isinstance(emp, Salesman): emp.sales = float(input('请输入%s本月销售额: ' % emp.name)) # 同样是接收get_salary这个消息但是不同的员工表现出了不同的行为(多态) print('%s本月工资为: ￥%s元' % (emp.name, emp.get_salary()))if __name__ == '__main__': main() 图形用户界面和游戏开发基于tkinter模块的GUIGUI是图形用户界面的缩写，图形化的用户界面对使用过计算机的人来说应该都不陌生，在此也无需进行赘述。Python默认的GUI开发模块是tkinter（在Python 3以前的版本中名为Tkinter），从这个名字就可以看出它是基于Tk的，Tk是一个工具包，最初是为Tcl设计的，后来被移植到很多其他的脚本语言中，它提供了跨平台的GUI控件。当然Tk并不是最新和最好的选择，也没有功能特别强大的GUI控件，事实上，开发GUI应用并不是Python最擅长的工作，如果真的需要使用Python开发GUI应用，wxPython、PyQt、PyGTK等模块都是不错的选择。 基本上使用tkinter来开发GUI应用需要以下5个步骤： 导入tkinter模块中我们需要的东西。 创建一个顶层窗口对象并用它来承载整个GUI应用。 在顶层窗口对象上添加GUI组件。 通过代码将这些GUI组件的功能组织起来。 进入主事件循环(main loop)。 下面的代码演示了如何使用tkinter做一个简单的GUI应用。 12345678910111213141516171819202122232425262728293031323334353637383940414243import tkinterimport tkinter.messageboxdef main(): flag = True # 修改标签上的文字 def change_label_text(): nonlocal flag flag = not flag color, msg = ('red', 'Hello, world!')\ if flag else ('blue', 'Goodbye, world!') label.config(text=msg, fg=color) # 确认退出 def confirm_to_quit(): if tkinter.messagebox.askokcancel('温馨提示', '确定要退出吗?'): top.quit() # 创建顶层窗口 top = tkinter.Tk() # 设置窗口大小 top.geometry('240x160') # 设置窗口标题 top.title('小游戏') # 创建标签对象并添加到顶层窗口 label = tkinter.Label(top, text='Hello, world!', font='Arial -32', fg='red') label.pack(expand=1) # 创建一个装按钮的容器 panel = tkinter.Frame(top) # 创建按钮对象 指定添加到哪个容器中 通过command参数绑定事件回调函数 button1 = tkinter.Button(panel, text='修改', command=change_label_text) button1.pack(side='left') button2 = tkinter.Button(panel, text='退出', command=confirm_to_quit) button2.pack(side='right') panel.pack(side='bottom') # 开启主事件循环 tkinter.mainloop()if __name__ == '__main__': main() 需要说明的是，GUI应用通常是事件驱动式的，之所以要进入主事件循环就是要监听鼠标、键盘等各种事件的发生并执行对应的代码对事件进行处理，因为事件会持续的发生，所以需要这样的一个循环一直运行着等待下一个事件的发生。另一方面，Tk为控件的摆放提供了三种布局管理器，通过布局管理器可以对控件进行定位，这三种布局管理器分别是：Placer（开发者提供控件的大小和摆放位置）、Packer（自动将控件填充到合适的位置）和Grid（基于网格坐标来摆放控件），此处不进行赘述。 使用Pygame进行游戏开发Pygame是一个开源的Python模块，专门用于多媒体应用（如电子游戏）的开发，其中包含对图像、声音、视频、事件、碰撞等的支持。Pygame建立在SDL的基础上，SDL是一套跨平台的多媒体开发库，用C语言实现，被广泛的应用于游戏、模拟器、播放器等的开发。而Pygame让游戏开发者不再被底层语言束缚，可以更多的关注游戏的功能和逻辑。 下面我们来完成一个简单的小游戏，游戏的名字叫“大球吃小球”，当然完成这个游戏并不是重点，学会使用Pygame也不是重点，最重要的我们要在这个过程中体会如何使用前面讲解的面向对象程序设计，学会用这种编程思想去解决现实中的问题。 制作游戏窗口123456789101112131415161718192021import pygamedef main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = Falseif __name__ == '__main__': main() 在窗口中绘图可以通过pygame中draw模块的函数在窗口上绘图，可以绘制的图形包括：线条、矩形、多边形、圆、椭圆、圆弧等。需要说明的是，屏幕坐标系是将屏幕左上角设置为坐标原点(0, 0)，向右是x轴的正向，向下是y轴的正向，在表示位置或者设置尺寸的时候，我们默认的单位都是像素。所谓像素就是屏幕上的一个点，你可以用浏览图片的软件试着将一张图片放大若干倍，就可以看到这些点。pygame中表示颜色用的是色光三原色表示法，即通过一个元组或列表来指定颜色的RGB值，每个值都在0~255之间，因为是每种原色都用一个8位（bit）的值来表示，三种颜色相当于一共由24位构成，这也就是常说的“24位颜色表示法”。 123456789101112131415161718192021222324252627import pygamedef main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') # 设置窗口的背景色(颜色是由红绿蓝三原色构成的元组) screen.fill((242, 242, 242)) # 绘制一个圆(参数分别是: 屏幕, 颜色, 圆心位置, 半径, 0表示填充圆) pygame.draw.circle(screen, (255, 0, 0,), (100, 100), 30, 0) # 刷新当前窗口(渲染窗口将绘制的图像呈现出来) pygame.display.flip() running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = Falseif __name__ == '__main__': main() 加载图像如果需要直接加载图像到窗口上，可以使用pygame中image模块的函数来加载图像，再通过之前获得的窗口对象的blit方法渲染图像，代码如下所示。 1234567891011121314151617181920212223242526272829import pygamedef main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') # 设置窗口的背景色(颜色是由红绿蓝三原色构成的元组) screen.fill((255, 255, 255)) # 通过指定的文件名加载图像 ball_image = pygame.image.load('./res/ball.png') # 在窗口上渲染图像 screen.blit(ball_image, (50, 50)) # 刷新当前窗口(渲染窗口将绘制的图像呈现出来) pygame.display.flip() running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = Falseif __name__ == '__main__': main() 实现动画效果说到动画这个词大家都不会陌生，事实上要实现动画效果，本身的原理也非常简单，就是将不连续的图片连续的播放，只要每秒钟达到了一定的帧数，那么就可以做出比较流畅的动画效果。如果要让上面代码中的小球动起来，可以将小球的位置用变量来表示，并在循环中修改小球的位置再刷新整个窗口即可。 1234567891011121314151617181920212223242526272829import pygamedef main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') # 定义变量来表示小球在屏幕上的位置 x, y = 50, 50 running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False screen.fill((255, 255, 255)) pygame.draw.circle(screen, (255, 0, 0,), (x, y), 30, 0) pygame.display.flip() # 每隔50毫秒就改变小球的位置再刷新窗口 pygame.time.delay(50) x, y = x + 5, y + 5if __name__ == '__main__': main() 碰撞检测通常一个游戏中会有很多对象出现，而这些对象之间的“碰撞”在所难免，比如炮弹击中了飞机、箱子撞到了地面等。碰撞检测在绝大多数的游戏中都是一个必须得处理的至关重要的问题，pygame的sprite（动画精灵）模块就提供了对碰撞检测的支持，这里我们暂时不介绍sprite模块提供的功能，因为要检测两个小球有没有碰撞其实非常简单，只需要检查球心的距离有没有小于两个球的半径之和。为了制造出更多的小球，我们可以通过对鼠标事件的处理，在点击鼠标的位置创建颜色、大小和移动速度都随机的小球，当然要做到这一点，我们可以把之前学习到的面向对象的知识应用起来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from enum import Enum, uniquefrom math import sqrtfrom random import randintimport pygame@uniqueclass Color(Enum): """颜色""" RED = (255, 0, 0) GREEN = (0, 255, 0) BLUE = (0, 0, 255) BLACK = (0, 0, 0) WHITE = (255, 255, 255) GRAY = (242, 242, 242) @staticmethod def random_color(): """获得随机颜色""" r = randint(0, 255) g = randint(0, 255) b = randint(0, 255) return (r, g, b)class Ball(object): """球""" def __init__(self, x, y, radius, sx, sy, color=Color.RED): """初始化方法""" self.x = x self.y = y self.radius = radius self.sx = sx self.sy = sy self.color = color self.alive = True def move(self, screen): """移动""" self.x += self.sx self.y += self.sy if self.x - self.radius &lt;= 0 or \ self.x + self.radius &gt;= screen.get_width(): self.sx = -self.sx if self.y - self.radius &lt;= 0 or \ self.y + self.radius &gt;= screen.get_height(): self.sy = -self.sy def eat(self, other): """吃其他球""" if self.alive and other.alive and self != other: dx, dy = self.x - other.x, self.y - other.y distance = sqrt(dx ** 2 + dy ** 2) if distance &lt; self.radius + other.radius \ and self.radius &gt; other.radius: other.alive = False a self.radius = self.radius + int(other.radius * 0.146) def draw(self, screen): """在窗口上绘制球""" pygame.draw.circle(screen, self.color, (self.x, self.y), self.radius, 0) 事件处理可以在事件循环中对鼠标事件进行处理，通过事件对象的type属性可以判定事件类型，再通过pos属性就可以获得鼠标点击的位置。如果要处理键盘事件也是在这个地方，做法与处理鼠标事件类似。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546def main(): # 定义用来装所有球的容器 balls = [] # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False # 处理鼠标事件的代码 if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1: # 获得点击鼠标的位置 x, y = event.pos radius = randint(10, 100) sx, sy = randint(-10, 10), randint(-10, 10) color = Color.random_color() # 在点击鼠标的位置创建一个球(大小、速度和颜色随机) ball = Ball(x, y, radius, sx, sy, color) # 将球添加到列表容器中 balls.append(ball) screen.fill((255, 255, 255)) # 取出容器中的球 如果没被吃掉就绘制 被吃掉了就移除 for ball in balls: if ball.alive: ball.draw(screen) else: balls.remove(ball) pygame.display.flip() # 每隔50毫秒就改变球的位置再刷新窗口 pygame.time.delay(50) for ball in balls: ball.move(screen) # 检查球有没有吃到其他的球 for other in balls: ball.eat(other)if __name__ == '__main__': main() 上面的两段代码合在一起，我们就完成了“大球吃小球”的游戏（如下图所示），准确的说它算不上一个游戏，但是做一个小游戏的基本知识我们已经通过这个例子告诉大家了，有了这些知识已经可以开始你的小游戏开发之旅了。其实上面的代码中还有很多值得改进的地方，比如刷新窗口以及让球移动起来的代码并不应该放在事件循环中，等学习了多线程的知识后，用一个后台线程来处理这些事可能是更好的选择。如果希望获得更好的用户体验，我们还可以在游戏中加入背景音乐以及在球与球发生碰撞时播放音效，利用pygame的mixer和music模块，我们可以很容易的做到这一点，大家可以自行了解这方面的知识。事实上，想了解更多的关于pygame的知识，最好的教程是pygame的官方网站，如果英语没毛病就可以赶紧去看看啦。 如果想开发3D游戏，pygame就显得力不从心了，对3D游戏开发如果有兴趣的读者不妨看看Panda3D。 文件和异常在实际开发中，常常需要对程序中的数据进行持久化操作，而实现数据持久化最直接简单的方式就是将数据保存到文件中。说到“文件”这个词，可能需要先科普一下关于文件系统的知识，对于这个概念，维基百科上给出了很好的诠释，这里不再浪费笔墨。 在Python中实现文件的读写操作其实非常简单，通过Python内置的open函数，我们可以指定文件名、操作模式、编码信息等来获得操作文件的对象，接下来就可以对文件进行读写操作了。这里所说的操作模式是指要打开什么样的文件（字符文件还是二进制文件）以及做什么样的操作（读、写还是追加），具体的如下表所示。 操作模式 具体含义 &#39;r&#39; 读取 （默认） &#39;w&#39; 写入（会先截断之前的内容） &#39;x&#39; 写入，如果文件已经存在会产生异常 &#39;a&#39; 追加，将内容写入到已有文件的末尾 &#39;b&#39; 二进制模式 &#39;t&#39; 文本模式（默认） &#39;+&#39; 更新（既可以读又可以写） 读写文本文件读取文本文件时，需要在使用open函数时指定好带路径的文件名（可以使用相对路径或绝对路径）并将文件模式设置为&#39;r&#39;（如果不指定，默认值也是&#39;r&#39;），然后通过encoding参数指定编码（如果不指定，默认值是None，那么在读取文件时使用的是操作系统默认的编码），如果不能保证保存文件时使用的编码方式与encoding参数指定的编码方式是一致的，那么就可能因无法解码字符而导致读取失败。下面的例子演示了如何读取一个纯文本文件。 12345678def main(): f = open('致橡树.txt', 'r', encoding='utf-8') print(f.read()) f.close()if __name__ == '__main__': main() 请注意上面的代码，如果open函数指定的文件并不存在或者无法打开，那么将引发异常状况导致程序崩溃。为了让代码有一定的健壮性和容错性，我们可以使用Python的异常机制对可能在运行时发生状况的代码进行适当的处理，如下所示。 123456789101112131415161718def main(): f = None try: f = open('致橡树.txt', 'r', encoding='utf-8') print(f.read()) except FileNotFoundError: print('无法打开指定的文件!') except LookupError: print('指定了未知的编码!') except UnicodeDecodeError: print('读取文件时解码错误!') finally: if f: f.close()if __name__ == '__main__': main() 在Python中，我们可以将那些在运行时可能会出现状况的代码放在try代码块中，在try代码块的后面可以跟上一个或多个except来捕获可能出现的异常状况。例如在上面读取文件的过程中，文件找不到会引发FileNotFoundError，指定了未知的编码会引发LookupError，而如果读取文件时无法按指定方式解码会引发UnicodeDecodeError，我们在try后面跟上了三个except分别处理这三种不同的异常状况。最后我们使用finally代码块来关闭打开的文件，释放掉程序中获取的外部资源，由于finally块的代码不论程序正常还是异常都会执行到（甚至是调用了sys模块的exit函数退出Python环境，finally块都会被执行，因为exit函数实质上是引发了SystemExit异常），因此我们通常把finally块称为“总是执行代码块”，它最适合用来做释放外部资源的操作。如果不愿意在finally代码块中关闭文件对象释放资源，也可以使用上下文语法，通过with关键字指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源，代码如下所示。 1234567891011121314def main(): try: with open('致橡树.txt', 'r', encoding='utf-8') as f: print(f.read()) except FileNotFoundError: print('无法打开指定的文件!') except LookupError: print('指定了未知的编码!') except UnicodeDecodeError: print('读取文件时解码错误!')if __name__ == '__main__': main() 除了使用文件对象的read方法读取文件之外，还可以使用for-in循环逐行读取或者用readlines方法将文件按行读取到一个列表容器中，代码如下所示。 1234567891011121314151617181920212223import timedef main(): # 一次性读取整个文件内容 with open('致橡树.txt', 'r', encoding='utf-8') as f: print(f.read()) # 通过for-in循环逐行读取 with open('致橡树.txt', mode='r') as f: for line in f: print(line, end='') time.sleep(0.5) print() # 读取文件按行读取到列表中 with open('致橡树.txt') as f: lines = f.readlines() print(lines) if __name__ == '__main__': main() 要将文本信息写入文件文件也非常简单，在使用open函数时指定好文件名并将文件模式设置为&#39;w&#39;即可。注意如果需要对文件内容进行追加式写入，应该将模式设置为&#39;a&#39;。如果要写入的文件不存在会自动创建文件而不是引发异常。下面的例子演示了如何将1~9999直接的素数分别写入三个文件中（1~99之间的素数保存在a.txt中，100~999之间的素数保存在b.txt中，1000~9999之间的素数保存在c.txt中）。 12345678910111213141516171819202122232425262728293031323334353637from math import sqrtdef is_prime(n): """判断素数的函数""" assert n &gt; 0 for factor in range(2, int(sqrt(n)) + 1): if n % factor == 0: return False return True if n != 1 else Falsedef main(): filenames = ('a.txt', 'b.txt', 'c.txt') fs_list = [] try: for filename in filenames: fs_list.append(open(filename, 'w', encoding='utf-8')) for number in range(1, 10000): if is_prime(number): if number &lt; 100: fs_list[0].write(str(number) + '\n') elif number &lt; 1000: fs_list[1].write(str(number) + '\n') else: fs_list[2].write(str(number) + '\n') except IOError as ex: print(ex) print('写文件时发生错误!') finally: for fs in fs_list: fs.close() print('操作完成!')if __name__ == '__main__': main() 读写二进制文件知道了如何读写文本文件要读写二进制文件也就很简单了，下面的代码实现了复制图片文件的功能。 12345678910111213141516def main(): try: with open('guido.jpg', 'rb') as fs1: data = fs1.read() print(type(data)) # &lt;class 'bytes'&gt; with open('吉多.jpg', 'wb') as fs2: fs2.write(data) except FileNotFoundError as e: print('指定的文件无法打开.') except IOError as e: print('读写文件时出现错误.') print('程序执行结束.')if __name__ == '__main__': main() 读写JSON文件通过上面的讲解，我们已经知道如何将文本数据和二进制数据保存到文件中，那么这里还有一个问题，如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存。JSON是“JavaScript Object Notation”的缩写，它本来是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的。目前JSON基本上已经取代了XML作为异构系统间交换数据的事实标准。关于JSON的知识，更多的可以参考JSON的官方网站，从这个网站也可以了解到每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个JSON的简单例子。 1234567891011&#123; 'name': '骆昊', 'age': 38, 'qq': 957658, 'friends': ['王大锤', '白元芳'], 'cars': [ &#123;'brand': 'BYD', 'max_speed': 180&#125;, &#123;'brand': 'Audi', 'max_speed': 280&#125;, &#123;'brand': 'Benz', 'max_speed': 320&#125; ]&#125; 可能大家已经注意到了，上面的JSON跟Python中的字典其实是一样一样的，事实上JSON的数据类型和Python的数据类型是很容易找到对应关系的，如下面两张表所示。 JSON Python object dict array list string str number (int / real) int / float true / false True / False null None Python JSON dict object list, tuple array str string int, float, int- &amp; float-derived Enums number True / False true / false None null 我们使用Python中的json模块就可以将字典或列表以JSON格式保存到文件中，代码如下所示。 12345678910111213141516171819202122232425import jsondef main(): mydict = &#123; 'name': '骆昊', 'age': 38, 'qq': 957658, 'friends': ['王大锤', '白元芳'], 'cars': [ &#123;'brand': 'BYD', 'max_speed': 180&#125;, &#123;'brand': 'Audi', 'max_speed': 280&#125;, &#123;'brand': 'Benz', 'max_speed': 320&#125; ] &#125; try: with open('data.json', 'w', encoding='utf-8') as fs: json.dump(mydict, fs) except IOError as e: print(e) print('保存数据完成!')if __name__ == '__main__': main() json模块主要有四个比较重要的函数，分别是： dump - 将Python对象按照JSON格式序列化到文件中 dumps - 将Python对象处理成JSON格式的字符串 load - 将文件中的JSON数据反序列化成对象 loads - 将字符串的内容反序列化成Python对象 这里出现了两个概念，一个叫序列化，一个叫反序列化。自由的百科全书维基百科上对这两个概念是这样解释的：“序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化（deserialization）”。 目前绝大多数网络数据服务（或称之为网络API）都是基于HTTP协议提供JSON格式的数据，关于HTTP协议的相关知识，可以看看阮一峰老师的《HTTP协议入门》，如果想了解国内的网络数据服务，可以看看聚合数据和阿凡达数据等网站，国外的可以看看{API}Search网站。下面的例子演示了如何使用requests模块（封装得足够好的第三方网络访问模块）访问网络API获取国内新闻，如何通过json模块解析JSON数据并显示新闻标题，这个例子使用了天行数据提供的国内新闻数据接口，其中的APIKey需要自己到该网站申请。 12345678910111213import requestsimport jsondef main(): resp = requests.get('http://api.tianapi.com/guonei/?key=APIKey&amp;num=10') data_model = json.loads(resp.text) for news in data_model['newslist']: print(news['title'])if __name__ == '__main__': main() 在Python中要实现序列化和反序列化除了使用json模块之外，还可以使用pickle和shelve模块，但是这两个模块是使用特有的序列化协议来序列化数据，因此序列化后的数据只能被Python识别。关于这两个模块的相关知识可以自己看看网络上的资料。另外，如果要了解更多的关于Python异常机制的知识，可以看看segmentfault上面的文章《总结：Python中的异常处理》，这篇文章不仅介绍了Python中异常机制的使用，还总结了一系列的最佳实践，很值得一读。 使用正则表达式正则表达式相关知识在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。 我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。 关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫《正则表达式30分钟入门教程》，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \w 匹配字母/数字/下划线 b\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \s 匹配空白字符（包括\r、\n、\t等） love\syou 可以匹配love you \d 匹配数字 \d\d 可以匹配01 / 23 / 99等 \b 匹配单词的边界 \bThe\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 $ 匹配字符串的结束 .exe$ 可以匹配.exe结尾的字符串 \W 匹配非字母/数字/下划线 b\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \S 匹配非空白字符 love\Syou 可以匹配love#you等但不能匹配love you \D 匹配非数字 \d\D 可以匹配9a / 3# / 0F等 \B 匹配非单词边界 \Bio\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 [^] 匹配不在字符集中的任意单一字符 [^aeiou] 可以匹配任一非元音字母字符 * 匹配0次或多次 \w* + 匹配1次或多次 \w+ ? 匹配0次或1次 \w? {N} 匹配N次 \w{3} {M,} 匹配至少M次 \w{3,} {M,N} 匹配至少M次至多N次 \w{3,6} \ 分支 foo\ bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?&lt;name&gt;exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \b\w+(?=ing) 可以匹配I’m dancing中的danc (?&lt;=exp) 匹配exp后面的位置 (?&lt;=\bdanc)\w+\b 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.*ba.*?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 说明：如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\(和\)，否则圆括号被视为正则表达式中的分组。 Python对正则表达式的支持Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记 说明：上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。 下面我们通过一系列的例子来告诉大家在Python中如何使用正则表达式。 例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。123456789101112131415161718192021222324252627282930"""验证输入用户名和QQ号是否有效并给出对应的提示信息要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间QQ号是5~12的数字且首位不能为0"""import redef main(): username = input('请输入用户名: ') qq = input('请输入QQ号: ') # match函数的第一个参数是正则表达式字符串或正则表达式对象 # 第二个参数是要跟正则表达式做匹配的字符串对象 m1 = re.match(r'^[0-9a-zA-Z_]&#123;6,20&#125;$', username) if not m1: print('请输入有效的用户名.') m2 = re.match(r'^[1-9]\d&#123;4,11&#125;$', qq) if not m2: print('请输入有效的QQ号.') if m1 and m2: print('你输入的信息是有效的!')if __name__ == '__main__': main() 提示：上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\，例如表示数字的\d得书写成\\d，这样不仅写起来不方便，阅读的时候也会很吃力。 例子2：从一段文字中提取出国内手机号码。123456789101112131415161718192021222324252627import redef main(): # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字 pattern = re.compile(r'(?&lt;=\D)1[34578]\d&#123;9&#125;(?=\D)') sentence = ''' 重要的事情说8130123456789遍，我的手机号是13512346789这个靓号， 不是15600998765，也是110或119，王大锤的手机号才是15600998765。 ''' # 查找所有匹配并保存到一个列表中 mylist = re.findall(pattern, sentence) print(mylist) print('--------华丽的分隔线--------') # 通过迭代器取出匹配对象并获得匹配的内容 for temp in pattern.finditer(sentence): print(temp.group()) print('--------华丽的分隔线--------') # 通过search函数指定搜索位置找出所有匹配 m = pattern.search(sentence) while m: print(m.group()) m = pattern.search(sentence, m.end())if __name__ == '__main__': main() 说明：上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：(?&lt;=\D)(1[38]\d{9}|14[57]\d{8}|15[0-35-9]\d{8}|17[678]\d{8})(?=\D)，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。 例子3：替换字符串中的不良内容123456789101112import redef main(): sentence = '你丫是傻叉吗? 我操你大爷的. Fuck you.' purified = re.sub('[操肏艹草曹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔', '*', sentence, flags=re.IGNORECASE) print(purified) # 你丫是*吗? 我*你大爷的. * you.if __name__ == '__main__': main() 说明：re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M。 例子4：拆分长字符串12345678910111213import redef main(): poem = '窗前明月光，疑是地上霜。举头望明月，低头思故乡。' sentence_list = re.split(r'[，。, .]', poem) while '' in sentence_list: sentence_list.remove('') print(sentence_list) # ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡']if __name__ == '__main__': main() 后话如果要从事爬虫类应用的开发，那么正则表达式一定是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，当然对于初学者来收，要编写一个正确的适当的正则表达式可能并不是一件容易的事情（当然有些常用的正则表达式可以直接在网上找找），所以实际开发爬虫应用的时候，有很多人会选择Beautiful Soup或Lxml来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦，这些内容我们会在后期的爬虫专题中为大家介绍。 进程和线程今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。 概念进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。 一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如macOS中的“活动监视器”、Windows中的“任务管理器”）来证实. 当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。 Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。 Python中的多进程Unix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。fork()函数非常特殊它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了fork()函数。由于Windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（Pool）、用于进程间通信的队列（Queue）和管道（Pipe）等。 下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。 123456789101112131415161718192021from random import randintfrom time import time, sleepdef download_task(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main(): start = time() download_task('Python从入门到住院.pdf') download_task('Peking Hot.avi') end = time() print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__': main() 下面是运行程序得到的一次运行结果。 12345开始下载Python从入门到住院.pdf...Python从入门到住院.pdf下载完成! 耗费了6秒开始下载Peking Hot.avi...Peking Hot.avi下载完成! 耗费了7秒总共耗费了13.01秒. 从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。 12345678910111213141516171819202122232425262728from multiprocessing import Processfrom os import getpidfrom random import randintfrom time import time, sleepdef download_task(filename): print('启动下载进程，进程号[%d].' % getpid()) print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main(): start = time() p1 = Process(target=download_task, args=('Python从入门到住院.pdf', )) p1.start() p2 = Process(target=download_task, args=('Peking Hot.avi', )) p2.start() p1.join() p2.join() end = time() print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__': main() 在上面的代码中，我们通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，而join方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。 1234567启动下载进程，进程号[1530].开始下载Python从入门到住院.pdf...启动下载进程，进程号[1531].开始下载Peking Hot.avi...Peking Hot.avi下载完成! 耗费了7秒Python从入门到住院.pdf下载完成! 耗费了10秒总共耗费了10.01秒. 我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。 123456789101112131415161718192021from multiprocessing import Processfrom time import sleepcounter = 0def sub_task(string): global counter while counter &lt; 10: print(string, end='', flush=True) counter += 1 sleep(0.01) def main(): Process(target=sub_task, args=('Ping', )).start() Process(target=sub_task, args=('Pong', )).start()if __name__ == '__main__': main() 看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个counter变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的Queue类，它是可以被多个进程共享的队列，底层是通过管道和信号量（semaphore）机制来实现的，有兴趣的读者可以自己尝试一下。 Python中的多线程在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。 1234567891011121314151617181920212223242526from random import randintfrom threading import Threadfrom time import time, sleepdef download(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main(): start = time() t1 = Thread(target=download, args=('Python从入门到住院.pdf',)) t1.start() t2 = Thread(target=download, args=('Peking Hot.avi',)) t2.start() t1.join() t2.join() end = time() print('总共耗费了%.3f秒' % (end - start))if __name__ == '__main__': main() 我们可以直接使用threading模块的Thread类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承Thread类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。 1234567891011121314151617181920212223242526272829303132from random import randintfrom threading import Threadfrom time import time, sleepclass DownloadTask(Thread): def __init__(self, filename): super().__init__() self._filename = filename def run(self): print('开始下载%s...' % self._filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (self._filename, time_to_download))def main(): start = time() t1 = DownloadTask('Python从入门到住院.pdf') t1.start() t2 = DownloadTask('Peking Hot.avi') t2.start() t1.join() t2.join() end = time() print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__': main() 因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from time import sleepfrom threading import Threadclass Account(object): def __init__(self): self._balance = 0 def deposit(self, money): # 计算存款后的余额 new_balance = self._balance + money # 模拟受理存款业务需要0.01秒的时间 sleep(0.01) # 修改账户余额 self._balance = new_balance @property def balance(self): return self._balanceclass AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money)def main(): account = Account() threads = [] # 创建100个存款的线程向同一个账户中存钱 for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() # 等所有存款的线程都执行完毕 for t in threads: t.join() print('账户余额为: ￥%d元' % account.balance)if __name__ == '__main__': main() 运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到new_balance = self._balance + money这行代码，多个线程得到的账户余额都是初始状态下的0，所以都是0上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from time import sleepfrom threading import Thread, Lockclass Account(object): def __init__(self): self._balance = 0 self._lock = Lock() def deposit(self, money): # 先获取锁才能执行后续的代码 self._lock.acquire() try: new_balance = self._balance + money sleep(0.01) self._balance = new_balance finally: # 在finally中执行释放锁的操作保证正常异常锁都能释放 self._lock.release() @property def balance(self): return self._balanceclass AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money)def main(): account = Account() threads = [] for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() for t in threads: t.join() print('账户余额为: ￥%d元' % account.balance)if __name__ == '__main__': main() 比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。 多进程还是多线程无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。 但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。 是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到了Python中有嵌入C/C++代码的机制。 除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。 说明：上面的内容和例子来自于廖雪峰官方网站的《Python教程》，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。 单线程+异步I/O现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下实现多任务编程的一种趋势。 在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，我稍后会做一个专题来进行讲解。 应用案例例子1：将耗时间的任务放到线程中以获得更好的用户体验。如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验，代码如下所示。 123456789101112131415161718192021222324252627282930313233import timeimport tkinterimport tkinter.messageboxdef download(): # 模拟下载任务需要花费10秒钟时间 time.sleep(10) tkinter.messagebox.showinfo('提示', '下载完成!')def show_about(): tkinter.messagebox.showinfo('关于', '作者: 骆昊(v1.0)')def main(): top = tkinter.Tk() top.title('单线程') top.geometry('200x150') top.wm_attributes('-topmost', True) panel = tkinter.Frame(top) button1 = tkinter.Button(panel, text='下载', command=download) button1.pack(side='left') button2 = tkinter.Button(panel, text='关于', command=show_about) button2.pack(side='right') panel.pack(side='bottom') tkinter.mainloop()if __name__ == '__main__': main() 如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243import timeimport tkinterimport tkinter.messageboxfrom threading import Threaddef main(): class DownloadTaskHandler(Thread): def run(self): time.sleep(10) tkinter.messagebox.showinfo('提示', '下载完成!') # 启用下载按钮 button1.config(state=tkinter.NORMAL) def download(): # 禁用下载按钮 button1.config(state=tkinter.DISABLED) # 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行) # 在线程中处理耗时间的下载任务 DownloadTaskHandler(daemon=True).start() def show_about(): tkinter.messagebox.showinfo('关于', '作者: 骆昊(v1.0)') top = tkinter.Tk() top.title('单线程') top.geometry('200x150') top.wm_attributes('-topmost', 1) panel = tkinter.Frame(top) button1 = tkinter.Button(panel, text='下载', command=download) button1.pack(side='left') button2 = tkinter.Button(panel, text='关于', command=show_about) button2.pack(side='right') panel.pack(side='bottom') tkinter.mainloop()if __name__ == '__main__': main() 例子2：使用多进程对复杂任务进行“分而治之”。我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。 12345678910111213141516from time import timedef main(): total = 0 number_list = [x for x in range(1, 100000001)] start = time() for number in number_list: total += number print(total) end = time() print('Execution time: %.3fs' % (end - start))if __name__ == '__main__': main() 在上面的代码中，我故意先去创建了一个列表容器然后填入了100000000个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到8个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839from multiprocessing import Process, Queuefrom random import randintfrom time import timedef task_handler(curr_list, result_queue): total = 0 for number in curr_list: total += number result_queue.put(total)def main(): processes = [] number_list = [x for x in range(1, 100000001)] result_queue = Queue() index = 0 # 启动8个进程将数据切片后进行运算 for _ in range(8): p = Process(target=task_handler, args=(number_list[index:index + 12500000], result_queue)) index += 12500000 processes.append(p) p.start() # 开始记录所有进程执行完成花费的时间 start = time() for p in processes: p.join() # 合并执行结果 total = 0 while not result_queue.empty(): total += result_queue.get() print(total) end = time() print('Execution time: ', (end - start), 's', sep='')if __name__ == '__main__': main() 比较两段代码的执行结果（在我目前使用的MacBook上，上面的代码需要大概6秒左右的时间，而下面的代码只需要不到1秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的CPU执行时间以及更好的利用了CPU的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过multiprocessing.managers模块中提供的管理器将Queue对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。 网络编程入门计算机网络基础计算机网络是独立自主的计算机互联而成的系统的总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。今天计算机网络中的设备和计算机网络的用户已经多得不可计数，而计算机网络也可以称得上是一个“复杂巨系统”，对于这样的系统，我们不可能用一两篇文章把它讲清楚，有兴趣的读者可以自行阅读Andrew S.Tanenbaum老师的经典之作《计算机网络》或Kurose和Ross老师合著的《计算机网络:自顶向下方法》来了解计算机网络的相关知识。 计算机网络发展史 1960s - 美国国防部ARPANET项目问世，奠定了分组交换网络的基础。 1980s - 国际标准化组织（ISO）发布OSI/RM，奠定了网络技术标准化的基础。 1990s - 英国人蒂姆·伯纳斯-李发明了图形化的浏览器，浏览器的简单易用性使得计算机网络迅速被普及。 TCP/IP模型实现网络通信的基础是网络通信协议，这些协议通常是由互联网工程任务组 （IETF）制定的。所谓“协议”就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接、怎样互相识别等，网络协议的三要素是：语法、语义和时序。构成我们今天使用的Internet的基础的是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，我们通常也把这套东西称为TCP/IP模型。与国际标准化组织发布的OSI/RM这个七层模型不同，TCP/IP是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层. IP通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。当然由于IPv4地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是一个局域网（LAN）中的内部IP地址，通过网络地址转换（NAT）服务我们也可以实现对网络的访问。计算机网络上有大量的被我们称为“路由器”的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送到目的地通路，这项功能就是所谓的路由。 TCP全称传输控制协议，它是基于IP提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP称为可靠的传输协议是因为TCP向调用者承诺了三件事情： 数据不传丢不传错（利用握手、校验和重传机制可以实现）。 流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）。 拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）。 网络应用模式 C/S模式和B/S模式。这里的C指的是Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；而B指的是Browser（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过C或B都可以实现对S（服务器）的访问。关于二者的比较和讨论在网络上有一大堆的文章，在此我们就不再浪费笔墨了。 去中心化的网络应用模式。不管是B/S还是C/S都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。 基于HTTP协议的网络资源访问HTTP（超文本传输协议）HTTP是超文本传输协议（Hyper-Text Transfer Proctol）的简称，维基百科上对HTTP的解释是：超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，它是万维网数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，通过HTTP或者HTTPS（超文本传输安全协议）请求的资源由URI（统一资源标识符）来标识。关于HTTP的更多内容，我们推荐阅读阮一峰老师的《HTTP 协议入门》，简单的说，通过HTTP我们可以获取网络上的（基于字符的）资源，开发中经常会用到的网络API（有的地方也称之为网络数据接口）就是基于HTTP来实现数据传输的。 JSON格式JSON（JavaScript Object Notation）是一种轻量级的数据交换语言，该语言以易于让人阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是最初只是Javascript中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持JSON格式数据的生成和解析，Python内置的json模块也提供了这方面的功能。由于JSON是纯文本，它和XML一样都适用于异构系统之间的数据交换，而相较于XML，JSON显得更加的轻便和优雅。下面是表达同样信息的XML和JSON，而JSON的优势是相当直观的。 XML的例子： 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;message&gt; &lt;from&gt;Alice&lt;/from&gt; &lt;to&gt;Bob&lt;/to&gt; &lt;content&gt;Will you marry me?&lt;/content&gt;&lt;/message&gt; JSON的例子： 12345&#123; 'from': 'Alice', 'to': 'Bob', 'content': 'Will you marry me?'&#125; requests库requests是一个基于HTTP协议来使用网络的第三库，其官方网站有这样的一句介绍它的话：“Requests是唯一的一个非转基因的Python HTTP库，人类可以安全享用。”简单的说，使用requests库可以非常方便的使用HTTP，避免安全缺陷、冗余代码以及“重复发明轮子”（行业黑话，通常用在软件工程领域表示重新创造一个已有的或是早已被优化過的基本方法）。前面的文章中我们已经使用过这个库，下面我们还是通过requests来实现一个访问网络数据接口并从中获取美女图片下载链接然后下载美女图片到本地的例子程序，程序中使用了天行数据提供的网络API。 我们可以先通过pip安装requests及其依赖库。 1pip install requests 如果使用PyCharm作为开发工具，可以直接在代码中书写import requests，然后通过代码修复功能来自动下载安装requests。 12345678910111213141516171819202122232425262728293031323334353637from time import timefrom threading import Threadimport requests# 继承Thread类创建自定义的线程类class DownloadHanlder(Thread): def __init__(self, url): super().__init__() self.url = url def run(self): filename = self.url[self.url.rfind('/') + 1:] resp = requests.get(self.url) with open('/Users/Hao/' + filename, 'wb') as f: f.write(resp.content)def main(): # 通过requests模块的get函数获取网络资源 # 下面的代码中使用了天行数据接口提供的网络API # 要使用该数据接口需要在天行数据的网站上注册 # 然后用自己的Key替换掉下面代码的中APIKey即可 resp = requests.get( 'http://api.tianapi.com/meinv/?key=APIKey&amp;num=10') # 将服务器返回的JSON格式的数据解析为字典 data_model = resp.json() for mm_dict in data_model['newslist']: url = mm_dict['picUrl'] # 通过多线程的方式实现图片下载 DownloadHanlder(url).start()if __name__ == '__main__': main() 基于传输层协议的套接字编程套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。 TCP套接字所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。 下面的代码实现了一个提供时间日期的服务器。 12345678910111213141516171819202122232425262728293031323334from socket import socket, SOCK_STREAM, AF_INETfrom datetime import datetimedef main(): # 1.创建套接字对象并指定使用哪种传输服务 # family=AF_INET - IPv4地址 # family=AF_INET6 - IPv6地址 # type=SOCK_STREAM - TCP套接字 # type=SOCK_DGRAM - UDP套接字 # type=SOCK_RAW - 原始套接字 server = socket(family=AF_INET, type=SOCK_STREAM) # 2.绑定IP地址和端口(端口用于区分不同的服务) # 同一时间在同一个端口上只能绑定一个服务否则报错 server.bind(('192.168.1.2', 6789)) # 3.开启监听 - 监听客户端连接到服务器 # 参数512可以理解为连接队列的大小 server.listen(512) print('服务器启动开始监听...') while True: # 4.通过循环接收客户端的连接并作出相应的处理(提供服务) # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行 # accept方法返回一个元组其中的第一个元素是客户端对象 # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成) client, addr = server.accept() print(str(addr) + '连接到了服务器.') # 5.发送数据 client.send(str(datetime.now()).encode('utf-8')) # 6.断开连接 client.close()if __name__ == '__main__': main() 运行服务器程序后我们可以通过Windows系统的telnet来访问该服务器。 1telnet 192.168.1.2 6789 当然我们也可以通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。 123456789101112131415from socket import socketdef main(): # 1.创建套接字对象默认使用IPv4和TCP协议 client = socket() # 2.连接到服务器(需要指定IP地址和端口) client.connect(('192.168.1.2', 6789)) # 3.从服务器接收数据 print(client.recv(1024).decode('utf-8')) client.close()if __name__ == '__main__': main() 需要注意的是，上面的服务器并没有使用多线程或者异步I/O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。 服务器端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from socket import socket, SOCK_STREAM, AF_INETfrom base64 import b64encodefrom json import dumpsfrom threading import Threaddef main(): # 自定义线程类 class FileTransferHandler(Thread): def __init__(self, cclient): super().__init__() self.cclient = cclient def run(self): my_dict = &#123;&#125; my_dict['filename'] = 'guido.jpg' # JSON是纯文本不能携带二进制数据 # 所以图片的二进制数据要处理成base64编码 my_dict['filedata'] = data # 通过dumps函数将字典处理成JSON字符串 json_str = dumps(my_dict) # 发送JSON字符串 self.cclient.send(json_str.encode('utf-8')) self.cclient.close() # 1.创建套接字对象并指定使用哪种传输服务 server = socket() # 2.绑定IP地址和端口(区分不同的服务) server.bind(('192.168.1.2', 5566)) # 3.开启监听 - 监听客户端连接到服务器 server.listen(512) print('服务器启动开始监听...') with open('guido.jpg', 'rb') as f: # 将二进制数据处理成base64再解码成字符串 data = b64encode(f.read()).decode('utf-8') while True: client, addr = server.accept() # 启动一个线程来处理客户端的请求 FileTransferHandler(client).start()if __name__ == '__main__': main() 客户端代码： 1234567891011121314151617181920212223242526272829from socket import socketfrom json import loadsfrom base64 import b64decodedef main(): client = socket() client.connect(('192.168.1.2', 5566)) # 定义一个保存二进制数据的对象 in_data = bytes() # 由于不知道服务器发送的数据有多大每次接收1024字节 data = client.recv(1024) while data: # 将收到的数据拼接起来 in_data += data data = client.recv(1024) # 将收到的二进制数据解码成JSON字符串并转换成字典 # loads函数的作用就是将JSON字符串转成字典对象 my_dict = loads(in_data.decode('utf-8')) filename = my_dict['filename'] filedata = my_dict['filedata'].encode('utf-8') with open('/Users/Hao/' + filename, 'wb') as f: # 将base64格式的数据解码成二进制数据并写入文件 f.write(b64decode(filedata)) print('图片已保存.')if __name__ == '__main__': main() 在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从000000到111111的64种状态。维基百科上有关于Base64编码的详细讲解，不熟悉Base64的读者可以自行阅读。 说明：上面的代码主要为了讲解网络编程的相关内容因此并没有对异常状况进行处理，请读者自行添加异常处理代码来增强程序的健壮性。 UDP套接字传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。在Python中也可以使用UDP套接字来创建网络应用，对此我们不进行赘述，有兴趣的读者可以自行研究。 网络应用开发发送电子邮件在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。 就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。 下面的代码演示了如何在Python发送邮件。 12345678910111213141516171819202122from smtplib import SMTPfrom email.header import Headerfrom email.mime.text import MIMETextdef main(): # 请自行修改下面的邮件发送者和接收者 sender = 'abcdefg@126.com' receivers = ['uvwxyz@qq.com', 'uvwxyz@126.com'] message = MIMEText('用Python发送邮件的示例代码.', 'plain', 'utf-8') message['From'] = Header('王大锤', 'utf-8') message['To'] = Header('骆昊', 'utf-8') message['Subject'] = Header('示例代码实验邮件', 'utf-8') smtper = SMTP('smtp.126.com') # 请自行修改下面的登录口令 smtper.login(sender, 'secretpass') smtper.sendmail(sender, receivers, message.as_string()) print('邮件发送完成!')if __name__ == '__main__': main() 如果要发送带有附件的邮件，那么可以按照下面的方式进行操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from smtplib import SMTPfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartimport urllibdef main(): # 创建一个带附件的邮件消息对象 message = MIMEMultipart() # 创建文本内容 text_content = MIMEText('附件中有本月数据请查收', 'plain', 'utf-8') message['Subject'] = Header('本月数据', 'utf-8') # 将文本内容添加到邮件消息对象中 message.attach(text_content) # 读取文件并将文件作为附件添加到邮件消息对象中 with open('/Users/Hao/Desktop/hello.txt', 'rb') as f: txt = MIMEText(f.read(), 'base64', 'utf-8') txt['Content-Type'] = 'text/plain' txt['Content-Disposition'] = 'attachment; filename=hello.txt' message.attach(txt) # 读取文件并将文件作为附件添加到邮件消息对象中 with open('/Users/Hao/Desktop/汇总数据.xlsx', 'rb') as f: xls = MIMEText(f.read(), 'base64', 'utf-8') xls['Content-Type'] = 'application/vnd.ms-excel' xls['Content-Disposition'] = 'attachment; filename=month-data.xlsx' message.attach(xls) # 创建SMTP对象 smtper = SMTP('smtp.126.com') # 开启安全连接 # smtper.starttls() sender = 'abcdefg@126.com' receivers = ['uvwxyz@qq.com'] # 登录到SMTP服务器 # 请注意此处不是使用密码而是邮件客户端授权码进行登录 # 对此有疑问的读者可以联系自己使用的邮件服务器客服 smtper.login(sender, 'secretpass') # 发送邮件 smtper.sendmail(sender, receivers, message.as_string()) # 与邮件服务器断开连接 smtper.quit() print('发送完成!')if __name__ == '__main__': main() 发送短信发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了互亿无线短信平台（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。 1234567891011121314151617181920212223import urllib.parseimport http.clientimport jsondef main(): host = "106.ihuyi.com" sms_send_uri = "/webservice/sms.php?method=Submit" # 下面的参数需要填入自己注册的账号和对应的密码 params = urllib.parse.urlencode(&#123;'account': '你自己的账号', 'password' : '你自己的密码', 'content': '您的验证码是：147258。请不要把验证码泄露给其他人。', 'mobile': '接收者的手机号', 'format':'json' &#125;) print(params) headers = &#123;'Content-type': 'application/x-www-form-urlencoded', 'Accept': 'text/plain'&#125; conn = http.client.HTTPConnection(host, port=80, timeout=30) conn.request('POST', sms_send_uri, params, headers) response = conn.getresponse() response_str = response.read() jsonstr = response_str.decode('utf-8') print(json.loads(jsonstr)) conn.close()if __name__ == '__main__': main() Web前端概述HTML简史 1991年10月：一个非正式CERN（欧洲核子研究中心）文件首次公开18个HTML标签，这个文件的作者是物理学家蒂姆·伯纳斯-李，因此他是万维网的发明者，也是万维网联盟的主席。 1995年11月：HTML 2.0标准发布（RFC 1866）。 1997年1月：HTML 3.2作为W3C推荐标准发布。 1997年12月：HTML 4.0作为W3C推荐标准发布。 1999年12月：HTML4.01作为W3C推荐标准发布。 2008年1月：HTML5由W3C作为工作草案发布。 2011年5月：W3C将HTML5推进至“最终征求”（Last Call）阶段。 2012年12月：W3C指定HTML5作为“候选推荐”阶段。 2014年10月：HTML5作为稳定W3C推荐标准发布，这意味着HTML5的标准化已经完成。 HTML5新特性 引入原生多媒体支持（audio和video标签） 引入可编程内容（canvas标签） 引入语义Web（article、aside、details、figure、footer、header、nav、section、summary等标签） 引入新的表单控件（日历、邮箱、搜索等） 引入对离线存储更好的支持 引入对定位、拖放、WebSocket、后台任务等的支持 使用标签承载内容结构 head title meta body 文本 标题和段落 粗体和斜体 上标和下标 空白（白色空间折叠） 折行和水平标尺 语义化标记 加粗和强调 引用 缩写词和首字母缩写词 引文 所有者联系信息 内容的修改 列表（list） 有序列表（ordered list） 无序列表（unordered list） 定义列表（definition list） 链接（anchor） 页面链接 锚链接 功能链接 图像（image） 图像存储位置 图像及其宽高 选择正确的图像格式 JPEG GIF PNG 矢量图 figure标签 表格（table） 基本的表格结构 表格的标题 跨行和跨列 长表格 表单（form） 如何收集信息 表单控件（input） 文本框 / 密码框 / 文本域 单选按钮 / 复选按钮 / 下拉列表 提交按钮 / 图像按钮 / 文件上传 组合表单元素 fieldset / legend HTML5的表单控件 日期 电子邮件 / URL 搜索 音视频（audio / video） 视频格式和播放器 视频托管服务 添加视频的准备工作 video标签和属性 audio标签和属性 其他 文档类型 注释 属性 id class 块级元素 / 行级元素 内联框架（internal frame） 页面信息（meta） 转义字符（实体替换符） 使用CSS渲染页面简介 CSS的作用 CSS的工作原理 规则、属性和值 颜色（color） 如何指定颜色 颜色术语和颜色对比 背景色 文本（text / font） 文本的大小和字型(font-size / font-family) 斜体、粗体、大写和下划线(font-weight / font-style / text-decoration) 行间距(line-height)、字母间距(letter-spacing)和单词间距(word-spacing) 对齐(text-align)方式和缩进(text-ident) 链接样式（:link / :visited / :active / :hover） CSS3新属性 投影 首字母和首行文本(p:first-letter / p:first-line) 响应用户 盒子（box model） 盒子大小的控制（width / height） 盒子的边框、外边距和内边距（border / margin / padding） 盒子的显示和隐藏（display / visibility） CSS3新属性 边框图像（border-image） 投影（border-shadow） 圆角（border-radius） 列表、表格和表单 列表的项目符号（list-style） 表格的边框和背景（border-collapse） 表单控件的外观 表单控件的对齐 浏览器的开发者工具 图像 控制图像的大小（display: inline-block） 对齐图像 背景图像（background / background-image / background-repeat / background-position） 布局 控制元素的位置（position / z-index） 普通流 相对定位 绝对定位 固定定位 浮动元素（float / clear） 网站布局 HTML5布局 适配屏幕尺寸 固定宽度布局 流体布局 布局网格 使用JavaScript控制行为JavaScript基本语法 语句和注释 变量和数据类型 声明和赋值 简单数据类型和复杂数据类型 变量的命名规则 表达式和运算符 赋值运算符 算术运算符 比较运算符 逻辑运算符 分支结构 if…else… switch…case…default… 循环结构 for循环 while循环 do…while循环 数组 创建数组 操作数组中的元素 函数 声明函数 调用函数 参数和返回值 匿名函数 立即调用函数 面向对象 对象的概念 创建对象的字面量语法 访问成员运算符 创建对象的构造函数语法 this关键字 添加和删除属性 delete关键字 全局对象 Number / String / Boolean Date / Math / RegEx / Array BOM window对象的属性和方法 history对象 forward() / back() / go() location对象 navigator对象 screen对象 DOM DOM树 访问元素 getElementById() / querySelector() getElementsByClassName() / getElementsByTagName() / querySelectorAll() parentNode / previousSibling / nextSibling / firstChild / lastChild 操作元素 nodeValue innerHTML / textContent / createElement() / createTextNode() / appendChild() / removeChild() className / id / hasAttribute() / getAttribute() / setAttribute() / removeAttribute() 事件处理 事件类型 UI事件：load / unload / error / resize / scroll 键盘事件：keydown / keyup / keypress 鼠标事件：click / dbclick / mousedown / mouseup / mousemove / mouseover / mouseout 焦点事件：focus / blur 表单事件：input / change / submit / reset / cut / copy / paste / select 事件绑定 HTML事件处理程序（不推荐使用，因为要做到标签与代码分离） 传统的DOM事件处理程序（只能附加一个回调函数） 事件监听器（旧的浏览器中不被支持） 事件流：事件捕获 / 事件冒泡 事件对象（低版本IE中的window.event） target（低版本IE中的srcElement） type cancelable preventDefault() stopPropagation()（低版本IE中的cancelBubble） 鼠标事件 - 事件发生的位置 屏幕位置：screenX和screenY 页面位置：pageX和pageY 客户端位置：clientX和clientY 键盘事件 - 哪个键被按下了 keyCode属性 String.fromCharCode(event.keyCode) HTML5事件 DOMContentLoaded hashchange beforeunload JavaScript API HTML5中的API：geolocation / localStorage / sessionStorage / history 使用jQueryjQuery概述 Write Less Do More（用更少的代码来完成更多的工作） 使用CSS选择器来查找元素（更简单更方便） 使用jQuery方法来操作元素（解决浏览器兼容性问题、应用于所有元素并施加多个方法） 引入jQuery 下载jQuery的开发版和压缩版 从CDN加载jQuery 12345&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; window.jQuery || document.write('&lt;script src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt;')&lt;/script&gt; 查找元素 选择器 * / element / #id / .class / selector1, selector2 ancestor descendant / parent&gt;child / previous+next / previous~siblings 筛选器 基本筛选器：:not(selector) / :first / :last / :even / :odd / :eq(index) / :gt(index) / :lt(index) / :animated / :focus 内容筛选器：:contains(‘…’) / :empty / :parent / :has(selector) 可见性筛选器：:hidden / :visible 子节点筛选器：:nth-child(expr) / :first-child / :last-child / :only-child 属性筛选器：[attribute] / [attribute=’value’] / [attribute!=’value’] / [attribute^=’value’] / [attribute$=’value’] / [attribute|=’value’] / [attribute~=’value’] 表单：:input / :text / :password / :radio / :checkbox / :submit / :image / :reset / :button / :file / :selected / :enabled / :disabled / :checked 执行操作 内容操作 获取/修改内容：html() / text() / replaceWith() / remove() 获取/设置元素：before() / after() / prepend() / append() / remove() / clone() / unwrap() / detach() / empty() / add() 获取/修改属性：attr() / removeAttr() / addClass() / removeClass() / css() 获取/设置表单值：val() 查找操作 查找方法：find() / parent() / children() / siblings() / next() / nextAll() / prev() / prevAll() 筛选器：filter() / not() / has() / is() / contains() 索引编号：eq() 尺寸和位置 尺寸相关：height() / width() / innerHeight() / innerWidth() / outerWidth() / outerHeight() 位置相关：offset() / position() / scrollLeft() / scrollTop() 特效和动画 基本动画：show() / hide() / toggle() 消失出现：fadeIn() / fadeOut() / fadeTo() / fadeToggle() 滑动效果：slideDown() / slideUp() / slideToggle() 自定义：delay() / stop() / animate() 事件 文档加载：ready() / load() 用户交互：on() / off() 链式操作检测页面是否可用12345&lt;script&gt; $(document).ready(function() &#123; &#125;);&lt;/script&gt; 12345&lt;script&gt; $(function() &#123; &#125;);&lt;/script&gt; jQuery插件 jQuery Validation jQuery Treeview jQuery Autocomplete jQuery UI 避免和其他库的冲突先引入其他库再引入jQuery的情况。 12345678&lt;script src="other.js"&gt;&lt;/script&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script&gt; jQuery.noConflict(); jQuery(function() &#123; jQuery('div').hide(); &#125;);&lt;/script&gt; 先引入jQuery再引入其他库的情况。 1234567&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="other.js"&gt;&lt;/script&gt;&lt;script&gt; jQuery(function() &#123; jQuery('div').hide(); &#125;);&lt;/script&gt; 使用Ajax 原生的Ajax 基于jQuery的Ajax 加载内容 提交表单 使用Bootstrap特点 支持主流的浏览器和移动设备 容易上手 响应式设计 内容 网格系统 封装的CSS 现成的组件 JavaScript插件 玩转Linux操作系统操作系统发展史Linux概述Linux是一个通用操作系统。一个操作系统要负责任务调度、内存分配、处理外围设备I/O等操作。操作系统通常由内核和系统程序（设备驱动、底层库、shell、服务程序等）两部分组成。 Linux内核是芬兰人Linus Torvalds开发的，于1991年9月发布。而Linux操作系统作为Internet时代的产物，它是由全世界许多开发者共同合作开发的，是一个自由的操作系统（注意是自由不是免费）。 Linux系统优点 通用操作系统，不跟特定的硬件绑定。 用C语言编写，有可移植性，有内核编程接口。 支持多用户和多任务，支持安全的分层文件系统。 大量的实用程序，完善的网络功能以及强大的支持文档。 可靠的安全性和良好的稳定性，对开发者更友好。 基础命令Linux系统的命令通常都是如下所示的格式： 1命令名称 [命名参数] [命令对象] 获取登录信息 - w / who / last。 12345678910[root@izwz97tbgo9lkabnat2lo8z ~]# w 23:31:16 up 12:16, 2 users, load average: 0.00, 0.01, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 182.139.66.250 23:03 4.00s 0.02s 0.00s wjackfrue pts/1 182.139.66.250 23:26 3:56 0.00s 0.00s -bash[root@izwz97tbgo9lkabnat2lo8z ~]# whoroot pts/0 2018-04-12 23:03 (182.139.66.250)jackfrued pts/1 2018-04-12 23:26 (182.139.66.250)[root@izwz97tbgo9lkabnat2lo8z ~]# who am iroot pts/0 2018-04-12 23:03 (182.139.66.250) 查看自己使用的Shell - ps。 Shell也被称为“壳”，它是用户与内核交流的翻译官，简单的说就是人与计算机交互的接口。目前很多Linux系统默认的Shell都是bash（Bourne Again SHell），因为它可以使用Tab键进行命令补全、可以保存历史命令、可以方便的配置环境变量以及执行批处理操作等。 1234[root@izwz97tbgo9lkabnat2lo8z ~]# ps PID TTY TIME CMD 3531 pts/0 00:00:00 bash 3553 pts/0 00:00:00 ps 查看命令的说明 - whatis。 1234[root@izwz97tbgo9lkabnat2lo8z ~]# whatis psps (1) - report a snapshot of the current processes.[root@izwz97tbgo9lkabnat2lo8z ~]# whatis pythonpython (1) - an interpreted, interactive, object-oriented programming language 查看命令的位置 - which / whereis。 12345678[root@izwz97tbgo9lkabnat2lo8z ~]# whereis psps: /usr/bin/ps /usr/share/man/man1/ps.1.gz[root@izwz97tbgo9lkabnat2lo8z ~]# whereis pythonpython: /usr/bin/python /usr/bin/python2.7 /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz[root@izwz97tbgo9lkabnat2lo8z ~]# which ps/usr/bin/ps[root@izwz97tbgo9lkabnat2lo8z ~]# which python/usr/bin/python 查看帮助文档 - man / info / apropos。 1234567891011121314151617[root@izwz97tbgo9lkabnat2lo8z ~]# ps --helpUsage: ps [options] Try 'ps --help &lt;simple|list|output|threads|misc|all&gt;' or 'ps --help &lt;s|l|o|t|m|a&gt;' for additional help text.For more details see ps(1).[root@izwz97tbgo9lkabnat2lo8z ~]# man psPS(1) User Commands PS(1)NAME ps - report a snapshot of the current processes.SYNOPSIS ps [options]DESCRIPTION...[root@izwz97tbgo9lkabnat2lo8z ~]# info ps... 切换用户 - su。 12[root@izwz97tbgo9lkabnat2lo8z ~]# su hellokitty[hellokitty@izwz97tbgo9lkabnat2lo8z root]$ 以管理员身份执行命令 - sudo。 12345[jackfrued@izwz97tbgo9lkabnat2lo8z ~]$ ls /rootls: cannot open directory /root: Permission denied[jackfrued@izwz97tbgo9lkabnat2lo8z ~]$ sudo ls /root[sudo] password for jackfrued:calendar.py code error.txt hehe hello.c index.html myconf result.txt 说明：如果希望用户能够以管理员身份执行命令，用户必须在sudoers（/etc/sudoers）名单中。 登入登出相关 - logout / exit / adduser / userdel / passwd / ssh。 123456789101112[root@izwz97tbgo9lkabnat2lo8z ~]# adduser jackfrued[root@izwz97tbgo9lkabnat2lo8z ~]# passwd jackfruedChanging password for user jackfrued.New password:Retype new password:passwd: all authentication tokens updated successfully.[root@izwz97tbgo9lkabnat2lo8z ~]# ssh hellokitty@1.2.3.4hellokitty@1.2.3.4's password:Last login: Thu Apr 12 23:05:32 2018 from 10.12.14.16[hellokitty@izwz97tbgo9lkabnat2lo8z ~]$ logoutConnection to 1.2.3.4 closed.[root@izwz97tbgo9lkabnat2lo8z ~]# 查看系统和主机名 - uname / hostname。 123456[root@izwz97tbgo9lkabnat2lo8z ~]# unameLinux[root@izwz97tbgo9lkabnat2lo8z ~]# hostnameizwz97tbgo9lkabnat2lo8z[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat /etc/centos-releaseCentOS Linux release 7.4.1708 (Core) 重启和关机 - reboot / init 6 / shutdown / init 0。 查看历史命令 - history。 实用程序文件和文件夹操作 创建/删除目录 - mkdir / rmdir。 创建/删除文件 - touch / rm。 touch命令用于创建空白文件或修改文件时间。在Linux系统中一个文件有三种时间： 更改内容的时间（mtime） 更改权限的时间（ctime） 最后访问时间（atime） 切换和查看当前工作目录 - cd / pwd。 查看目录内容 - ls。 查看文件内容 - cat / head / tail / more / less。 拷贝/移动文件 - cp / mv。 查看文件及内容 - find / grep。 1234567[root@izwz97tbgo9lkabnat2lo8z ~]# find -name *.html./index.html./code/index.html[root@izwz97tbgo9lkabnat2lo8z ~]# grep "&lt;script&gt;" . -R -n./index.html:15: &lt;script&gt;./code/index.html:2884: &lt;script&gt;./code/foo.html:2:&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta ... 符号链接 - ln。 压缩和归档 - gzip / gunzip / xz / tar。 其他工具 - sort / uniq / diff / file / wc。 管道和重定向 管道的使用 - |。 输出重定向和错误重定向 - > / 2>。 输入重定向 - \&lt;。 别名 alias unalias 其他程序 时间和日期 - date / cal。 录制操作脚本 - script。 给用户发送消息 - mesg / write / wall / mail。 文件系统文件和路径 命名规则 扩展名 隐藏文件 工作目录和主目录 绝对路径和相对路径 目录结构 /bin - 基本命令的二进制文件 /boot - 引导加载程序的静态文件 /dev - 设备文件 /etc - 配置文件 /home - 用户主目录的父目录 /lib - 共享库文件 /lib64 - 共享64位库文件 /lost+found - 存放未链接文件 /media - 自动识别设备的挂载目录 /mnt - 临时挂载文件系统的挂载点 /opt - 可选插件软件包安装位置 /proc - 内核和进程信息 /root - root账户主目录 /run - 存放系统运行时需要的东西 /sbin - 超级用户的二进制文件 /sys - 设备的伪文件系统 /tmp - 临时文件夹 /usr - 用户应用目录 /var - 变量数据目录 访问权限 chmod。 chown。 磁盘管理 列出文件系统的磁盘使用状况 - df。 磁盘分区表操作 - fdisk。 格式化文件系统 - mkfs。 文件系统检查 - fsck。 挂载/卸载 - mount / umount。 编辑器vim 启动和退出 命令模式和编辑模式 光标操作 文本操作 查找和替换 /正则表达式 :1,$s/正则表达式/替换后的内容/gice g - global i - ignore case c - confirm e - error 参数设定 .vimrc set ts=4 set nu 高级技巧 映射快捷键 inoremap key:… 录制宏 在命令模式下输入qa开始录制宏（qa/qb/qc/qd） 执行你的操作，这些操作都会被录制下来 如果要录制的操作完成了，按q结束录制 @a播放宏（1000@a - 将宏播放1000次） 环境变量 HOME SHELL HISTSIZE RANDOM PATH 软件安装和配置yum yum update yum install / yum remove yum list / yum search yum makecache rpm rpm -ivh --force --nodeps rpm -e rpm -qa | grep 源代码构建安装 … make &amp;&amp; make install 实例 安装MySQL。 安装Redis。 安装NginX。 配置服务 systemctl start / stop / restart / status systemctl enable / disable 计划任务 - crontab。 开机自启。 网络访问和管理 通过网络获取资源 - wget。 -b 后台下载模式 -O 下载到指定的目录 -r 递归下载 显示/操作网络配置（旧） - ipconfig。 显示/操作网络配置（新） - ip。 网络可达性检查 - ping。 查看网络服务和端口 - netstat。 安全文件拷贝 - scp。 安全文件传输 - sftp。 Shell和Shell编程 通配符。 后台运行。 其他内容 awk sed xargs 关系型数据入门关系型数据概述 数据持久化。 数据库发展史。 关系型数据库特点。 E-R图。 关系型数据库产品。 MySQL简介 安装和配置。 常用命令。 SQL详解 DDL DML DQL Python数据库编程 MySQLdb PyMySQL ORM概述网络爬虫和相关工具网络爬虫网络爬虫（web crawler），以前经常称之为网络蜘蛛（spider），是按照一定的规则自动浏览万维网并获取信息的机器人程序（或脚本），曾经被广泛的应用于互联网搜索引擎。使用过互联网和浏览器的人都知道，网页中除了供用户阅读的文字信息之外，还包含一些超链接。网络爬虫系统正是通过网页中的超链接信息不断获得网络上的其它页面。正因如此，网络数据采集的过程就像一个爬虫或者蜘蛛在网络上漫游，所以才被形象的称为网络爬虫或者网络蜘蛛。 爬虫的应用领域在理想的状态下，所有ICP（Internet Content Provider）都应该为自己的网站提供API接口来共享它们允许其他程序获取的数据，在这种情况下爬虫就不是必需品，国内比较有名的电商平台（如淘宝、京东等）、社交平台（如腾讯微博等）等网站都提供了自己的Open API，但是这类Open API通常会对可以抓取的数据以及抓取数据的频率进行限制。对于大多数的公司而言，及时的获取行业相关数据是企业生存的重要环节之一，然而大部分企业在行业数据方面的匮乏是其与生俱来的短板，合理的利用爬虫来获取数据并从中提取出有价值的信息是至关重要的。当然爬虫还有很多重要的应用领域，以下列举了其中的一部分： 搜索引擎 新闻聚合 社交应用 舆情监控 行业数据 合法性和背景调研爬虫合法性探讨 网络爬虫领域目前还属于拓荒阶段，虽然互联网世界已经通过自己的游戏规则建立起一定的道德规范(Robots协议，全称是“网络爬虫排除标准”)，但法律部分还在建立和完善中，也就是说，现在这个领域暂时还是灰色地带。 “法不禁止即为许可”，如果爬虫就像浏览器一样获取的是前端显示的数据（网页上的公开信息）而不是网站后台的私密敏感信息，就不太担心法律法规的约束，因为目前大数据产业链的发展速度远远超过了法律的完善程度。 在爬取网站的时候，需要限制自己的爬虫遵守Robots协议，同时控制网络爬虫程序的抓取数据的速度；在使用数据的时候，必须要尊重网站的知识产权（从Web 2.0时代开始，虽然Web上的数据很多都是由用户提供的，但是网站平台是投入了运营成本的，当用户在注册和发布内容时，平台通常就已经获得了对数据的所有权、使用权和分发权）。如果违反了这些规定，在打官司的时候败诉几率相当高。 Robots.txt文件大多数网站都会定义robots.txt文件，下面以淘宝的robots.txt文件为例，看看该网站对爬虫有哪些限制。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152User-agent: BaiduspiderAllow: /articleAllow: /oshtmlDisallow: /product/Disallow: /User-Agent: GooglebotAllow: /articleAllow: /oshtmlAllow: /productAllow: /spuAllow: /dianpuAllow: /overseaAllow: /listDisallow: /User-agent: BingbotAllow: /articleAllow: /oshtmlAllow: /productAllow: /spuAllow: /dianpuAllow: /overseaAllow: /listDisallow: /User-Agent: 360SpiderAllow: /articleAllow: /oshtmlDisallow: /User-Agent: YisouspiderAllow: /articleAllow: /oshtmlDisallow: /User-Agent: SogouspiderAllow: /articleAllow: /oshtmlAllow: /productDisallow: /User-Agent: Yahoo! SlurpAllow: /productAllow: /spuAllow: /dianpuAllow: /overseaAllow: /listDisallow: /User-Agent: *Disallow: / 注意上面robots.txt第一段的最后一行，通过设置“Disallow: /”禁止百度爬虫访问除了“Allow”规定页面外的其他所有页面。因此当你在百度搜索“淘宝”的时候，搜索结果下方会出现：“由于该网站的robots.txt文件存在限制指令（限制搜索引擎抓取），系统无法提供该页面的内容描述”。百度作为一个搜索引擎，至少在表面上遵守了淘宝网的robots.txt协议，所以用户不能从百度上搜索到淘宝内部的产品信息。 相关工具介绍HTTP协议在开始讲解爬虫之前，我们稍微对HTTP（超文本传输协议）做一些回顾，因为我们在网页上看到的内容通常是浏览器执行HTML语言得到的结果，而HTTP就是传输HTML数据的协议。HTTP是构建于TCP（传输控制协议）之上应用级协议，它利用了TCP提供的可靠的传输服务实现了Web应用中的数据交换。按照维基百科上的介绍，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，也就是说这个协议是浏览器和Web服务器之间传输的数据的载体。关于这个协议的详细信息以及目前的发展状况，大家可以阅读阮一峰老师的《HTTP 协议入门》、《互联网协议入门》系列以及《图解HTTPS协议》进行了解，下图是我在2009年9月10日凌晨4点在四川省网络通信技术重点实验室用开源协议分析工具Ethereal（抓包工具WireShark的前身）截取的访问百度首页时的HTTP请求和响应的报文（协议数据），由于Ethereal截取的是经过网络适配器的数据，因此可以清晰的看到从物理链路层到应用层的协议数据。 HTTP请求（请求行+请求头+空行+[消息体]）： HTTP响应（响应行+响应头+空行+消息体）： 说明：但愿这两张如同泛黄的照片般的截图帮助你大概的了解到HTTP是一个怎样的协议。 相关工具 Chrome Developer Tools POSTMAN HTTPie 1234567891011121314151617$ http --header http://www.scu.edu.cnHTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, max-age=600Connection: Keep-AliveContent-Encoding: gzipContent-Language: zh-CNContent-Length: 14403Content-Type: text/htmlDate: Sun, 27 May 2018 15:38:25 GMTETag: "e6ec-56d3032d70a32-gzip"Expires: Sun, 27 May 2018 15:48:25 GMTKeep-Alive: timeout=5, max=100Last-Modified: Sun, 27 May 2018 13:44:22 GMTServer: VWebServerVary: User-Agent,Accept-EncodingX-Frame-Options: SAMEORIGIN BuiltWith：识别网站使用的技术 123456789&gt;&gt;&gt;&gt;&gt;&gt; import builtwith&gt;&gt;&gt; builtwith.parse('http://www.bootcss.com/')&#123;'web-servers': ['Nginx'], 'font-scripts': ['Font Awesome'], 'javascript-frameworks': ['Lo-dash', 'Underscore.js', 'Vue.js', 'Zepto', 'jQuery'], 'web-frameworks': ['Twitter Bootstrap']&#125;&gt;&gt;&gt;&gt;&gt;&gt; import ssl&gt;&gt;&gt; ssl._create_default_https_context = ssl._create_unverified_context&gt;&gt;&gt; builtwith.parse('https://www.jianshu.com/')&#123;'web-servers': ['Tengine'], 'web-frameworks': ['Twitter Bootstrap', 'Ruby on Rails'], 'programming-languages': ['Ruby']&#125; python-whois：查询网站的所有者 1234&gt;&gt;&gt;&gt;&gt;&gt; import whois&gt;&gt;&gt; whois.whois('baidu.com')&#123;'domain_name': ['BAIDU.COM', 'baidu.com'], 'registrar': 'MarkMonitor, Inc.', 'whois_server': 'whois.markmonitor.com', 'referral_url': None, 'updated_date': [datetime.datetime(2017, 7, 28, 2, 36, 28), datetime.datetime(2017, 7, 27, 19, 36, 28)], 'creation_date': [datetime.datetime(1999, 10, 11, 11, 5, 17), datetime.datetime(1999, 10, 11, 4, 5, 17)], 'expiration_date': [datetime.datetime(2026, 10, 11, 11, 5, 17), datetime.datetime(2026, 10, 11, 0, 0)], 'name_servers': ['DNS.BAIDU.COM', 'NS2.BAIDU.COM', 'NS3.BAIDU.COM', 'NS4.BAIDU.COM', 'NS7.BAIDU.COM', 'dns.baidu.com', 'ns4.baidu.com', 'ns3.baidu.com', 'ns7.baidu.com', 'ns2.baidu.com'], 'status': ['clientDeleteProhibited https://icann.org/epp#clientDeleteProhibited', 'clientTransferProhibited https://icann.org/epp#clientTransferProhibited', 'clientUpdateProhibited https://icann.org/epp#clientUpdateProhibited', 'serverDeleteProhibited https://icann.org/epp#serverDeleteProhibited', 'serverTransferProhibited https://icann.org/epp#serverTransferProhibited', 'serverUpdateProhibited https://icann.org/epp#serverUpdateProhibited', 'clientUpdateProhibited (https://www.icann.org/epp#clientUpdateProhibited)', 'clientTransferProhibited (https://www.icann.org/epp#clientTransferProhibited)', 'clientDeleteProhibited (https://www.icann.org/epp#clientDeleteProhibited)', 'serverUpdateProhibited (https://www.icann.org/epp#serverUpdateProhibited)', 'serverTransferProhibited (https://www.icann.org/epp#serverTransferProhibited)', 'serverDeleteProhibited (https://www.icann.org/epp#serverDeleteProhibited)'], 'emails': ['abusecomplaints@markmonitor.com', 'whoisrelay@markmonitor.com'], 'dnssec': 'unsigned', 'name': None, 'org': 'Beijing Baidu Netcom Science Technology Co., Ltd.', 'address': None, 'city': None, 'state': 'Beijing', 'zipcode': None, 'country': 'CN'&#125; robotparser：解析robots.txt的工具 12345678910&gt;&gt;&gt; from urllib import robotparser&gt;&gt;&gt; parser = robotparser.RobotFileParser()&gt;&gt;&gt; parser.set_url('https://www.taobao.com/robots.txt')&gt;&gt;&gt; parser.read()&gt;&gt;&gt; parser.can_fetch('Hellokitty', 'http://www.taobao.com/article')False&gt;&gt;&gt; parser.can_fetch('Baiduspider', 'http://www.taobao.com/article')True&gt;&gt;&gt; parser.can_fetch('Baiduspider', 'http://www.taobao.com/product')False 一个简单的爬虫一个基本的爬虫通常分为数据采集（网页下载）、数据处理（网页解析）和数据存储（将有用的信息持久化）三个部分的内容，当然更为高级的爬虫在数据采集和处理时会使用并发编程或分布式技术，其中可能还包括调度器和后台管理程序（监控爬虫的工作状态以及检查数据抓取的结果）。 设定抓取目标（种子页面）并获取网页。 当服务器无法访问时，设置重试次数。 在需要的时候设置用户代理（否则无法访问页面）。 对获取的页面进行必要的解码操作。 通过正则表达式获取页面中的链接。 对链接进行进一步的处理（获取页面并重复上面的动作）。 将有用的信息进行持久化（以备后续的处理）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from urllib.error import URLErrorfrom urllib.request import urlopenimport reimport pymysqlimport sslfrom pymysql import Error# 通过指定的字符集对页面进行解码(不是每个网站都将字符集设置为utf-8)def decode_page(page_bytes, charsets=('utf-8',)): page_html = None for charset in charsets: try: page_html = page_bytes.decode(charset) break except UnicodeDecodeError: pass # logging.error('Decode:', error) return page_html# 获取页面的HTML代码(通过递归实现指定次数的重试操作)def get_page_html(seed_url, *, retry_times=3, charsets=('utf-8',)): page_html = None try: page_html = decode_page(urlopen(seed_url).read(), charsets) except URLError: # logging.error('URL:', error) if retry_times &gt; 0: return get_page_html(seed_url, retry_times=retry_times - 1, charsets=charsets) return page_html# 从页面中提取需要的部分(通常是链接也可以通过正则表达式进行指定)def get_matched_parts(page_html, pattern_str, pattern_ignore_case=re.I): pattern_regex = re.compile(pattern_str, pattern_ignore_case) return pattern_regex.findall(page_html) if page_html else []# 开始执行爬虫程序并对指定的数据进行持久化操作def start_crawl(seed_url, match_pattern, *, max_depth=-1): conn = pymysql.connect(host='localhost', port=3306, database='crawler', user='root', password='123456', charset='utf8') try: with conn.cursor() as cursor: url_list = [seed_url] # 通过下面的字典避免重复抓取并控制抓取深度 visited_url_list = &#123;seed_url: 0&#125; while url_list: current_url = url_list.pop(0) depth = visited_url_list[current_url] if depth != max_depth: page_html = get_page_html(current_url, charsets=('utf-8', 'gbk', 'gb2312')) links_list = get_matched_parts(page_html, match_pattern) param_list = [] for link in links_list: if link not in visited_url_list: visited_url_list[link] = depth + 1 page_html = get_page_html(link, charsets=('utf-8', 'gbk', 'gb2312')) headings = get_matched_parts(page_html, r'&lt;h1&gt;(.*)&lt;span') if headings: param_list.append((headings[0], link)) cursor.executemany('insert into tb_result values (default, %s, %s)', param_list) conn.commit() except Error: pass # logging.error('SQL:', error) finally: conn.close()def main(): ssl._create_default_https_context = ssl._create_unverified_context start_crawl('http://sports.sohu.com/nba_a.shtml', r'&lt;a[^&gt;]+test=a\s[^&gt;]*href=["\'](.*?)["\']', max_depth=2)if __name__ == '__main__': main() 注意事项： 处理相对链接。有的时候我们从页面中获取的链接不是一个完整的绝对链接而是一个相对链接，这种情况下需要将其与URL前缀进行拼接（urllib.parse中的urljoin函数可以完成此项操作）。 设置代理服务。有些网站会限制访问的区域（例如美国的Netflix屏蔽了很多国家的访问），有些爬虫需要隐藏自己的身份，在这种情况下可以设置代理服务器（urllib.request中的ProxyHandler就是用来进行此项操作）。 限制下载速度。如果我们的爬虫获取网页的速度过快，可能就会面临被封禁或者产生“损害动产”的风险（这个可能会导致吃官司且败诉哦），可以在两次下载之间添加延时从而对爬虫进行限速。 避免爬虫陷阱。有些网站会动态生成页面内容，这会导致产生无限多的页面（例如在线万年历等）。可以通过记录到达当前页面经过了多少个链接（链接深度）来解决该问题，当达到事先设定的最大深度时爬虫就不再像队列中添加该网页中的链接了。 SSL相关问题。在使用urlopen打开一个HTTPS链接时会验证一次SSL证书，如果不做出处理会产生错误提示“SSL: CERTIFICATE_VERIFY_FAILED”，可以通过以下两种方式加以解决： 使用未经验证的上下文 12345import sslrequest = urllib.request.Request(url='...', headers=&#123;...&#125;) context = ssl._create_unverified_context()web_page = urllib.request.urlopen(request, context=context) 设置全局的取消证书验证 123import sslssl._create_default_https_context = ssl._create_unverified_context 数据采集和解析通过上一个章节，我们已经了解到了开发一个爬虫需要做的工作以及一些常见的问题，至此我们可以对爬虫开发需要做的工作以及相关的技术做一个简单的汇总，可能有些库我们之前并没有使用过，不过别担心，这些内容我们都会讲到的。 下载数据 - urllib / requests / aiohttp。 解析数据 - re / lxml / beautifulsoup4（bs4）/ pyquery。 缓存和持久化 - pymysql / redis / sqlalchemy / peewee / pymongo。 生成摘要 - hashlib。 序列化和压缩 - pickle / json / zlib。 调度器 - 进程 / 线程 / 协程。 HTML页面分析123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;p&gt;这是一个神奇的网站！&lt;/p&gt; &lt;hr&gt; &lt;div&gt; &lt;h2&gt;这是一个例子程序&lt;/h2&gt; &lt;p&gt;静夜思&lt;/p&gt; &lt;p class="foo"&gt;床前明月光&lt;/p&gt; &lt;p id="bar"&gt;疑似地上霜&lt;/p&gt; &lt;p class="foo"&gt;举头望明月&lt;/p&gt; &lt;div&gt;&lt;a href="http://www.baidu.com"&gt;&lt;p&gt;低头思故乡&lt;/p&gt;&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;a class="foo" href="http://www.qq.com"&gt;腾讯网&lt;/a&gt; &lt;img src="./img/pretty-girl.png" alt="美女"&gt; &lt;img src="./img/hellokitty.png" alt="凯蒂猫"&gt; &lt;img src="/static/img/pretty-girl.png" alt="美女"&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;上场时间&lt;/th&gt; &lt;th&gt;得分&lt;/th&gt; &lt;th&gt;篮板&lt;/th&gt; &lt;th&gt;助攻&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 如果你对上面的代码并不感到陌生，那么你一定知道HTML页面通常由三部分构成，分别是：用来承载内容的Tag（标签）、负责渲染页面的CSS（层叠样式表）以及控制交互式行为的JavaScript。通常，我们可以在浏览器的右键菜单中通过“查看网页源代码”的方式获取网页的代码并了解页面的结构；当然，我们也可以通过浏览器提供的开发人员工具来了解网页更多的信息。 使用requests获取页面 GET请求和POST请求。 URL参数和请求头。 复杂的POST请求（文件上传）。 操作Cookie。 设置代理服务器。 超时设置。 说明：关于requests的详细用法可以参考它的官方文档。 四种采集方式四种采集方式的比较 抓取方法 速度 使用难度 备注 正则表达式 快 困难 常用正则表达式在线正则表达式测试 lxml 快 一般 需要安装C语言依赖库唯一支持XML的解析器 Beautiful 快/慢（取决于解析器） 简单 PyQuery 较快 简单 Python版的jQuery 说明：Beautiful的解析器包括：Python标准库（html.parser）、lxml的HTML解析器、lxml的XML解析器和html5lib。 BeautifulSoup的使用 遍历文档树 获取标签 获取标签属性 获取标签内容 获取子（孙）节点 获取父节点/祖先节点 获取兄弟节点 搜索树节点 find / find_all：字符串、正则表达式、列表、True、函数或Lambda。 select_one / select：CSS选择器 说明：更多内容可以参考BeautifulSoup的官方文档。 实例 - 获取知乎发现上的问题链接12345678910111213141516171819202122232425262728293031from urllib.parse import urljoinimport reimport requestsfrom bs4 import BeautifulSoupdef main(): headers = &#123;'user-agent': 'Baiduspider'&#125; proxies = &#123; 'http': 'http://122.114.31.177:808' &#125; base_url = 'https://www.zhihu.com/' seed_url = urljoin(base_url, 'explore') resp = requests.get(seed_url, headers=headers, proxies=proxies) soup = BeautifulSoup(resp.text, 'lxml') href_regex = re.compile(r'^/question') link_set = set() for a_tag in soup.find_all('a', &#123;'href': href_regex&#125;): if 'href' in a_tag.attrs: href = a_tag.attrs['href'] full_url = urljoin(base_url, href) link_set.add(full_url) print('Total %d question pages found.' % len(link_set))if __name__ == '__main__': main() 存储数据数据缓存通过前面章节的内容，我们已经知道了如何从指定的页面中抓取数据，以及如何保存抓取的结果，但是我们没有考虑过这么一种情况，就是我们可能需要从已经抓取过的页面中提取出更多的数据，重新去下载这些页面对于规模不大的网站倒是问题也不大，但是如果能够把这些页面缓存起来，对应用的性能会有明显的改善。 使用NoSQLRedis简介Redis是REmote DIctionary Server的缩写，它是一个用ANSI C编写的高性能的key-value存储系统，与其他的key-value存储系统相比，Redis有以下一些特点（也是优点）： Redis的读写性能极高，并且有丰富的特性（发布/订阅、事务、通知等）。 Redis支持数据的持久化（RDB和AOF两种方式），可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供hash、list、set，zset、hyperloglog、geo等数据类型。 Redis支持主从复制（实现读写分析）以及哨兵模式（监控master是否宕机并调整配置）。 Redis的安装和配置可以使用Linux系统的包管理工具（如yum）来安装Redis，也可以通过在Redis的官方网站下载Redis的源代码解压缩解归档之后进行构件安装。 123456# wget http://download.redis.io/releases/redis-3.2.11.tar.gz# gunzip redis-3.2.11.tar.gz# tar -xvf redis-3.2.11.tar# cd redis-3.2.11# make &amp;&amp; make install 接下来我们将redis-3.2.11目录下的redis.conf配置文件复制到用户主目录下并修改配置文件（如果你对配置文件不是很有把握就不要直接修改而是先复制一份再修改这个副本）。 1234# cd ..# cp redis-3.2.11/redis.conf redis.conf# vim redis.conf 配置将Redis服务绑定到指定的IP地址和端口。 配置底层有多少个数据库。 配置Redis的持久化机制 - RDB。 配置Redis的持久化机制 - AOF。 配置访问Redis服务器的验证口令。 配置Redis的主从复制，通过主从复制可以实现读写分离。 配置慢查询日志。 这样我们就完成了Redis的基本配置，如果对上面的东西感到困惑，可以先系统的了解一下Redis，《Redis开发与运维》是一本不错的入门读物，而《Redis实战》是不错的进阶读物。 Redis的服务器和客户端接下来启动Redis服务器，可以将服务器放在后台去运行。 12345678910111213141516171819# redis-server redis.conf &amp; _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 3.2.11 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 12345 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 接下来，我们尝试用Redis客户端去连接服务器。 1234567# redis-cli -h 172.18.61.250 -p 6379172.18.61.250:6379&gt; auth 1qaz2wsxOK172.18.61.250:6379&gt; pingPONG172.18.61.250:6379&gt; Redis有着非常丰富的数据类型，也有很多的命令来操作这些数据，具体的内容可以查看Redis命令参考，在这个网站上，除了Redis的命令参考，还有Redis的详细文档，其中包括了通知、事务、主从复制、持久化、哨兵、集群等内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647172.18.61.250:6379&gt; set username adminOK172.18.61.250:6379&gt; get username"admin"172.18.61.250:6379&gt; hset student1 name hao(integer) 0172.18.61.250:6379&gt; hset student1 age 38(integer) 1172.18.61.250:6379&gt; hset student1 gender male(integer) 1172.18.61.250:6379&gt; hgetall student11) "name"2) "hao"3) "age"4) "38"5) "gender"6) "male"172.18.61.250:6379&gt; lpush num 1 2 3 4 5(integer) 5172.18.61.250:6379&gt; lrange num 0 -11) "5"2) "4"3) "3"4) "2"5) "1"172.18.61.250:6379&gt; sadd fruits apple banana orange apple grape grape(integer) 4172.18.61.250:6379&gt; scard fruits(integer) 4172.18.61.250:6379&gt; smembers fruits1) "grape"2) "orange"3) "banana"4) "apple"172.18.61.250:6379&gt; zadd scores 90 zhao 78 qian 66 sun 95 lee(integer) 4172.18.61.250:6379&gt; zrange scores 0 -11) "sun"2) "qian"3) "zhao"4) "lee"172.18.61.250:6379&gt; zrevrange scores 0 -11) "lee"2) "zhao"3) "qian"4) "sun" 在Python程序中使用Redis可以使用pip安装redis模块。redis模块的核心是名为Redis的类，该类的对象代表一个Redis客户端，通过该客户端可以向Redis服务器发送命令并获取执行的结果。上面我们在Redis客户端中使用的命令基本上就是Redis对象可以接收的消息，所以如果了解了Redis的命令就可以在Python中玩转Redis。 123$ pip3 install redis$ python3 123456789101112131415&gt;&gt;&gt; import redis&gt;&gt;&gt; client = redis.Redis(host='1.2.3.4', port=6379, password='1qaz2wsx')&gt;&gt;&gt; client.set('username', 'admin')True&gt;&gt;&gt; client.hset('student', 'name', 'hao')1&gt;&gt;&gt; client.hset('student', 'age', 38)1&gt;&gt;&gt; client.keys('*')[b'username', b'student']&gt;&gt;&gt; client.get('username')b'admin'&gt;&gt;&gt; client.hgetall('student')&#123;b'name': b'hao', b'age': b'38'&#125; MongoDB简介MongoDB是2009年问世的一个面向文档的数据库管理系统，由C++语言编写，旨在为Web应用提供可扩展的高性能数据存储解决方案。虽然在划分类别的时候后，MongoDB被认为是NoSQL的产品，但是它更像一个介于关系数据库和非关系数据库之间的产品，在非关系数据库中它功能最丰富，最像关系数据库。 MongoDB将数据存储为一个文档，一个文档由一系列的“键值对”组成，其文档类似于JSON对象，但是MongoDB对JSON进行了二进制处理（能够更快的定位key和value），因此其文档的存储格式称为BSON。关于JSON和BSON的差别大家可以看看MongoDB官方网站的文章《JSON and BSON》。 目前，MongoDB已经提供了对Windows、MacOS、Linux、Solaris等多个平台的支持，而且也提供了多种开发语言的驱动程序，Python当然是其中之一。 MongoDB的安装和配置可以从MongoDB的官方下载链接下载MongoDB，官方为Windows系统提供了一个Installer程序，而Linux和MacOS则提供了压缩文件。下面简单说一下Linux系统如何安装和配置MongoDB。 1234567891011121314# wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon-3.6.5.tgz# gunzip mongodb-linux-x86_64-amazon-3.6.5.tgz# mkdir mongodb-3.6.5# tar -xvf mongodb-linux-x86_64-amazon-3.6.5.tar --strip-components 1 -C mongodb-3.6.5/# export PATH=$PATH:~/mongodb-3.6.5/bin# mkdir -p /data/db# mongod --bind_ip 172.18.61.2502018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] MongoDB starting : pid=1163 port=27017 dbpath=/data/db 64-bit host=iZwz97tbgo9lkabnat2lo8Z2018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] db version v3.6.52018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] git version: a20ecd3e3a174162052ff99913bc2ca9a839d6182018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] OpenSSL version: OpenSSL 1.0.0-fips29 Mar 2010...2018-06-03T18:03:28.945+0800 I NETWORK [initandlisten] waiting for connections on port 27017 说明：上面的操作中，export命令是设置PATH环境变量，这样可以在任意路径下执行mongod来启动MongoDB服务器。MongoDB默认保存数据的路径是/data/db目录，为此要提前创建该目录。此外，在使用mongod启动MongoDB服务器时，—bind_ip参数用来将服务绑定到指定的IP地址，也可以用—port参数来指定端口，默认端口为27017。 MongoDB基本概念我们通过与关系型数据库进行对照的方式来说明MongoDB中的一些概念。 SQL MongoDB 解释（SQL/MongoDB） database database 数据库/数据库 table collection 二维表/集合 row document 记录（行）/文档 column field 字段（列）/域 index index 索引/索引 table joins — 表连接/嵌套文档 primary key primary key 主键/主键（_id字段） 通过Shell操作MongoDB启动服务器后可以使用交互式环境跟服务器通信，如下所示。 12345# mongo --host 172.18.61.250MongoDB shell version v3.6.5connecting to: mongodb://172.18.61.250:27017/...&gt; 查看、创建和删除数据库。 12345678910111213&gt; // 显示所有数据库&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GB&gt; // 创建并切换到school数据库&gt; use schoolswitched to db school&gt; // 删除当前数据库&gt; db.dropDatabase()&#123; "ok" : 1 &#125;&gt; 创建、删除和查看集合。 123456789101112131415161718&gt; // 创建并切换到school数据库&gt; use schoolswitched to db school&gt; // 创建colleges集合&gt; db.createCollection('colleges')&#123; "ok" : 1 &#125;&gt; // 创建students集合&gt; db.createCollection('students')&#123; "ok" : 1 &#125;&gt; // 查看所有集合&gt; show collectionscollegesstudents&gt; // 删除colleges集合&gt; db.colleges.drop()true&gt; 说明：在MongoDB中插入文档时如果集合不存在会自动创建集合，所以也可以按照下面的方式通过创建文档来创建集合。 文档的CRUD操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&gt; // 向students集合插入文档&gt; db.students.insert(&#123;stuid: 1001, name: '骆昊', age: 38&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; // 向students集合插入文档&gt; db.students.save(&#123;stuid: 1002, name: '王大锤', tel: '13012345678', gender: '男'&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; // 查看所有文档&gt; db.students.find()&#123; "_id" : ObjectId("5b13c72e006ad854460ee70b"), "stuid" : 1001, "name" : "骆昊", "age" : 38 &#125;&#123; "_id" : ObjectId("5b13c790006ad854460ee70c"), "stuid" : 1002, "name" : "王大锤", "tel" : "13012345678", "gender" : "男" &#125;&gt; // 更新stuid为1001的文档&gt; db.students.update(&#123;stuid: 1001&#125;, &#123;'$set': &#123;tel: '13566778899', gender: '男'&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; // 插入或更新stuid为1003的文档&gt; db.students.update(&#123;stuid: 1003&#125;, &#123;'$set': &#123;name: '白元芳', tel: '13022223333', gender: '男'&#125;&#125;, upsert=true)WriteResult(&#123; "nMatched" : 0, "nUpserted" : 1, "nModified" : 0, "_id" : ObjectId("5b13c92dd185894d7283efab")&#125;)&gt; // 查询所有文档&gt; db.students.find().pretty()&#123; "_id" : ObjectId("5b13c72e006ad854460ee70b"), "stuid" : 1001, "name" : "骆昊", "age" : 38, "gender" : "男", "tel" : "13566778899"&#125;&#123; "_id" : ObjectId("5b13c790006ad854460ee70c"), "stuid" : 1002, "name" : "王大锤", "tel" : "13012345678", "gender" : "男"&#125;&#123; "_id" : ObjectId("5b13c92dd185894d7283efab"), "stuid" : 1003, "gender" : "男", "name" : "白元芳", "tel" : "13022223333"&#125;&gt; // 查询stuid大于1001的文档&gt; db.students.find(&#123;stuid: &#123;'$gt': 1001&#125;&#125;).pretty()&#123; "_id" : ObjectId("5b13c790006ad854460ee70c"), "stuid" : 1002, "name" : "王大锤", "tel" : "13012345678", "gender" : "男"&#125;&#123; "_id" : ObjectId("5b13c92dd185894d7283efab"), "stuid" : 1003, "gender" : "男", "name" : "白元芳", "tel" : "13022223333"&#125;&gt; // 查询stuid大于1001的文档只显示name和tel字段&gt; db.students.find(&#123;stuid: &#123;'$gt': 1001&#125;&#125;, &#123;_id: 0, name: 1, tel: 1&#125;).pretty()&#123; "name" : "王大锤", "tel" : "13012345678" &#125;&#123; "name" : "白元芳", "tel" : "13022223333" &#125;&gt; // 查询name为“骆昊”或者tel为“13022223333”的文档&gt; db.students.find(&#123;'$or': [&#123;name: '骆昊'&#125;, &#123;tel: '13022223333'&#125;]&#125;, &#123;_id: 0, name: 1, tel: 1&#125;).pretty()&#123; "name" : "骆昊", "tel" : "13566778899" &#125;&#123; "name" : "白元芳", "tel" : "13022223333" &#125;&gt; // 查询学生文档跳过第1条文档只查1条文档&gt; db.students.find().skip(1).limit(1).pretty()&#123; "_id" : ObjectId("5b13c790006ad854460ee70c"), "stuid" : 1002, "name" : "王大锤", "tel" : "13012345678", "gender" : "男"&#125;&gt; // 对查询结果进行排序(1表示升序，-1表示降序)&gt; db.students.find(&#123;&#125;, &#123;_id: 0, stuid: 1, name: 1&#125;).sort(&#123;stuid: -1&#125;)&#123; "stuid" : 1003, "name" : "白元芳" &#125;&#123; "stuid" : 1002, "name" : "王大锤" &#125;&#123; "stuid" : 1001, "name" : "骆昊" &#125;&gt; // 在指定的一个或多个字段上创建索引&gt; db.students.ensureIndex(&#123;name: 1&#125;)&#123; "createdCollectionAutomatically" : false, "numIndexesBefore" : 1, "numIndexesAfter" : 2, "ok" : 1&#125;&gt; 使用MongoDB可以非常方便的配置数据复制，通过冗余数据来实现数据的高可用以及灾难恢复，也可以通过数据分片来应对数据量迅速增长的需求。关于MongoDB更多的操作可以查阅官方文档 ，同时推荐大家阅读Kristina Chodorow写的《MongoDB权威指南》。 ####在Python程序中操作MongoDB 可以通过pip安装pymongo来实现对MongoDB的操作。 123$ pip3 install pymongo$ python3 1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt;&gt;&gt; from pymongo import MongoClient&gt;&gt;&gt; client = MongoClient('mongodb://120.77.222.217:27017') &gt;&gt;&gt; db = client.school&gt;&gt;&gt; for student in db.students.find():... print('学号:', student['stuid'])... print('姓名:', student['name'])... print('电话:', student['tel'])... 学号: 1001.0姓名: 骆昊电话: 13566778899学号: 1002.0姓名: 王大锤电话: 13012345678学号: 1003.0姓名: 白元芳电话: 13022223333&gt;&gt;&gt; db.students.find().count()3&gt;&gt;&gt; db.students.remove()&#123;'n': 3, 'ok': 1.0&#125;&gt;&gt;&gt; db.students.find().count()0&gt;&gt;&gt; coll = db.students&gt;&gt;&gt; from pymongo import ASCENDING&gt;&gt;&gt; coll.create_index([('name', ASCENDING)], unique=True)'name_1'&gt;&gt;&gt; coll.insert_one(&#123;'stuid': int(1001), 'name': '骆昊', 'gender': True&#125;)&lt;pymongo.results.InsertOneResult object at 0x1050cc6c8&gt;&gt;&gt;&gt; coll.insert_many([&#123;'stuid': int(1002), 'name': '王大锤', 'gender': False&#125;, &#123;'stuid': int(1003), 'name': '白元芳', 'gender': True&#125;])&lt;pymongo.results.InsertManyResult object at 0x1050cc8c8&gt;&gt;&gt;&gt; for student in coll.find(&#123;'gender': True&#125;):... print('学号:', student['stuid'])... print('姓名:', student['name'])... print('性别:', '男' if student['gender'] else '女')... 学号: 1001姓名: 骆昊性别: 男学号: 1003姓名: 白元芳性别: 男&gt;&gt;&gt; 关于PyMongo更多的知识可以通过它的官方文档进行了解。 实例 - 缓存知乎发现上的链接和页面代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from hashlib import sha1from urllib.parse import urljoinimport pickleimport reimport requestsimport zlibfrom bs4 import BeautifulSoupfrom redis import Redisdef main(): # 指定种子页面 base_url = 'https://www.zhihu.com/' seed_url = urljoin(base_url, 'explore') # 创建Redis客户端 client = Redis(host='1.2.3.4', port=6379, password='1qaz2wsx') # 设置用户代理(否则访问会被拒绝) headers = &#123;'user-agent': 'Baiduspider'&#125; # 通过requests模块发送GET请求并指定用户代理 resp = requests.get(seed_url, headers=headers) # 创建BeautifulSoup对象并指定使用lxml作为解析器 soup = BeautifulSoup(resp.text, 'lxml') href_regex = re.compile(r'^/question') # 将URL处理成SHA1摘要(长度固定更简短) hasher_proto = sha1() # 查找所有href属性以/question打头的a标签 for a_tag in soup.find_all('a', &#123;'href': href_regex&#125;): # 获取a标签的href属性值并组装完整的URL href = a_tag.attrs['href'] full_url = urljoin(base_url, href) # 传入URL生成SHA1摘要 hasher = hasher_proto.copy() hasher.update(full_url.encode('utf-8')) field_key = hasher.hexdigest() # 如果Redis的键'zhihu'对应的hash数据类型中没有URL的摘要就访问页面并缓存 if not client.hexists('zhihu', field_key): html_page = requests.get(full_url, headers=headers).text # 对页面进行序列化和压缩操作 zipped_page = zlib.compress(pickle.dumps(html_page)) # 使用hash数据类型保存URL摘要及其对应的页面代码 client.hset('zhihu', field_key, zipped_page) # 显示总共缓存了多少个页面 print('Total %d question pages found.' % client.hlen('zhihu'))if __name__ == '__main__': main() 并发下载多线程和多进程回顾在前面的《进程和线程》一文中，我们已经对在Python中使用多进程和多线程实现并发编程进行了简明的讲解，在此我们补充几个知识点。 threading.local类使用线程时最不愿意遇到的情况就是多个线程竞争资源，在这种情况下为了保证资源状态的正确性，我们可能需要对资源进行加锁保护的处理，这一方面会导致程序失去并发性，另外如果多个线程竞争多个资源时，还有可能因为加锁方式的不当导致死锁。要解决多个线程竞争资源的问题，其中一个方案就是让每个线程都持有资源的副本（拷贝），这样每个线程可以操作自己所持有的资源，从而规避对资源的竞争。 要实现将资源和持有资源的线程进行绑定的操作，最简单的做法就是使用threading模块的local类，在网络爬虫开发中，就可以使用local类为每个线程绑定一个MySQL数据库连接或Redis客户端对象，这样通过线程可以直接获得这些资源，既解决了资源竞争的问题，又避免了在函数和方法调用时传递这些资源。具体的请参考本章多线程爬取“手机搜狐网”（Redis版）的实例代码。 concurrent.futures模块Python3.2带来了concurrent.futures 模块，这个模块包含了线程池和进程池、管理并行编程任务、处理非确定性的执行流程、进程/线程同步等功能。关于这部分的内容推荐大家阅读《Python并行编程》。 分布式进程使用多进程的时候，可以将进程部署在多个主机节点上，Python的multiprocessing模块不但支持多进程，其中managers子模块还支持把多进程部署到多个节点上。当然，要部署分布式进程，首先需要一个服务进程作为调度者，进程之间通过网络进行通信来实现对进程的控制和调度，由于managers模块已经对这些做出了很好的封装，因此在无需了解网络通信细节的前提下，就可以编写分布式多进程应用。具体的请参照本章分布式多进程爬取“手机搜狐网”的实例代码。 协程和异步I/O协程的概念协程（coroutine）通常又称之为微线程或纤程，它是相互协作的一组子程序（函数）。所谓相互协作指的是在执行函数A时，可以随时中断去执行函数B，然后又中断继续执行函数A。注意，这一过程并不是函数调用（因为没有调用语句），整个过程看似像多线程，然而协程只有一个线程执行。协程通过yield关键字和 send()操作来转移执行权，协程之间不是调用者与被调用者的关系。 协程的优势在于以下两点： 执行效率极高，因为子程序（函数）切换不是线程切换，由程序自身控制，没有切换线程的开销。 不需要多线程的锁机制，因为只有一个线程，也不存在竞争资源的问题，当然也就不需要对资源加锁保护，因此执行效率高很多。 说明：协程适合处理的是I/O密集型任务，处理CPU密集型任务并不是它的长处，如果要提升CPU的利用率可以考虑“多进程+协程”的模式。 历史回顾 Python 2.2：第一次提出了生成器（最初称之为迭代器）的概念（PEP 255）。 Python 2.5：引入了将对象发送回暂停了的生成器这一特性即生成器的send()方法（PEP 342）。 Python 3.3：添加了yield from特性，允许从迭代器中返回任何值（注意生成器本身也是迭代器），这样我们就可以串联生成器并且重构出更好的生成器。 Python 3.4：引入asyncio.coroutine装饰器用来标记作为协程的函数，协程函数和asyncio及其事件循环一起使用，来实现异步I/O操作。 Python 3.5：引入了async和await，可以使用async def来定义一个协程函数，这个函数中不能包含任何形式的yield语句，但是可以使用return或await从协程中返回值。 示例代码 生成器 - 数据的生产者。 1234567891011121314151617181920from time import sleep# 倒计数生成器def countdown(n): while n &gt; 0: yield n n -= 1def main(): for num in countdown(5): print(f'Countdown: &#123;num&#125;') sleep(1) print('Countdown Over!')if __name__ == '__main__': main() 生成器还可以叠加来组成生成器管道，代码如下所示。 123456789101112131415161718192021222324# Fibonacci数生成器def fib(): a, b = 0, 1 while True: a, b = b, a + b yield a# 偶数生成器def even(gen): for val in gen: if val % 2 == 0: yield valdef main(): gen = even(fib()) for _ in range(10): print(next(gen))if __name__ == '__main__': main() 协程 - 数据的消费者。 123456789101112131415161718192021222324252627282930from time import sleep# 生成器 - 数据生产者def countdown_gen(n, consumer): consumer.send(None) while n &gt; 0: consumer.send(n) n -= 1 consumer.send(None)# 协程 - 数据消费者def countdown_con(): while True: n = yield if n: print(f'Countdown &#123;n&#125;') sleep(1) else: print('Countdown Over!')def main(): countdown_gen(5, countdown_con())if __name__ == '__main__': main() 说明：上面代码中countdown_gen函数中的第1行consumer.send(None)是为了激活生成器，通俗的说就是让生成器执行到有yield关键字的地方挂起，当然也可以通过next(consumer)来达到同样的效果。如果不愿意每次都用这样的代码来“预激”生成器，可以写一个包装器来完成该操作，代码如下所示。 12345678910111213from functools import wrapsdef coroutine(fn): @wraps(fn) def wrapper(*args, **kwargs): gen = fn(*args, **kwargs) next(gen) return gen return wrapper 这样就可以使用@coroutine装饰器对协程进行预激操作，不需要再写重复代码来激活协程。 异步I/O - 非阻塞式I/O操作。 1234567891011121314151617181920212223import asyncio@asyncio.coroutinedef countdown(name, n): while n &gt; 0: print(f'Countdown[&#123;name&#125;]: &#123;n&#125;') yield from asyncio.sleep(1) n -= 1def main(): loop = asyncio.get_event_loop() tasks = [ countdown("A", 10), countdown("B", 5), ] loop.run_until_complete(asyncio.wait(tasks)) loop.close()if __name__ == '__main__': main() async和await。 123456789101112131415161718192021222324252627282930import asyncioimport aiohttpasync def download(url): print('Fetch:', url) async with aiohttp.ClientSession() as session: async with session.get(url) as resp: print(url, '---&gt;', resp.status) print(url, '---&gt;', resp.cookies) print('\n\n', await resp.text())def main(): loop = asyncio.get_event_loop() urls = [ 'https://www.baidu.com', 'http://www.sohu.com/', 'http://www.sina.com.cn/', 'https://www.taobao.com/', 'https://www.jd.com/' ] tasks = [download(url) for url in urls] loop.run_until_complete(asyncio.wait(tasks)) loop.close()if __name__ == '__main__': main() 上面的代码使用了AIOHTTP这个非常著名的第三方库，它实现了HTTP客户端和HTTP服务器的功能，对异步操作提供了非常好的支持，有兴趣可以阅读它的官方文档。 实例 - 多线程爬取“手机搜狐网”所有页面。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157import pickleimport zlibfrom enum import Enum, uniquefrom hashlib import sha1from random import randomfrom threading import Thread, current_thread, localfrom time import sleepfrom urllib.parse import urlparseimport pymongoimport redisimport requestsfrom bs4 import BeautifulSoupfrom bson import Binary@uniqueclass SpiderStatus(Enum): IDLE = 0 WORKING = 1def decode_page(page_bytes, charsets=('utf-8',)): page_html = None for charset in charsets: try: page_html = page_bytes.decode(charset) break except UnicodeDecodeError: pass return page_htmlclass Retry(object): def __init__(self, *, retry_times=3, wait_secs=5, errors=(Exception, )): self.retry_times = retry_times self.wait_secs = wait_secs self.errors = errors def __call__(self, fn): def wrapper(*args, **kwargs): for _ in range(self.retry_times): try: return fn(*args, **kwargs) except self.errors as e: print(e) sleep((random() + 1) * self.wait_secs) return None return wrapperclass Spider(object): def __init__(self): self.status = SpiderStatus.IDLE @Retry() def fetch(self, current_url, *, charsets=('utf-8', ), user_agent=None, proxies=None): thread_name = current_thread().name print(f'[&#123;thread_name&#125;]: &#123;current_url&#125;') headers = &#123;'user-agent': user_agent&#125; if user_agent else &#123;&#125; resp = requests.get(current_url, headers=headers, proxies=proxies) return decode_page(resp.content, charsets) \ if resp.status_code == 200 else None def parse(self, html_page, *, domain='m.sohu.com'): soup = BeautifulSoup(html_page, 'lxml') for a_tag in soup.body.select('a[href]'): parser = urlparse(a_tag.attrs['href']) scheme = parser.scheme or 'http' netloc = parser.netloc or domain if scheme != 'javascript' and netloc == domain: path = parser.path query = '?' + parser.query if parser.query else '' full_url = f'&#123;scheme&#125;://&#123;netloc&#125;&#123;path&#125;&#123;query&#125;' redis_client = thread_local.redis_client if not redis_client.sismember('visited_urls', full_url): redis_client.rpush('m_sohu_task', full_url) def extract(self, html_page): pass def store(self, data_dict): # redis_client = thread_local.redis_client # mongo_db = thread_local.mongo_db passclass SpiderThread(Thread): def __init__(self, name, spider): super().__init__(name=name, daemon=True) self.spider = spider def run(self): redis_client = redis.Redis(host='1.2.3.4', port=6379, password='1qaz2wsx') mongo_client = pymongo.MongoClient(host='1.2.3.4', port=27017) thread_local.redis_client = redis_client thread_local.mongo_db = mongo_client.msohu while True: current_url = redis_client.lpop('m_sohu_task') while not current_url: current_url = redis_client.lpop('m_sohu_task') self.spider.status = SpiderStatus.WORKING current_url = current_url.decode('utf-8') if not redis_client.sismember('visited_urls', current_url): redis_client.sadd('visited_urls', current_url) html_page = self.spider.fetch(current_url) if html_page not in [None, '']: hasher = hasher_proto.copy() hasher.update(current_url.encode('utf-8')) doc_id = hasher.hexdigest() sohu_data_coll = mongo_client.msohu.webpages if not sohu_data_coll.find_one(&#123;'_id': doc_id&#125;): sohu_data_coll.insert_one(&#123; '_id': doc_id, 'url': current_url, 'page': Binary(zlib.compress(pickle.dumps(html_page))) &#125;) self.spider.parse(html_page) self.spider.status = SpiderStatus.IDLEdef is_any_alive(spider_threads): return any([spider_thread.spider.status == SpiderStatus.WORKING for spider_thread in spider_threads])thread_local = local()hasher_proto = sha1()def main(): redis_client = redis.Redis(host='1.2.3.4', port=6379, password='1qaz2wsx') if not redis_client.exists('m_sohu_task'): redis_client.rpush('m_sohu_task', 'http://m.sohu.com/') spider_threads = [SpiderThread('thread-%d' % i, Spider()) for i in range(10)] for spider_thread in spider_threads: spider_thread.start() while redis_client.exists('m_sohu_task') or is_any_alive(spider_threads): pass print('Over!')if __name__ == '__main__': main() 表单交互和验证码处理提交表单手动提交自动提交验证码处理加载验证码光学字符识别光学字符识别（OCR）是从图像中抽取文本的工具，可以应用于公安、电信、物流、金融等诸多行业，例如识别车牌，身份证扫描识别、名片信息提取等。在爬虫开发中，如果遭遇了有文字验证码的表单，就可以利用OCR来进行验证码处理。Tesseract-OCR引擎最初是由惠普公司开发的光学字符识别系统，目前发布在Github上，由Google赞助开发。 改善OCR处理更复杂的验证码验证码处理服务Scrapy爬虫框架入门Scrapy概述Scrapy是Python开发的一个非常流行的网络爬虫框架，可以用来抓取Web站点并从页面中提取结构化的数据，被广泛的用于数据挖掘、数据监测和自动化测试等领域。 组件 Scrapy引擎（Engine）：Scrapy引擎是用来控制整个系统的数据处理流程。 调度器（Scheduler）：调度器从Scrapy引擎接受请求并排序列入队列，并在Scrapy引擎发出请求后返还给它们。 下载器（Downloader）：下载器的主要职责是抓取网页并将网页内容返还给蜘蛛（Spiders）。 蜘蛛（Spiders）：蜘蛛是有Scrapy用户自定义的用来解析网页并抓取特定URL返回的内容的类，每个蜘蛛都能处理一个域名或一组域名，简单的说就是用来定义特定网站的抓取和解析规则。 条目管道（Item Pipeline）：条目管道的主要责任是负责处理有蜘蛛从网页中抽取的数据条目，它的主要任务是清理、验证和存储数据。当页面被蜘蛛解析后，将被发送到条目管道，并经过几个特定的次序处理数据。每个条目管道组件都是一个Python类，它们获取了数据条目并执行对数据条目进行处理的方法，同时还需要确定是否需要在条目管道中继续执行下一步或是直接丢弃掉不处理。条目管道通常执行的任务有：清理HTML数据、验证解析到的数据（检查条目是否包含必要的字段）、检查是不是重复数据（如果重复就丢弃）、将解析到的数据存储到数据库（关系型数据库或NoSQL数据库）中。 中间件（Middlewares）：中间件是介于Scrapy引擎和其他组件之间的一个钩子框架，主要是为了提供自定义的代码来拓展Scrapy的功能，包括下载器中间件和蜘蛛中间件。 数据处理流程Scrapy的整个数据处理流程由Scrapy引擎进行控制，通常的运转流程包括以下的步骤： 引擎询问蜘蛛需要处理哪个网站，并让蜘蛛将第一个需要处理的URL交给它。 引擎让调度器将需要处理的URL放在队列中。 引擎从调度那获取接下来进行爬取的页面。 调度将下一个爬取的URL返回给引擎，引擎将它通过下载中间件发送到下载器。 当网页被下载器下载完成以后，响应内容通过下载中间件被发送到引擎；如果下载失败了，引擎会通知调度器记录这个URL，待会再重新下载。 引擎收到下载器的响应并将它通过蜘蛛中间件发送到蜘蛛进行处理。 蜘蛛处理响应并返回爬取到的数据条目，此外还要将需要跟进的新的URL发送给引擎。 引擎将抓取到的数据条目送入条目管道，把新的URL发送给调度器放入队列中。 上述操作中的2-8步会一直重复直到调度器中没有需要请求的URL，爬虫停止工作。 安装和使用Scrapy可以先创建虚拟环境并在虚拟环境下使用pip安装scrapy。 12$ 项目的目录结构如下图所示。 1234567891011121314(venv) $ tree.|____ scrapy.cfg|____ douban| |____ spiders| | |____ __init__.py| | |____ __pycache__| |____ __init__.py| |____ __pycache__| |____ middlewares.py| |____ settings.py| |____ items.py| |____ pipelines.py 说明：Windows系统的命令行提示符下有tree命令，但是Linux和MacOS的终端是没有tree命令的，可以用下面给出的命令来定义tree命令，其实是对find命令进行了定制并别名为tree。 alias tree=&quot;find . -print | sed -e &#39;s;[^/]*/;|____;g;s;____|; |;g&#39;&quot; Linux系统也可以通过yum或其他的包管理工具来安装tree。 yum install tree 根据刚才描述的数据处理流程，基本上需要我们做的有以下几件事情： 在items.py文件中定义字段，这些字段用来保存数据，方便后续的操作。 12345678910111213141516171819# -*- coding: utf-8 -*-# Define here the models for your scraped items## See documentation in:# https://doc.scrapy.org/en/latest/topics/items.htmlimport scrapyclass DoubanItem(scrapy.Item): name = scrapy.Field() year = scrapy.Field() score = scrapy.Field() director = scrapy.Field() classification = scrapy.Field() actor = scrapy.Field() 在spiders文件夹中编写自己的爬虫。 12(venv) $ scrapy genspider movie movie.douban.com --template=crawl 1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-import scrapyfrom scrapy.selector import Selectorfrom scrapy.linkextractors import LinkExtractorfrom scrapy.spiders import CrawlSpider, Rulefrom douban.items import DoubanItemclass MovieSpider(CrawlSpider): name = 'movie' allowed_domains = ['movie.douban.com'] start_urls = ['https://movie.douban.com/top250'] rules = ( Rule(LinkExtractor(allow=(r'https://movie.douban.com/top250\?start=\d+.*'))), Rule(LinkExtractor(allow=(r'https://movie.douban.com/subject/\d+')), callback='parse_item'), ) def parse_item(self, response): sel = Selector(response) item = DoubanItem() item['name']=sel.xpath('//*[@id="content"]/h1/span[1]/text()').extract() item['year']=sel.xpath('//*[@id="content"]/h1/span[2]/text()').re(r'\((\d+)\)') item['score']=sel.xpath('//*[@id="interest_sectl"]/div/p[1]/strong/text()').extract() item['director']=sel.xpath('//*[@id="info"]/span[1]/a/text()').extract() item['classification']= sel.xpath('//span[@property="v:genre"]/text()').extract() item['actor']= sel.xpath('//*[@id="info"]/span[3]/a[1]/text()').extract() return item 在pipelines.py中完成对数据进行持久化的操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding: utf-8 -*-# Define your item pipelines here## Don't forget to add your pipeline to the ITEM_PIPELINES setting# See: https://doc.scrapy.org/en/latest/topics/item-pipeline.htmlimport pymongofrom scrapy.exceptions import DropItemfrom scrapy.conf import settingsfrom scrapy import logclass DoubanPipeline(object): def __init__(self): connection = pymongo.MongoClient(settings['MONGODB_SERVER'], settings['MONGODB_PORT']) db = connection[settings['MONGODB_DB']] self.collection = db[settings['MONGODB_COLLECTION']] def process_item(self, item, spider): #Remove invalid data valid = True for data in item: if not data: valid = False raise DropItem("Missing %s of blogpost from %s" %(data, item['url'])) if valid: #Insert data into database new_moive=[&#123; "name":item['name'][0], "year":item['year'][0], "score":item['score'], "director":item['director'], "classification":item['classification'], "actor":item['actor'] &#125;] self.collection.insert(new_moive) log.msg("Item wrote to MongoDB database %s/%s" % (settings['MONGODB_DB'], settings['MONGODB_COLLECTION']), level=log.DEBUG, spider=spider) return item 修改settings.py文件对项目进行配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# -*- coding: utf-8 -*-# Scrapy settings for douban project## For simplicity, this file contains only settings considered important or# commonly used. You can find more settings consulting the documentation:## https://doc.scrapy.org/en/latest/topics/settings.html# https://doc.scrapy.org/en/latest/topics/downloader-middleware.html# https://doc.scrapy.org/en/latest/topics/spider-middleware.htmlBOT_NAME = 'douban'SPIDER_MODULES = ['douban.spiders']NEWSPIDER_MODULE = 'douban.spiders'# Crawl responsibly by identifying yourself (and your website) on the user-agentUSER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.54 Safari/536.5'# Obey robots.txt rulesROBOTSTXT_OBEY = True# Configure maximum concurrent requests performed by Scrapy (default: 16)# CONCURRENT_REQUESTS = 32# Configure a delay for requests for the same website (default: 0)# See https://doc.scrapy.org/en/latest/topics/settings.html#download-delay# See also autothrottle settings and docsDOWNLOAD_DELAY = 3RANDOMIZE_DOWNLOAD_DELAY = True# The download delay setting will honor only one of:# CONCURRENT_REQUESTS_PER_DOMAIN = 16# CONCURRENT_REQUESTS_PER_IP = 16# Disable cookies (enabled by default)COOKIES_ENABLED = TrueMONGODB_SERVER = '120.77.222.217'MONGODB_PORT = 27017MONGODB_DB = 'douban'MONGODB_COLLECTION = 'movie'# Disable Telnet Console (enabled by default)# TELNETCONSOLE_ENABLED = False# Override the default request headers:# DEFAULT_REQUEST_HEADERS = &#123;# 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',# 'Accept-Language': 'en',# &#125;# Enable or disable spider middlewares# See https://doc.scrapy.org/en/latest/topics/spider-middleware.html# SPIDER_MIDDLEWARES = &#123;# 'douban.middlewares.DoubanSpiderMiddleware': 543,# &#125;# Enable or disable downloader middlewares# See https://doc.scrapy.org/en/latest/topics/downloader-middleware.html# DOWNLOADER_MIDDLEWARES = &#123;# 'douban.middlewares.DoubanDownloaderMiddleware': 543,# &#125;# Enable or disable extensions# See https://doc.scrapy.org/en/latest/topics/extensions.html# EXTENSIONS = &#123;# 'scrapy.extensions.telnet.TelnetConsole': None,# &#125;# Configure item pipelines# See https://doc.scrapy.org/en/latest/topics/item-pipeline.htmlITEM_PIPELINES = &#123; 'douban.pipelines.DoubanPipeline': 400,&#125;LOG_LEVEL = 'DEBUG'# Enable and configure the AutoThrottle extension (disabled by default)# See https://doc.scrapy.org/en/latest/topics/autothrottle.html#AUTOTHROTTLE_ENABLED = True# The initial download delay#AUTOTHROTTLE_START_DELAY = 5# The maximum download delay to be set in case of high latencies#AUTOTHROTTLE_MAX_DELAY = 60# The average number of requests Scrapy should be sending in parallel to# each remote server#AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0# Enable showing throttling stats for every response received:#AUTOTHROTTLE_DEBUG = False# Enable and configure HTTP caching (disabled by default)# See https://doc.scrapy.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settingsHTTPCACHE_ENABLED = TrueHTTPCACHE_EXPIRATION_SECS = 0HTTPCACHE_DIR = 'httpcache'HTTPCACHE_IGNORE_HTTP_CODES = []HTTPCACHE_STORAGE = 'scrapy.extensions.httpcache.FilesystemCacheStorage' 补充说明XPath语法 XPath路径表达式：XPath使用路径表达式来选取XML文档中的节点或者节点集。 XPath节点：元素、属性、文本、命名空间、处理指令、注释、根节点。 XPath语法。（注：下面的例子来自于菜鸟教程网站的XPath教程。) XML文件。 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;bookstore&gt; &lt;book&gt; &lt;title lang="eng"&gt;Harry Potter&lt;/title&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book&gt; &lt;title lang="eng"&gt;Learning XML&lt;/title&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; XPath语法。 | 路径表达式 | 结果 || ————— | ———————————————————— || bookstore | 选取 bookstore 元素的所有子节点。 || /bookstore | 选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ || bookstore/book | 选取属于 bookstore 的子元素的所有 book 元素。 || //book | 选取所有 book 子元素，而不管它们在文档中的位置。 || bookstore//book | 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。 || //@lang | 选取名为 lang 的所有属性。 | XPath谓词。 | 路径表达式 | 结果 || ———————————- | ———————————————————— || /bookstore/book[1] | 选取属于 bookstore 子元素的第一个 book 元素。 || /bookstore/book[last()] | 选取属于 bookstore 子元素的最后一个 book 元素。 || /bookstore/book[last()-1] | 选取属于 bookstore 子元素的倒数第二个 book 元素。 || /bookstore/book[position()35.00] | 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 || /bookstore/book[price&gt;35.00]/title | 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 | 通配符用法。 | 路径表达式 | 结果 || ———— | ——————————— || /bookstore/ | 选取 bookstore 元素的所有子元素。 || // | 选取文档中的所有元素。 || //title[@*] | 选取所有带有属性的 title 元素。 | 选取多个路径。 | 路径表达式 | 结果 || ——————————– | ———————————————————— || //book/title | //book/price | 选取 book 元素的所有 title 和 price 元素。 || //title | //price | 选取文档中的所有 title 和 price 元素。 || /bookstore/book/title | //price | 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。 | 在Chrome浏览器中查看元素XPath语法那些年我们踩过的那些坑坑01 - 整数比较的坑在 Python 中一切都是对象，整数也是对象，在比较两个整数时有两个运算符==和is，它们的区别是： is比较的是两个整数对象的id值是否相等，也就是比较两个引用是否代表了内存中同一个地址。 ==比较的是两个整数对象的内容是否相等，使用==时其实是调用了对象的__eq__()方法。 知道了is和==的区别之后，我们可以来看看下面的代码，了解Python中整数比较有哪些坑： 123456789101112131415161718192021222324def main(): x = y = -1 while True: x += 1 y += 1 if x is y: print('%d is %d' % (x, y)) else: print('Attention! %d is not %d' % (x, y)) break x = y = 0 while True: x -= 1 y -= 1 if x is y: print('%d is %d' % (x, y)) else: print('Attention! %d is not %d' % (x, y)) breakif __name__ == '__main__': main() 上面代码的部分运行结果如下图所示，出现这个结果的原因是Python出于对性能的考虑所做的一项优化。对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫small_ints的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。Python把频繁使用的整数对象的值定在[-5, 256]这个区间，如果需要这个范围的整数，就直接从small_ints中获取引用而不是临时创建新的对象。因为大于256或小于-5的整数不在该范围之内，所以就算两个整数的值是一样，但它们是不同的对象。 当然仅仅如此这个坑就不值一提了，我们再看看下面的代码。 1234567891011121314import disa = 257def main(): b = 257 # 第6行 c = 257 # 第7行 print(b is c) # True print(a is b) # False print(a is c) # Falseif __name__ == "__main__": main() 程序的执行结果已经用注释写在代码上了。够坑吧！看上去a、b和c的值都是一样的，但是is运算的结果却不一样。为什么会出现这样的结果，首先我们来说说Python程序中的代码块。所谓代码块是程序的一个最小的基本执行单位，一个模块文件、一个函数体、一个类、交互式命令中的单行代码都叫做一个代码块。上面的代码由两个代码块构成，a = 257是一个代码块，main函数是另外一个代码块。Python内部为了进一步提高性能，凡是在一个代码块中创建的整数对象，如果值不在small_ints缓存范围之内，但在同一个代码块中已经存在一个值与其相同的整数对象了，那么就直接引用该对象，否则创建一个新的对象出来，这条规则对不在small_ints范围的负数并不适用，对负数值浮点数也不适用，但对非负浮点数和字符串都是适用的，这一点读者可以自行证明。所以 b is c返回了True，而a和b不在同一个代码块中，虽然值都是257，但却是两个不同的对象，is运算的结果自然是False了。为了验证刚刚的结论，我们可以借用dis模块（听名字就知道是进行反汇编的模块）从字节码的角度来看看这段代码。如果不理解什么是字节码，可以先看看《谈谈 Python 程序的运行原理》)这篇文章。可以先用import dis导入dis模块并按照如下所示的方式修改代码。 123if __name__ == "__main__": main() dis.dis(main) 代码的执行结果如下图所示。可以看出代码第6行和第7行，也就是main函数中的257是从同一个位置加载的，因此是同一个对象；而代码第9行的a明显是从不同的地方加载的，因此引用的是不同的对象。 如果还想对这个问题进行进一步深挖，推荐大家阅读《Python整数对象实现原理》这篇文章。 坑02 - 嵌套列表的坑Python中有一种内置的数据类型叫列表，它是一种容器，可以用来承载其他的对象（准确的说是其他对象的引用），列表中的对象可以称为列表的元素，很明显我们可以把列表作为列表中的元素，这就是所谓的嵌套列表。嵌套列表可以模拟出现实中的表格、矩阵、2D游戏的地图（如植物大战僵尸的花园）、棋盘（如国际象棋、黑白棋）等。但是在使用嵌套的列表时要小心，否则很可能遭遇非常尴尬的情况，下面是一个小例子。 12345678910111213def main(): names = ['关羽', '张飞', '赵云', '马超', '黄忠'] subjs = ['语文', '数学', '英语'] scores = [[0] * 3] * 5 for row, name in enumerate(names): print('请输入%s的成绩' % name) for col, subj in enumerate(subjs): scores[row][col] = float(input(subj + ': ')) print(scores)if __name__ == '__main__': main() 我们希望录入5个学生3门课程的成绩，于是定义了一个有5个元素的列表，而列表中的每个元素又是一个由3个元素构成的列表，这样一个列表的列表刚好跟一个表格是一致的，相当于有5行3列，接下来我们通过嵌套的for-in循环输入每个学生3门课程的成绩。程序执行完成后我们发现，每个学生3门课程的成绩是一模一样的，而且就是最后录入的那个学生的成绩。 要想把这个坑填平，我们首先要区分对象和对象的引用这两个概念，而要区分这两个概念，还得先说说内存中的栈和堆。我们经常会听人说起“堆栈”这个词，但实际上“堆”和“栈”是两个不同的概念。众所周知，一个程序运行时需要占用一些内存空间来存储数据和代码，那么这些内存从逻辑上又可以做进一步的划分。对底层语言（如C语言）有所了解的程序大都知道，程序中可以使用的内存从逻辑上可以为五个部分，按照地址从高到低依次是：栈（stack）、堆（heap）、数据段（data segment）、只读数据段（static area）和代码段（code segment）。其中，栈用来存储局部、临时变量，以及函数调用时保存现场和恢复现场需要用到的数据，这部分内存在代码块开始执行时自动分配，代码块执行结束时自动释放，通常由编译器自动管理；堆的大小不固定，可以动态的分配和回收，因此如果程序中有大量的数据需要处理，这些数据通常都放在堆上，如果堆空间没有正确的被释放会引发内存泄露的问题，而像Python、Java等编程语言都使用了垃圾回收机制来实现自动化的内存管理（自动回收不再使用的堆空间）。所以下面的代码中，变量a并不是真正的对象，它是对象的引用，相当于记录了对象在堆空间的地址，通过这个地址我们可以访问到对应的对象；同理，变量b是列表容器的引用，它引用了堆空间上的列表容器，而列表容器中并没有保存真正的对象，它保存的也仅仅是对象的引用。 12a = object()b = ['apple', 'pitaya', 'grape'] 知道了这一点，我们可以回过头看看刚才的程序，我们对列表进行[[0] * 3] * 5操作时，仅仅是将[0, 0, 0]这个列表的地址进行了复制，并没有创建新的列表对象，所以容器中虽然有5个元素，但是这5个元素引用了同一个列表对象，这一点可以通过id函数检查scores[0]和scores[1]的地址得到证实。所以正确的代码应该按照如下的方式进行修改。 1234567891011121314def main(): names = ['关羽', '张飞', '赵云', '马超', '黄忠'] subjs = ['语文', '数学', '英语'] scores = [[]] * 5 for row, name in enumerate(names): print('请输入%s的成绩' % name) scores[row] = [0] * 3 for col, subj in enumerate(subjs): scores[row][col] = float(input(subj + ': ')) print(scores)if __name__ == '__main__': main() 或者 1234567891011121314def main(): names = ['关羽', '张飞', '赵云', '马超', '黄忠'] subjs = ['语文', '数学', '英语'] scores = [[0] * 3 for _ in range(5)] for row, name in enumerate(names): print('请输入%s的成绩' % name) scores[row] = [0] * 3 for col, subj in enumerate(subjs): scores[row][col] = float(input(subj + ': ')) print(scores)if __name__ == '__main__': main() 如果对内存的使用不是很理解，可以看看PythonTutor网站上提供的代码可视化执行功能，通过可视化执行，我们可以看到内存是如何分配的，从而避免在使用嵌套列表或者复制对象时可能遇到的坑。 坑03 - 访问修饰符的坑用Python做过面向对象编程的人都知道，Python的类提供了两种访问控制权限，一种是公开，一种是私有（在属性或方法前加上双下划线）。而用惯了Java或C#这类编程语言的人都知道，类中的属性（数据抽象）通常都是私有的，其目的是为了将数据保护起来；而类中的方法（行为抽象）通常都是公开的，因为方法是对象向外界提供的服务。但是Python并没有从语法层面确保私有成员的私密性，因为它只是对类中所谓的私有成员进行了命名的变换，如果知道命名的规则照样可以直接访问私有成员，请看下面的代码。 123456789101112131415161718192021class Student(object): def __init__(self, name, age): self.__name = name self.__age = age def __str__(self): return self.__name + ': ' + str(self.__age)def main(): stu = Student('骆昊', 38) # 'Student' object has no attribute '__name' # print(stu.__name) # 用下面的方式照样可以访问类中的私有成员 print(stu._Student__name) print(stu._Student__age)if __name__ == '__main__': main() Python为什么要做出这样的设定呢？用一句广为流传的格言来解释这个问题：“We are all consenting adults here”（我们都是成年人）。这句话表达了很多Python程序员的一个共同观点，那就是开放比封闭要好，我们应该自己对自己的行为负责而不是从语言层面来限制对数据或方法的访问。 所以在Python中我们实在没有必要将类中的属性或方法用双下划线开头的命名处理成私有的成员，因为这并没有任何实际的意义。如果想对属性或方法进行保护，我们建议用单下划线开头的受保护成员，虽然它也不能真正保护这些属性或方法，但是它相当于给调用者一个暗示，让调用者知道这是不应该直接访问的属性或方法，而且这样做并不影响子类去继承这些东西。 需要提醒大家注意的是，Python类中的那些魔法方法，如__str__、__repr__等，这些方法并不是私有成员哦，虽然它们以双下划线开头，但是他们也是以双下划线结尾的，这种命名并不是私有成员的命名，这一点对初学者来说真的很坑。 玩转PyCharm(上)PyCharm是由JetBrains公司开发的提供给Python专业的开发者的一个集成开发环境，它最大的优点是能够大大提升Python开发者的工作效率，为开发者集成了很多用起来非常顺手的功能，包括代码调试、高亮语法、代码跳转、智能提示、自动补全、单元测试、版本控制等等。此外，PyCharm还提供了对一些高级功能的支持，包括支持基于Django框架的Web开发、。 PyCharm的安装可以在JetBrains公司的官方网站找到PyCharm的下载链接，有两个可供下载的版本一个是社区版一个是专业版，社区版在Apache许可证下发布，专业版在专用许可证下发布（需要购买授权下载后可试用30天），其拥有许多额外功能。安装PyCharm需要有JRE（Java运行时环境）的支持，如果没有可以在安装过程中选择在线下载安装。 说明：如果你是一名学生，希望购买PyCharm来使用，可以看看教育优惠官方申请指南。 首次使用的设置第一次使用PyCharm时，会有一个导入设置的向导，如果之前没有使用PyCharm或者没有保存过设置的就直接选择“Do not import settings”进入下一步即可。 专业版的PyCharm是需要激活的，强烈建议为优秀的软件支付费用，如果不用做商业用途，我们可以暂时选择试用30天或者使用社区版的PyCharm。 接下来是选择UI主题，这个可以根据个人喜好进行选择。 再接下来是创建可以在终端（命令行）中使用PyCharm项目的启动脚本，当然也可以直接跳过这一步。 然后可以选择需要安装哪些插件，我们可以暂时什么都不安装等需要的时候再来决定。 用PyCharm创建项目点击上图中的“Start using PyCharm”按钮就可以开始使用PyCharm啦，首先来到的是一个欢迎页，在欢迎页上我们可以选择“创建新项目”、“打开已有项目”和“从版本控制系统中检出项目”。 如果选择了“Create New Project”来创建新项目就会打一个创建项目的向导页。 在如上图所示的界面中，我们可以选择创建项目的模板，包括了纯Python项目、基于各种不同框架的Web项目、Web前端项目、跨平台项目等各种不同的项目模板。如果选择Python的项目，那么有一个非常重要的设定是选择“New environment…”（创建新的虚拟环境）还是使用“Existing Interpreter”（已经存在的解释器）。前者肯定是更好的选择，因为新的虚拟环境不会对系统环境变量中配置的Python环境造成影响，简单举个例子就是你在虚拟环境下安装或者更新了任何三方库，它并不会对系统原有的Python解释器造成任何的影响，但代价是需要额外的存储空间来建立这个虚拟环境。 项目创建完成后就可以开始新建各种文件来书写Python代码了。 在工作窗口的右键菜单中可以找到“Run …”和“Debug …”菜单项，通过这两个菜单项我们就可以运行和调试我们的代码啦。建议关注一下菜单栏中的“Code”、“Refactor”和“Tools”菜单，这里面为编写Python代码提供了很多有用的帮助，我们在后面也会陆续为大家介绍这些功能。 要不要使用复杂表达式Perl语言的原作者Larry Wall曾经说过，伟大的程序员都有三个优点：懒惰、暴躁和自负。乍一看这三个词语没有一个是褒义词，但在程序员的世界里，这三个词有不同的意义。首先，懒惰会促使程序员去写一些省事儿的程序来辅助自己或别人更好的完成工作，这样我们就无需做那些重复和繁琐的劳动；同理能够用3行代码解决的事情，我们也绝不会写出10行代码来。其次，暴躁会让程序员主动的去完成一些你还没有提出的工作，去优化自己的代码让它更有效率，能够3秒钟完成的任务，我们绝不能容忍1分钟的等待。最后，自负会促使程序员写出可靠无误的代码，我们写代码不是为了接受批评和指责，而是为了让其他人来膜拜。 那么接下来就有一个很有意思的问题值得探讨一下，我们需要一个程序从输入的三个数中找出最大的那个数。这个程序对任何会编程的人来说都是小菜一碟，甚至不会编程的人经过10分钟的学习也能搞定。下面是用来解决这个问题的Python代码。 12345678910a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))if a &gt; b: the_max = aelse: the_max = bif c &gt; the_max: the_max = cprint('The max is:', the_max) 但是我们刚才说了，程序员都是懒惰的，很多程序员都会使用三元条件运算符来改写上面的代码。 123456a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))the_max = a if a &gt; b else bthe_max = c if c &gt; the_max else the_maxprint('The max is:', the_max) 需要说明的是，Python在2.5版本以前是没有上面代码第4行和第5行中使用的三元条件运算符的，究其原因是Guido van Rossum（Python之父）认为三元条件运算符并不能帮助 Python变得更加简洁，于是那些习惯了在C/C++或Java中使用三元条件运算符（在这些语言中，三元条件运算符也称为“Elvis运算符”，因为?:放在一起很像著名摇滚歌手猫王Elvis的大背头）的程序员试着用and和or运算符的短路特性来模拟出三元操作符，于是在那个年代，上面的代码是这样写的。 123456a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))the_max = a &gt; b and a or bthe_max = c &gt; the_max and c or the_maxprint('The max is:', the_max) 但是这种做法在某些场景下是不能成立的，且看下面的代码。 123456a = 0b = -100# 下面的代码本来预期输出a的值，结果却得到了b的值# 因为a的值0在进行逻辑运算时会被视为False来处理print(True and a or b)# print(a if True else b) 所以在Python 2.5以后引入了三元条件运算符来避免上面的风险（上面代码被注释掉的最后一句话）。那么，问题又来了，上面的代码还可以写得更简短吗？答案是肯定的。 1234a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))print('The max is:', (a if a &gt; b else b) if (a if a &gt; b else b) &gt; c else c) 但是，这样做真的好吗？如此复杂的表达式是不是让代码变得晦涩了很多呢？我们发现，在实际开发中很多开发者都喜欢过度的使用某种语言的特性或语法糖，于是简单的多行代码变成了复杂的单行表达式，这样做真的好吗？这个问题我也不止一次的问过自己，现在我能给出的答案是下面的代码，使用辅助函数。 12345678def the_max(x, y): return x if x &gt; y else ya = int(input('a = '))b = int(input('b = '))c = int(input('c = '))print('The max is:', the_max(the_max(a, b), c)) 上面的代码中，我定义了一个辅助函数the_max用来找出参数传入的两个值中较大的那一个，于是下面的输出语句可以通过两次调用the_max函数来找出三个数中的最大值，现在代码的可读性是不是好了很多。用辅助函数来替代复杂的表达式真的是一个不错的选择，关键是比较大小的逻辑转移到这个辅助函数后不仅可以反复调用它，而且还可以进行级联操作。 当然，很多语言中比较大小的函数根本没有必要自己来实现（通常都是内置函数），Python也是如此。Python内置的max函数利用了Python对可变参数的支持，允许一次性传入多个值或者一个迭代器并找出那个最大值，所以上面讨论的问题在Python中也就是一句话的事，但是从复杂表达式到使用辅助函数简化复杂表达式这个思想是非常值得玩味的，所以分享出来跟大家做一个交流。 1234a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))print('The max is:', max(a, b, c)) PEP 8风格指南PEP是Python Enhancement Proposal的缩写，通常翻译为“Python增强提案”。每个PEP都是一份为Python社区提供的指导Python往更好的方向发展的技术文档，其中的第8号增提案即PEP 8是针对Python语言编订的代码风格指南。尽管我们可以在保证语法没有问题的前提下随意书写Python代码，但是在实际开发中，采用一致的风格书写出可读性强的代码是每个专业的程序员应该做到的事情，也是每个公司的编程规范中会提出的要求，这些在多人协作开发一个项目（团队开发）的时候显得尤为重要。我们可以从Python官方网站的PEP 8链接中找到该文档，下面我们对该文档的关键部分做一个简单的总结。 空格的使用 使用空格来表示缩进而不要用制表符（Tab）。这一点对习惯了其他编程语言的人来说简直觉得不可理喻，因为绝大多数的程序员都会用Tab来表示缩进，但是要知道Python并没有像C/C++或Java那样的用花括号来构造一个代码块的语法，在Python中分支和循环结构都使用缩进来表示哪些代码属于同一个级别，鉴于此Python代码对缩进以及缩进宽度的依赖比其他很多语言都强得多。在不同的编辑器中，Tab的宽度可能是2、4或8个字符，甚至是其他更离谱的值，用Tab来表示缩进对Python代码来说可能是一场灾难。 和语法相关的每一层缩进都用4个空格来表示。 每行的字符数不要超过79个字符，如果表达式因太长而占据了多行，除了首行之外的其余各行都应该在正常的缩进宽度上再加上4个空格。 函数和类的定义，代码前后都要用两个空行进行分隔。 在同一个类中，各个方法之间应该用一个空行进行分隔。 二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。 标识符命名PEP 8倡导用不同的命名风格来命名Python中不同的标识符，以便在阅读代码时能够通过标识符的名称来确定该标识符在Python中扮演了怎样的角色（在这一点上，Python自己的内置模块以及某些第三方模块都做得并不是很好）。 变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。 类中受保护的实例属性，应该以一个下划线开头。 类中私有的实例属性，应该以两个下划线开头。 类和异常的命名，应该每个单词首字母大写。 模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。 类的实例方法，应该把第一个参数命名为self以表示对象自身。 类的类方法，应该把第一个参数命名为cls以表示该类自身。 表达式和语句在Python之禅（可以使用import this查看）中有这么一句名言：“There should be one– and preferably only one –obvious way to do it.”，翻译成中文是“做一件事应该有而且最好只有一种确切的做法”，这句话传达的思想在PEP 8中也是无处不在的。 采用内联形式的否定词，而不要把否定词放在整个表达式的前面。例如if a is not b就比if not a is b更容易让人理解。 不要用检查长度的方式来判断字符串、列表等是否为None或者没有元素，应该用if not x这样的写法来检查它。 就算if分支、for循环、except异常捕获等中只有一行代码，也不要将代码和if、for、except等写在一起，分开写才会让代码更清晰。 import语句总是放在文件开头的地方。 引入模块的时候，from math import sqrt比import math更好。 如果有多个import语句，应该将其分为三部分，从上到下分别是Python标准模块、第三方模块和自定义模块，每个部分内部应该按照模块名称的字母表顺序来排列。 Python惯例“惯例”这个词指的是“习惯的做法，常规的办法，一贯的做法”，与这个词对应的英文单词叫“idiom”。由于Python跟其他很多编程语言在语法和使用上还是有比较显著的差别，因此作为一个Python开发者如果不能掌握这些惯例，就无法写出“Pythonic”的代码。下面我们总结了一些在Python开发中的惯用的代码。 让代码既可以被导入又可以被执行。 1if __name__ == '__main__': 用下面的方式判断逻辑“真”或“假”。 12if x:if not x: 好的代码： 12345name = 'jackfrued'fruits = ['apple', 'orange', 'grape']owners = &#123;'1001': '骆昊', '1002': '王大锤'&#125;if name and fruits and owners: print('I love fruits!') 不好的代码： 12345name = 'jackfrued'fruits = ['apple', 'orange', 'grape']owners = &#123;'1001': '骆昊', '1002': '王大锤'&#125;if name != '' and len(fruits) &gt; 0 and owners != &#123;&#125;: print('I love fruits!') 善于使用in运算符。 12if x in items: # 包含for x in items: # 迭代 好的代码： 123name = 'Hao LUO'if 'L' in name: print('The name has an L in it.') 不好的代码： 123name = 'Hao LUO'if name.find('L') != -1: print('This name has an L in it!') 不使用临时变量交换两个值。 1a, b = b, a 用序列构建字符串。 好的代码： 123chars = ['j', 'a', 'c', 'k', 'f', 'r', 'u', 'e', 'd']name = ''.join(chars)print(name) # jackfrued 不好的代码： 12345chars = ['j', 'a', 'c', 'k', 'f', 'r', 'u', 'e', 'd']name = ''for char in chars: name += charprint(name) # jackfrued EAFP优于LBYL。 EAFP - Easier to Ask Forgiveness than Permission. LBYL - Look Before You Leap. 好的代码： 123456d = &#123;'x': '5'&#125;try: value = int(d['x']) print(value)except (KeyError, TypeError, ValueError): value = None 不好的代码： 1234567d = &#123;'x': '5'&#125;if 'x' in d and isinstance(d['x'], str) \ and d['x'].isdigit(): value = int(d['x']) print(value)else: value = None 使用enumerate进行迭代。 好的代码： 123fruits = ['orange', 'grape', 'pitaya', 'blueberry']for index, fruit in enumerate(fruits): print(index, ':', fruit) 不好的代码： 12345fruits = ['orange', 'grape', 'pitaya', 'blueberry']index = 0for fruit in fruits: print(index, ':', fruit) index += 1 用生成式生成列表。 好的代码： 123data = [7, 20, 3, 15, 11]result = [num * 3 for num in data if num &gt; 10]print(result) # [60, 45, 33] 不好的代码： 123456data = [7, 20, 3, 15, 11]result = []for i in data: if i &gt; 10: result.append(i * 3)print(result) # [60, 45, 33] 用zip组合键和值来创建字典。 好的代码： 1234keys = ['1001', '1002', '1003']values = ['骆昊', '王大锤', '白元芳']d = dict(zip(keys, values))print(d) 不好的代码： 123456keys = ['1001', '1002', '1003']values = ['骆昊', '王大锤', '白元芳']d = &#123;&#125;for i, key in enumerate(keys): d[key] = values[i]print(d) 说明：这篇文章的内容来自于网络，有兴趣的读者可以阅读原文。 Python参考书籍入门读物 《Python基础教程》（Beginning Python From Novice to Professional） 《Python学习手册》（Learning Python） 《Python编程》（Programming Python） 《Python Cookbook》 《Python程序设计》（Python Programming: An Introduction to Computer Science） 《Modern Python Cookbook》 进阶读物 《Python核心编程》（Core Python Applications Programming） 《流畅的Python》（Fluent Python） 《Effective Python：编写高质量Python代码的59个有效方法》（Effective Python 59 Specific Ways to Write Better Python） 《Python设计模式》（Learning Python Design Patterns） 《Python高级编程》（Expert Python Programming） 《Python性能分析与优化》（Mastering Python High Performance） Web框架 《Django基础教程》（Tango with Django） 《轻量级Django》（Lightweight Django） 《Python Web开发：测试驱动方法》（Test-Driven Development with Python） 《Web Development with Django Cookbook》 《Test-Driven Development with Django》 《Django Project Blueprints 》 《Flask Web开发：基于Python的Web应用开发实战》（Flask Web Development: Developing Web Applications with Python） 《深入理解Flask》（Mastering Flask） 爬虫开发 《用Python写网络爬虫》（Web Scraping with Python） 《精通Python爬虫框架Scrapy》（Learning Scrapy） 《Python网络数据采集》（Web Scraping with Python） 《Python爬虫开发与项目实战》 《Python 3网络爬虫开发实战》 数据分析 《利用Python进行数据分析》（Python for Data Analysis） 《Python数据科学手册》（Python Data Science Handbook） 《Python金融大数据分析》（Python for Finance） 《Python数据可视化编程实战》（Python Data Visualization Cookbook） 《Python数据处理》（Data Wrangling with Python） 机器学习 《Python机器学习基础教程》（Introduction to Machine Learning with Python） 《Python机器学习实践指南》（Python Machine Learning Blueprints） 《Python Machine Learning Case Studies》 《Python机器学习实践：测试驱动的开发方法》（Thoughtful Machine Learning with Python A Test Driven Approach） 《Python机器学习经典实例》（Python Machine Learning Cookbook） 《TensorFlow：实战Google深度学习框架》]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷题问题集合]]></title>
    <url>%2F2018%2F03%2F30%2F%E5%88%B7%E9%A2%98%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[学的比较杂，忘得比较快。好记性不如烂键盘。 机试题字符串最后一个单词的长度Question；12345678910111213题目描述计算字符串最后一个单词的长度，单词以空格隔开。 输入描述:一行字符串，非空，长度小于5000。输出描述:整数N，最后一个单词的长度。示例1输入hello world输出5 Solution:12str = input().strip().split()print(len(str[-1])) strip()usage: strip()方法用于移除字符串头尾指定的字符（默认为空格) 123456789str = "0000000 Runoob 0000000"; print str.strip( '0' ); # 去除首尾字符 0//输出 Runoob str2 = " Runoob "; # 去除首尾空格print str2.strip();//输出 Runoob split()split()通过指定分隔符对字符串进行切片，如果参数num有指定值，则仅分隔 num 个子字符串.usage； str.split(str=””, num=string.count(str))str – 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。num – 分割次数。12345678str = "Line1-abcdef \nLine2-abc \nLine4-abcd";print str.split( );print str.split(' ', 1 );//输出 ['Line1-abcdef', 'Line2-abc', 'Line4-abcd']['Line1-abcdef', '\nLine2-abc \nLine4-abcd'] len()len() 方法返回对象（字符、列表、元组等）长度或项目个数。uasge: len(s)123&gt;&gt;&gt;str = "runoob"&gt;&gt;&gt; len(str) # 字符串长度6 计算字符串个数Question：1234567891011121314题目描述写出一个程序，接受一个有字母和数字以及空格组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。输入描述:输入一个有字母和数字以及空格组成的字符串，和一个字符。输出描述:输出输入字符串中含有该字符的个数。示例1输入ABCDEF A输出1 Solution:1234567891011 #-*-coding:utf-8-*-str ="nhrwlbcc8m7c5hih9mhalw98k0322wf2jjm47kk3ntm9snfrflzzundn7d608usy049asxalzjk7izj6amcqhr8uubc04g52mcjboj2fmge2l6iarizfu4yve5o4i3srf5zgqbg82ckcotdeqp760mc9gzei5dzk5gj9x9yj05o3hle0ii64krkkp5i7blh7nbu3gu5vgi2scyn4yqx3z4vcjbyzhnqkh887izotjkg2l0mit0k14vyn39 t"N = str[-1]str = str[:-1].strip()counter=0for i in str: if N == i: counter = counter+1print(counter) 最优的Solution:123a=input().lower()b=input().lower()print(a.count(b)) lower()lower() 方法转换字符串中所有大写字符为小写。增加本题的鲁棒性。 count()count() 方法用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。usage:str.count(sub, start= 0,end=len(string))12345678910str="www.runoob.com"sub='o'print ("str.count('o') : ", str.count(sub))sub='run'print ("str.count('run', 0, 10) : ", str.count(sub,0,10))//输出 str.count('o') : 3str.count('run', 0, 10) : 1 sub – 搜索的子字符串start – 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。end – 字符串中结束搜索的位置。字符中第一个字符的索引为0。默认为字符串的最后一个位置。 明明的随机数1234567891011121314151617181920212223242526272829303132333435363738394041424344题目描述明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。Input Param n 输入随机数的个数 inputArray n个随机整数组成的数组 Return Value OutputArray 输出处理后的随机整数注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。输入描述:输入多行，先输入随机整数的个数，再输入相应个数的整数输出描述:返回多行，处理后的结果示例1输入11102040326740208930040015输出10152032406789300400 Solution:12345678910import randomn = range(65)inputArray = []outputArray = []for i in n: inputArray.append(random.randint(1,1000))for j in inputArray: if j not in outputArray: outputArray.append(j)print(sorted(outputArray)) 牛逼解法：1234567while True: try: a,res=int(input()),set() for i in range(a):res.add(int(input())) for i in sorted(res):print(i) except: break randint()使用了 random 模块的 randint() 函数来生成随机数1使用方法为:random.randint(1,1000) if的另外一种使用方法：123非的关系：if j not in outputArray: outputArray.append(j) sort() &amp; sorted()sort 与 sorted 区别：sort是应用在list上的方法，sorted可以对所有可迭代的对象进行排序操作。list的sort方法返回的是对已经存在的列表进行操作，而内建函数sorted方法返回的是一个新的list，而不是在原来的基础上进行的操作。 多个变量赋值1a,res=int(input()),set() Python允许你同时为多个变量赋值。例如：1a = b = c = 1 以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。也可以为多个对象指定多个变量。例如：1a, b, c = 1, 2, "john" 以上实例，两个整型对象1和2的分配给变量 a 和 b，字符串对象 “john” 分配给变量 c。 set()set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等12345678910&gt;&gt;&gt;x = set('runoob')&gt;&gt;&gt; y = set('google')&gt;&gt;&gt; x, y(set(['b', 'r', 'u', 'o', 'n']), set(['e', 'o', 'g', 'l'])) # 重复的被删除&gt;&gt;&gt; x &amp; y # 交集set(['o'])&gt;&gt;&gt; x | y # 并集set(['b', 'e', 'g', 'l', 'o', 'n', 'r', 'u'])&gt;&gt;&gt; x - y # 差集set(['r', 'b', 'u', 'n']) Python 装饰器from某乎：1内裤可以用来遮羞，但是到了冬天它没法为我们防风御寒，聪明的人们发明了长裤。长裤就类似于装饰器，在不影响内裤作用的前提下，给我们身子提供了保暖的功效。 装饰器本质上是一个Python函数，可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象，需求的场景：插入日志、性能测试、事务处理、缓存、权限校验。 例子： 比如写了很多个简单的函数，你想知道在运行的时候哪些函数在执行，只是想要很简单的在执行完毕之前给它打印一句“start”，应该是这样：123def func_name(arg): print 'Start func_name' sentences 这样做是没有错，但是有想过没，难道想给每一个函数后面都加上那么一句吗？等运行完再一个个的删掉print不觉得麻烦吗？一个不麻烦，十个，一百个呢。装饰器可以这么来：1234567891011121314151617def log(func): def wrapper(*arg,**kw): print 'Start %s' % func return func(*arg,**kw) return wrapper@logdef func_a(arg): pass@logdef fun_b(arg): pass@logdef fun_c(arg): pass 其中，log函数就是装饰器，把装饰器写好后给需要装饰的函数前面加上@log就可以，装饰器节省了代码量，并且在函数不需要装饰的时候直接把@log去掉就可以，只需要用编辑器全局查找然后删除即可。 字符串分隔Q:1234567891011121314151617题目描述•连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组； •长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。 输入描述:连续输入字符串(输入2次,每个字符串长度小于100)输出描述:输出到长度为8的新字符串数组示例1输入abc123456789输出abc000001234567890000000 S:1234567891011121314def pirnt8(line): if len(line) &lt; = 8: print(line+"0"*(8-len(line))) else: while len(line) &gt; 8: print(line[:8]) line = line[8:] print(line + "0"*(8-len(line)))a = input()b = input()pirnt8(a)pirnt8(b) input和raw_input的区别字符的时候可以用raw_input()，当然不怕麻烦也可以用input()手动加’’int类型的时候最好用input() 进制转换Q:1234567891011121314题目描述写出一个程序，接受一个十六进制的数值字符串，输出该数值的十进制字符串。（多组同时输入 ）输入描述:输入一个十六进制的数值字符串。输出描述:输出该数值的十进制字符串。示例1输入0xA输出10 S:12345678while True: try: print(int(input(),16)) except: break注意:注意处理异常，会使用try:except；处理多组输入：while True Python进制函数在python中没有char型，只有字符串类型，这样我们可能将char型转换为整型时极不方便，但是python已经提供了这些转换的内置函数。python 中除了整型，其他进制的只能用字符串来表示： 任意进制–&gt;十进制;int()可以将二进制，八进制，十六进制转换成十进制整型：123456&gt;&gt;&gt; int('1111', 2)15&gt;&gt;&gt; int('f', 16)15&gt;&gt;&gt; int('17', 8)15 整型–&gt;字符；chr()123chr(90)输出:'Z' 字符–&gt;整型:ord()123ord('Z')输出：90 十进制–&gt;十六进制:hex()123hex(255)输出：'0xff' 十进制–&gt;二进制：bin()123bin(255)输出：'0b11111111' 质数因子Q:123456789101112131415161718192021222324252627282930313233题目描述功能:输入一个正整数，按照从小到大的顺序输出它的所有质数的因子（如180的质数因子为2 2 3 3 5 ）最后一个数后面也要有空格详细描述：函数接口说明：public String getResult(long ulDataInput)输入参数：long ulDataInput：输入的正整数返回值：String输入描述:输入一个long型整数输出描述:按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。示例1输入180输出2 2 3 3 5 Solution：这个问题的意思，其实就是让你把输入的整数因式分解，只不过因子必须都是质数例如：180 = 2 2 3 3 5；90 = 2 3 3 * 5；1234567a, res = int(input()), []for i in range(2, a // 2 + 1): while a % i == 0: a = a / i res.append(i)print(" ".join(map(str, res)) + " " if res else str(a) + " ") range()函数语法：range(start, stop[, step]) 参数说明：start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1) xrange()函数说明：用法与range完全相同，所不同的是生成的不是一个数组，而是一个生成器。要生成很大的数字序列的时候，用xrange会比range性能优很多。range会直接生成一个list对象，而xrange则不会直接生成一个list，而是每次调用返回其中的一个值。所以xrange做循环的性能比range好，尤其是返回很大的时候，尽量用xrange吧，除非你是要返回一个列表。 取近似值Q:1234567891011121314题目描述写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。输入描述:输入一个正浮点数值输出描述:输出该数值的近似整数值示例1输入5.5输出6 S:12345a = float(input())if (a - int(a))&gt;=0.5: print(int(a)+1)else: print(int(a)) float(input())输入一个浮点型 int（）int（）默认向下取整 向上取整函数math.ceil()1234import mathmath.ceil(3.2)输出：3 向下取整函数math.floor()12import mathmath.floor( x ) 四舍五入函数round()123456a=3.25;b=3.75round(a);round(b)输出：3.04.0 合并表记录Q:123456789101112131415161718192021题目描述数据表记录包含表索引和数值，请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。输入描述:先输入键值对的个数然后输入成对的index和value值，以空格隔开输出描述:输出合并后的键值对（多行）示例1输入40 10 21 23 4输出0 31 23 4 Solution:12345678910111213from collections import defaultdictwhile True: try: a,dd=int(input()),defaultdict(int) for i in range(a): key,val=map(int,input().split()) dd[key]+=val for i in sorted(dd.keys()): print(str(i)+" "+str(dd[i])) except: break 提取不重复数Q:12345678910111213输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。输入描述:输入一个int型整数输出描述:按照从右向左的阅读顺序，返回一个不含重复数字的新的整数示例1输入9876673输出37689 Solution: 12345678910import matha = list(input())[::-1]c = list(set(a))c.sort(key=a.index)sum = 0b = len(c)-1for i in c: sum = sum + int(i)*pow(10,b) b = b-1print(sum) Python翻转字符串(reverse string)最简单的方法，将步长设置为-1 pow() 方法返回 xy（x的y次方） 的值math 模块 pow() 方法的语法:import mathmath.pow( x, y )内置的方法：pow(x,y) 按照特定=顺序排序c.sort(key=a.index) 字符个数统计Q:12345678910编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)。不在范围内的不作统计。输入描述:输入N个字符，字符在ACSII码范围内。输出描述:输出范围在(0~127)字符的个数。示例1输入abc输出3 Soulution:12345a,res= (set(input()),[])for i in a: if(ord(i)&gt;=0 and ord(i)&lt;=127): res.append(i)print(len(res)) 字符–&gt;整型:ord()123ord('Z')输出：90 字符串反转Q：1234567891011写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。例如：输入描述:输入N个字符输出描述:输出该字符串反转后的字符串示例1输入abcd输出dcba Solution:1print(input()[::-1]) [::-1]步长为-1，表示为可迭代对象进行反转。 数字反转Q:12345678910111213141516171819描述：输入一个整数，将这个整数以字符串的形式逆序输出程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 输入描述:输入一个int整数输出描述:将这个整数以字符串的形式逆序输出示例1输入1516000输出0006151 Solution:1print(str(input()[::-1])) 句子逆序Q:1234567891011121314151617181920212223242526题目描述将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符接口说明/** * 反转句子 * * @param sentence 原句子 * @return 反转后的句子 */public String reverse(String sentence);输入描述:将一个英文语句以单词为单位逆序排放。输出描述:得到逆序的句子示例1输入I am a boy输出boy a am I Solution:1print(" ".join(input().split()[::-1])) 越做越有感觉，能用一行代码完成的绝不写两行 str &gt;&gt;&gt;list1234567891011121314151617str1 = "12345" list1 = list(str1) print list1 str2 = "123 sjhid dhi" list2 = str2.split() #or list2 = str2.split(" ") print list2 str3 = "www.google.com" list3 = str3.split(".") print list3 输出为： [python] view plain copy['1', '2', '3', '4', '5'] ['123', 'sjhid', 'dhi'] ['www', 'google', 'com'] list &gt;&gt;&gt;str12345678910111213str4 = "".join(list3) print str4 str5 = ".".join(list3) print str5 str6 = " ".join(list3) print str6 输出为：[python] view plain copywwwgooglecom www.google.com www google com join()列表和元组转换为字符串则必须依靠join函数join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串语法：join()方法语法:str.join(sequence)参数：sequence – 要连接的元素序列返回值:返回通过指定字符连接序列中元素后生成的新字符串实例:以下实例展示了join()的使用方法：12345str = "-";seq = ("a", "b", "c");# 字符串序列print(str.join( seq ))以上实例输出结果如下：a-b-c 字符串的连接最长路径查找Q:12345678910111213141516171819202122232425262728题目描述给定n个字符串，请对n个字符串按照字典序排列。输入描述:输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。输出描述:数据输出n行，输出结果为按照字典序排列的字符串。示例1输入9captocatcardtwotooupboatboot输出boatbootcapcardcattotootwoup Solution；123a, strings = int(input()),[]for i in range(a):strings.append(input())for str in sorted(strings): print(str) range()老生常谈,注意其多行输入的方法 sorted()sort 与 sorted 区别：sort是应用在list上的方法，sorted可以对所有可迭代的对象进行排序操作。list的sort方法返回的是对已经存在的列表进行操作，而内建函数sorted方法返回的是一个新的list，而不是在原来的基础上进行的操作。 求int型正整数在内存中存储时1的个数Q:1234567891011121314题目描述输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。输入描述: 输入一个整数（int类型）输出描述: 这个数转换成2进制后，输出1的个数示例1输入5输出2 Solution:1print(str(bin(int(input()))).count("1")) 操作越来骚，Python大法好。 bin()十进制转二进制 count()统计字符串中出现特定符号的个数本题即将输入的int型整数转为二进制，再转换为字符串统计“1”出现的个数 Python 质数判断一个大于1的自然数，除了1和它本身外，不能被其他自然数（质数）整除（2, 3, 5, 7等），换句话说就是该数除了1和它本身以外不再有其他的因数。12345678910111213141516171819# Python 程序用于检测用户输入的数字是否为质数 # 用户输入数字num = int(input("请输入一个数字: ")) # 质数大于 1if num &gt; 1: # 查看因子 for i in range(2,num): if (num % i) == 0: print(num,"不是质数") print(i,"乘于",num//i,"是",num) break else: print(num,"是质数") # 如果输入的数字小于或等于 1，不是质数else: print(num,"不是质数")]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门学习--JavaScript]]></title>
    <url>%2F2018%2F03%2F01%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-JavaScript%2F</url>
    <content type="text"><![CDATA[大概了解了HTML和CSS，到了前端的精华JavaScript。学习笔记，ALL FROM 廖雪峰的官方网站 开始12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;script&gt;function displayDate()&#123; document.getElementById("demo").innerHTML=Date();&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;第一个JavaScript 程序&lt;/h1&gt;&lt;p id="demo"&gt;这是一个段落&lt;/p&gt;&lt;button type="button" onclick="displayDate()"&gt;显示日期&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; JavaScript简介JavaScript是一种运行在浏览器中的解释型的编程语言。在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。随着HTML5在PC和移动端越来越流行，JavaScript变得更加重要了。并且，新兴的Node.js把JavaScript引入到了服务器端，JavaScript已经变成了全能型选手。 基本语法语法JavaScript的语法和Java语言类似，每个语句以;结束，语句块用{…}。但是，JavaScript并不强制要求在每个语句的结尾加;，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上;。 完整的复制语句：1var x = 1; 语句块是一组语句的集合，例如，下面的代码先做了一个判断，如果判断成立，将执行{…}中的所有语句：12345if(2&gt;1)&#123; x = 1; y = 2; z = 3;&#125; 注意花括号{…}内的语句具有缩进，通常是4个空格。缩进不是JavaScript语法要求必须的，但缩进有助于我们理解代码的层次，所以编写代码时要遵守缩进规则。(Python的缩进哈哈哈) 注释以//开头直到行末的字符被视为行注释，注释是给开发人员看到，JavaScript引擎会自动忽略：12// 这是一行注释alert('hello'); // 这也是注释 另一种块注释是用/…/把多行字符包裹起来，把一大“块”视为一个注释：1234/* 从这里开始是块注释仍然是注释仍然是注释注释结束 */ 数据类型和变量NumberJavaScript不区分整数和浮点数，统一用Number表示。以下均为合法： 12345123;//整数0.456;//浮点数-99//负数NaN;//表示 Not a Number,当无法计算结果时用NaN表示Infinity;//表示无限大 Number可以直接做四则运算，规则和数学一致。 字符串字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。 布尔值布尔值和布尔数的表示完全一致，一个布尔值只有true、false两种值。实际上，JavaScript允许对任意数据类型做比较：12false == 0; // truefalse === 0; // false 注意：“==”第一种比较，会自动转换数据类型再比较，很多时候会得到诡异的结果。“===”第二种结比较，不会自动转换数据类型，如果数据类型不一致就会返回false。特例：NaN这个特殊的Number与所有其他值都不相等，包括它自己。1NaN === NaN;//false 唯一能判断NaN的方法是通过isNaN()函数：1isNaN(NaN);//true 还需要注意浮点数的相等比较：11/3 === (1 -2 / 3);//false 浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001;//true null和undefinednull表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。 数组JavaScript的数组可以包括任意数据类型。1[1,2,3.14,'Hello',null,true]; 另一种创建数组的方法是通过Array()函数实现：1new Array(1,2,3);//创建了数组[1,2,3] 数组的元素可以通过索引来访问，索引起始值为0：1234var arr = [1,2,3.14,'Hello',null,true];arr[0];//1arr[5];//truearr[6];//undefined 对象JavaScript的对象是一组由键值组成的无序集合：12345678var person = &#123; name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null&#125; 要获取一个对象的属性，我们用对象变量.属性名的方式：12person.name; // 'Bob'person.zipcode; // null 变量变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如：12345var a; // 申明了变量a，此时a的值为undefinedvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 = '007'; // s_007是一个字符串var Answer = true; // Answer是一个布尔值truevar t = null; // t的值是null 使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次，例如：12var a = 123; // a的值是整数123a = 'ABC'; // a变为字符串 这种变量本身类型不固定的语言称之为动态语言，与Java不同。要显示变量的内容，可以用console.log(x)，打开Chrome的控制台就可以看到结果。12var x = 100;console.log(x); strict模式JavaScript在设计之初，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量：1i = 10;//i现在是全局变量 在同一个页面的不同的JavaScript文件中，如果都不用var申明，恰好都使用了变量i，将造成变量i互相影响，产生难以调试的错误结果。使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。 字符串JavaScript的字符串就是用‘’或者“”括起来的字符。 多行字符串多行字符串的表示方法，用反引号 “... ”表示：1234`这是一个多行字符串`; 模板字符串要把多个字符串连接起来，可以用+号连接：1234var name = '小明'；var age = 20；var message = '你好，' + ',你今年' + age + '岁了！'；alert(message); 如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：1234var name = '小明';var age = 20;var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;alert(message); (这怎么和之前写的Java操作Word模板，操作XML的方法很像) 操作字符串字符串常见的操作如下：12var s = 'Hello, world!';s.length; // 13 要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：1234567var s = 'Hello, world!';s[0]; // 'H's[6]; // ' 's[7]; // 'w's[12]; // '!'s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined JavaScript字符串常用方法toUpperCasetoUpperCase()方法是把一个字符串全部变为大写：12var s = 'Hello';s.toUpperCase();返回HELLO toLowerCasetoLowerCase()方法是把一个字符串全部变为小写：123var s = 'Hello';var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lowerlower; // 'hello' indexOfindexOf()会搜索指定字符串出现的位置：123var s = 'Hello,world';s.indexOf('world');//返回7s.indexOf('World');//没有找到指定的子串，返回-1 substringsubstring()返回指定索引区间的子串：123var s = 'hello,world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' 数组JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。要取得Array的长度，直接访问length属性：12var arr = [1,2,3.14,'Hello',null,true];arr.length;//6 直接给Array的length赋一个新的值会导致Array大小的变化：123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array：123var arr = ['A', 'B', 'C'];arr[1] = 99;arr; // arr现在变为['A', 99, 'C'] 如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化：123var arr = [1, 2, 3];arr[5] = 'x';arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] 大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。 indexOf与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置：123var arr = [10,20,'30','xyz'];arr.indexOf(10);//元素10的索引为0arr.indexOf(30);//元素30没有找到，返回-1 sliceslice()就是对应String的substring()版本，截取Array的部分元素，然后返回一个新的Array。123var arr = ['A','B','C','D','E','F','G']；arr.slice(0,3);//从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] 叮：slice()的起止参数包括开始索引，不包括结束索引。如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array：1234var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']aCopy === arr; // false push和poppush()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删掉：123456789var arr = [1,2];arr.push('A','B');//返回Array新的长度：4 arr;//[1,2,'A','B']arr.pop();//pop返回'B'arr;//[1,2,'A']arr.pop();arr.pop();arr.pop();//连续三次pop arr;//[]arr.pop();//空数组继续pop不会报错，而是返回undefinedarr;//[] unshifth和shift向Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：123456789var arr = [1,2];arr.unshift('A','B');//返回Array新的长度：4 arr;//['A', 'B', 1, 2]arr.shift(); // 'A'arr; // ['B', 1, 2]arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次arr; // []arr.shift(); // 空数组继续shift不会报错，而是返回undefinedarr; // [] sortsort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序：123var arr = ['B','C','A'];arr.sort();arr;//['A','B','C'] reversereverse()把整个Array的元素给反转：123var arr = ['one', 'two', 'three'];arr.reverse(); arr; // ['three', 'two', 'one'] splicesplice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2,3,'Google','Facebook');//返回删除的元素['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']//// 只删除,不添加:arr.splice(2,2);//['Google', 'Facebook']arr;// ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] concatconcat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array：1234var arr = ['A','B','C'];var added = arr.concat([1,2,3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] 叮：concat()方法并没有修改当前Array，而是返回了一个新的Array。实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里：12var arr = ['A', 'B', 'C'];arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] joinjoin()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串:12var arr = ['A','B','C',1,2,3];arr.join('-');//'A-B-C-1-2-3' 如果Array的元素不是字符串，将自动转换为字符串后再连接。 多维数组如果数组的某个元素又是一个Array，则可以形成多维数组，例如：1var arr = [[1, 2, 3], [400, 500, 600], '-']; 上述Array包含3个元素，其中头两个元素本身也是Array。练习：如何通过索引取到500这个值：123456'use strict';var arr = [[1, 2, 3], [400, 500, 600], '-'];ans: var x = arr[1][1];console.log(x); // x应该为500 对象JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。 JavaScript的对象用于描述现实世界中的某个对象。例如，为了描述“小明”这个淘气的小朋友，我们可以用若干键值对来描述他： 12345678var xiaoming = &#123; name: 小明, birth:1990, school:'No.1 Middle School', height: 1.70, weight: 65, score:null&#125;; JavaScript用一个{…}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。上述对象申明了一个name属性，值是’小明’，birth属性，值是1990，以及其他一些属性。最后，把这个对象赋值给变量xiaoming后，就可以通过变量xiaoming来获取小明的属性了：12xiaoming.name//'小明'xiaoming.birth//1990 访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用’’括起来：1234var xiaohong = &#123; name:'小红'， 'middle-school':'No.1 Middle School'&#125;; xiaohong的属性名middle-school不是一个有效的变量，就需要用’’括起来。访问这个属性也无法使用.操作符，必须用[‘xxx’]来访问：123xiaohong['middle-school'];//'No.1 Middle School'xiaohong['name'];//'小红'xiaohong.name;//'小红' 也可以用xiaohong[‘name’]来访问xiaohong的name属性，不过xiaohong.name的写法更简洁。我们在编写JavaScript代码的时候，属性名尽量使用标准的变量名，这样就可以直接通过object.prop的形式访问一个属性了。实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。 如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回undefined：1234567'use strict';var xiaoming = &#123; name: '小明'&#125;;console.log(xiaoming.name);console.log(xiaoming.age); // undefined 由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：1234567891011var xiaoming = &#123; name: '小明'&#125;;xiaoming.age; // undefinedxiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming['name']; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 如果我们要检测xiaoming是否拥有某一属性，可以用in操作符：12345678910var xiaoming = &#123; name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null&#125;;'name' in xiaoming; // true'grade' in xiaoming; // false 不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的：1'toString' in xiaoming; // true 因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。 要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：12345var xiaoming = &#123; name: '小明'&#125;;xiaoming.hasOwnProperty('name'); // truexiaoming.hasOwnProperty('toString'); // false 条件判断JavaScript使用if () { … } else { … }来进行条件判断。例如，根据年龄显示不同内容，可以用if语句实现如下：123456var age = 20;if (age &gt;= 18) &#123; // 如果age &gt;= 18为true，则执行if语句块 alert('adult');&#125; else &#123; // 否则执行else语句块 alert('teenager');&#125; 其中else语句是可选的。如果语句块只包含一条语句，那么可以省略{}：12345var age = 20;if (age &gt;= 18) alert('adult');else alert('teenager'); 省略{}的危险之处在于，如果后来想添加一些语句，却忘了写{}，就改变了if…else…的语义，例如：123456var age = 20;if (age &gt;= 18) alert('adult');else console.log('age &lt; 18'); // 添加一行日志 alert('teenager'); // &lt;- 这行语句已经不在else的控制范围了 上述代码的else子句实际上只负责执行console.log(‘age &lt; 18’);，原有的alert(‘teenager’);已经不属于if…else…的控制范围了，它每次都会执行。 相反地，有{}的语句就不会出错：1234567var age = 20;if (age &gt;= 18) &#123; alert('adult');&#125; else &#123; console.log('age &lt; 18'); alert('teenager');&#125; 多行条件判断如果还要更细致地判断条件，可以使用多个if…else…的组合：12345678var age = 3;if (age &gt;= 18) &#123; alert('adult');&#125; else if (age &gt;= 6) &#123; alert('teenager');&#125; else &#123; alert('kid');&#125; 循环JavaScript的循环有两种，一种是for循环，通过初始条件、结束条件和递增条件来循环执行语句块：123456var x = 0;var i;for (i=1; i&lt;=10000; i++) &#123; x = x + i;&#125;x; // 50005000 分析一下for循环的控制条件：i=1 这是初始条件，将变量i置为1；i&lt;=10000 这是判断条件，满足时就继续循环，不满足就退出循环；i++ 这是每次循环后的递增条件，由于每次循环后变量i都会加1，因此它终将在若干次循环后不满足判断条件i&lt;=10000而退出循环。 for循环最常用的地方是利用索引来遍历数组：1234567var arr = ['Apple','Google','Microsoft'];var i,x;for(i=0;i&lt;arr.length;i++)&#123; x = arr[i]; console.log(x)&#125; for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环：1234567var x = 0;for(;;)&#123;//将无限循环下去 if(x &gt; 100)&#123; break;//通过if判断来退出循环 &#125; x++;&#125; for…infor循环的一个变体是for … in循环，它可以把一个对象的所有属性依次循环出来：123456789var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;for (var key in o)&#123; console.log(key);//'name', 'age', 'city'&#125; 要过滤掉对象继承的属性，用hasOwnProperty()来实现：12345678910var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;for (var key in o) &#123; if (o.hasOwnProperty(key)) &#123; console.log(key); // 'name', 'age', 'city' &#125;&#125; 循环数组：Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for … in循环可以直接循环出Array的索引：12345var a = ['A','B','C'];for(var i in a)&#123; console.log(i);// '0', '1', '2' console.log(a[i]);// 'A', 'B', 'C'&#125; 叮！for … in对Array的循环得到的是String而不是Number。 whilefor循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的for循环容易让人看不清循环的逻辑，此时用while循环更佳。 while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现： 1234567var x = 0;var n = 99;while(n &gt; 0)&#123; x = x + n; n = n - 2;&#125;x;//2500 循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。 do…whiledo { … } while()循环，它和while循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件：12345var n = 0;do &#123; n = n + 1;&#125; while (n &lt; 100);n; // 100 叮！用do { … } while()循环要小心，循环体会至少执行1次，而for和while循环则可能一次都不执行。 小结循环是让计算机做重复任务的有效的方法，有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。JavaScript的死循环会让浏览器无法正常显示或执行当前页面的逻辑，有的浏览器会直接挂掉，有的浏览器会在一段时间后提示你强行终止JavaScript的执行，因此，要特别注意死循环的问题。在编写循环代码时，务必小心编写初始条件和判断条件，尤其是边界值。特别注意i &lt; 100和i &lt;= 100是不同的判断逻辑。 Map和SetMapMap是一组键值对的结构，具有极快的查找速度。举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：12var names = ['Michael', 'Bob', 'Tracy'];var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael');//95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：1234var m = new Map();m.set('Adam', 67);m.set('Adam', 88);m.get('Adam'); // 88 SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set:12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤：12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, "3"&#125; 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：1234s.add(4);s;//Set &#123;1, 2, 3, 4&#125;s.add(4);s;//仍然是 Set &#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素：1234var s = new Set([1, 2, 3]);s; // Set &#123;1, 2, 3&#125;s.delete(3);s; // Set &#123;1, 2&#125; iterable遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for … of循环来遍历。用for … of循环遍历集合，用法如下：123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a)&#123;//遍历Array console.log(x);&#125;for(var x of s)&#123; console.log(x);&#125;for(var x of m)&#123; console.log(x[0] + '=' +x[1]);&#125; for … of循环和for … in循环有何区别？for … in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。 当我们手动给Array对象添加了额外的属性后，for … in循环将带来意想不到的意外效果：12345var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x in a) &#123; console.log(x); // '0', '1', '2', 'name'&#125; for … in循环将把name包括在内，但Array的length属性却不包括在内。for … of循环则完全修复了这些问题，它只循环集合本身的元素：12345var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x of a) &#123; console.log(x); // 'A', 'B', 'C'&#125; 这就是为什么要引入新的for … of循环。然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例：12345678'use strict';var a = ['A', 'B', 'C'];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index);&#125;); Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：1234var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;); Map的回调函数参数依次为value、key和map本身：1234var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);m.forEach(function (value, key, map) &#123; console.log(value);&#125;);]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门学习--CSS]]></title>
    <url>%2F2018%2F01%2F29%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-CSS%2F</url>
    <content type="text"><![CDATA[HTML已经做了简单了解，接下来是CSS的。 All form RUNOOB.COM CSS 简介什么是CSS？ CSS指层叠样式表（Cascading Style Sheets） 样式定义 如何显示 HTML元素 样式通常存储在样式表中 把样式添加到HTML4.0中，是为了解决内容与表分离的问题 外部样式表可以极大提高工作效率 外部样式表通常存储在CSS文件中 多个样式定义可层叠为一 CSS实例样式解决了一个很大的问题HTML 标签原本被设计为用于定义文档内容，如下实例：12&lt;h1&gt;这是一个标题&lt;/h1&gt;&lt;p&gt;这是一个段落。&lt;/p&gt; 样式表定义如何显示 HTML 元素，就像 HTML 3.2 的字体标签和颜色属性所起的作用那样。样式通常保存在外部的 .css 文件中。通过仅仅编辑一个简单的 CSS 文档，外部样式表使你有能力同时改变站点中所有页面的布局和外观。 CSS 语法先来实例。12345678910111213141516171819&lt;html&gt;&lt;head&gt;&lt;style&gt;body &#123;background-color:yellow;&#125;h1 &#123;font-size:36pt;&#125;h2 &#123;color:blue;&#125;p &#123;margin-left:50px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;This header is 36 pt&lt;/h1&gt;&lt;h2&gt;This header is blue&lt;/h2&gt;&lt;p&gt;This paragraph has a left margin of 50 pixels&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; CSS 实例CSS 规则由两个主要的部分构成，选择器，以及一条或多条声明。 CSS 声明总是以分号(;)结束，声明组以大括号({})括起来：1p &#123;color:red;text-align:center;&#125; 为了让CSS可读性更强，你可以每行只描述一个属性:12345p&#123;color:red;text-align:center;&#125; CSS 注释12345678/*这是个注释*/p&#123;text-align:center;/*这是另一个注释*/color:black;font-family:arial;&#125; CSS id 和 classid 和 class 选择器如果要在HTML元素中设置CSS样式，需要在元素中设置id和class选择器。 id选择器id选择器可以为标有特定id的HTML元素指定特定的样式。HTML元素以id属性来设置id选择器，CSS中id选择器以#来定义。下面的样式规则应用于元素属性id=”para1”：12345#para1&#123; text-align:center; color:red;&#125; class选择器class选择器用于描述一组元素的样式，class选择器有助于id选择器，class可以在多个元素中使用。class选择器在HTML中以class属性表示，在CSS中，类选择器以一个点“.”号显示：下面的例子中，所以拥有center类的HTML元素均为居中。1.center&#123;text-align:center;&#125; 也可指定特定的HTML元素使用class。下例中，所有的P元素使用class=“center”让该元素的文本居中。1p.center&#123;text-align:center;&#125; CSS 创建当读到一个样式表时，浏览器会根据它来格式化 HTML 文档。 如何插入样式表插入样式表的方法有三种： 外部样式表 内部样式表 内联样式 外部样式表当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用link标签链接到样式表。 link标签在（文档的）头部：123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;&lt;/head&gt; 浏览器会从文件Mystyle.css中读到样式声明，并根据它来格式文档。外部样式表可以在任何文本编辑器中进行编辑，文件不能包含任何的HTML标签，样式表应该以.css扩展名进行保存。下面为一个例子:123hr &#123;color:sienna;&#125;p &#123;margin-left:20px;&#125;body &#123;background-image:url("/images/back40.gif");&#125; 内部样式表当单个文档需要特殊的样式时，就应该使用内部样式表。可以使用style标签在文档头部定义内部样式表，就像这样:1234567&lt;head&gt;&lt;style&gt;hr &#123;color:sienna;&#125;p &#123;margin-left:20px;&#125;body &#123;background-image:url("images/back40.gif");&#125;&lt;/style&gt;&lt;/head&gt; 内联样式由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距：1&lt;p style="color:sienna;margin-left:20px"&gt;这是一个段落&lt;/p&gt; 多重样式如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。例如，外部样式表拥有针对 h3 选择器的三个属性：123456h3&#123; color:red; text-align:left; font-size:8pt;&#125; 而内部样式表拥有针对h3选择器的两个属性：12345h3&#123; text-align:right; font-size:20pt;&#125; 假如拥有内部样式表的这个页面同时与外部样式表链接，那么h3得到的样式是：123color:red;text-align:right;font-size:20pt; 即颜色属性将被继承于外部样式表，而文字排列（text-alignment）和字体尺寸（font-size）会被内部样式表中的规则取代。 多重样式优先级样式表允许以多种方式规定样式信息。样式可以规定在单个的HTML元素中，在HTML的头元素中，或在一个外部的CSS文件中。甚至可以在同一个HTML文档内部引用多个外部样式表。一般情况下，优先级如下：内联样式&gt;Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式 123456789101112&lt;head&gt; &lt;!-- 外部样式 style.css --&gt; &lt;link rel="stylesheet" type="text/css" href="style.css"/&gt; &lt;!-- 设置：h3&#123;color:blue;&#125; --&gt; &lt;style type="text/css"&gt; /* 内部样式 */ h3&#123;color:green;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;测试！&lt;/h3&gt;&lt;/body&gt; CSS 背景CSS背景属性用于定义HTML元素的背景。CSS属性定义背景效果: background-color background-image background-repeat background-attachment background-position 背景颜色background-color属性定义了元素的背景颜色。页面的背景颜色使用在body的选择器中：1body&#123;background-color:#b0c4de;&#125; CSS中，颜色值通常以以下方式定义： 十六进制 - 如：”#ff0000” RGB - 如：”rgb(255,0,0)” 颜色名称 - 如：”red”下面的例子中，h1,p,div元素拥有不同的背景颜色。 123h1 &#123;background-color:#6495ed;&#125;p &#123;background-color:#e0ffff;&#125;div &#123;background-color:#b0c4de;&#125; 背景图像background-image 属性描述了元素的背景图像.默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体.页面背景图片设置实例:1body &#123;background-image:url('paper.gif');&#125; 一个 反例，文本可读性差：1body &#123;background-image:url('bgdesert.jpg');&#125; 背景图像-水平或垂直平铺默认情况下 background-image 属性会在页面的水平或者垂直方向平铺。一些图像如果在水平方向与垂直方向平铺，这样看起来很不协调，如下所示:1234body&#123;background-image:url('gradient2.png');&#125; 只在水平方向平铺 (repeat-x), 页面背景会更好些:12345body&#123;background-image:url('gradient2.png');background-repeat:repeat-x;&#125; 背景图像-设置定位与不平铺让背景图像不影响文本的排版，不想让图像平铺，可以使用background-repeat属性。12345body&#123;background-image:url('img_tree.png');background-repeat:no-repeat;&#125; 背景- 简写属性在以上实例中我们可以看到页面的背景颜色通过了很多的属性来控制。为了简化这些属性的代码，我们可以将这些属性合并在同一个属性中，背景颜色的属性简写为background。1body &#123;background:#ffffff url('img_tree.png') no-repeat right top;&#125; 当使用简写属性时，属性值的顺序为： background-color background-image background-repeat background-attachment background-position CSS 文本格式文本颜色颜色属性被用来设置文字的颜色。颜色是通过CSS最经常的指定： 十六进制值-如:#FF0000 一个RGB值-如：RGB(255,0,0) 颜色的名称-如：red 例子：123body &#123;color:red;&#125;h1 &#123;color:#00ff00;&#125;h2 &#123;color:rgb(255,0,0);&#125; 文本的对齐方式文本排列属性是用来设置文本的水平对齐方式。文本可居中或对齐到左或右，两端对齐。当text-align设置为“justify”,每一行被展开为宽度相等，左，右外边距是对齐。123h1 &#123;text-align:center;&#125;p.date &#123;text-align:right;&#125;p.main &#123;text-align:justify;&#125; 文本修饰text-decoration属性用来设置或删除文本的装饰。从设计的角度看text-decoration属性主要用来删除链接的下划线：1a &#123;text-decoration:none;&#125; 一个例子：12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;h1 &#123;text-decoration:overline;&#125;h2 &#123;text-decoration:line-through;&#125;h3 &#123;text-decoration:underline;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;This is heading 1&lt;/h1&gt;&lt;h2&gt;This is heading 2&lt;/h2&gt;&lt;h3&gt;This is heading 3&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 文本转换文本转换属性是用来指定在一个文本中的大写和小写字母。可用于所有字句变成大写或小写字母，或每个单词的首字母大写。123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;p.uppercase &#123;text-transform:uppercase;&#125;p.lowercase &#123;text-transform:lowercase;&#125;p.capitalize &#123;text-transform:capitalize;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="uppercase"&gt;This is some text.&lt;/p&gt;&lt;p class="lowercase"&gt;This is some text.&lt;/p&gt;&lt;p class="capitalize"&gt;This is some text.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 文本缩进文本缩进属性是用来指定文本的第一行的缩进。1p &#123;text-indent:50px;&#125; CSS 字体CSS字体属性定义字体，加粗，大小，文字样式。 字体系列font-family属性设置文本的字体系列。应该设置几个字体名称作为一种后备机制，如果浏览器不支持第一种字体，他将尝试下一种字体。1p&#123;font-family:"Times New Roman",Times,serif;&#125; 字体样式主要是用于指定斜体文字的字体样式属性。此属性有三个值： 正常-正常显示文本 斜体-以斜体显示的文字 倾斜的文字-文字向一边倾斜 123p.normal&#123;font-style:normal;&#125;p.italic&#123;font-style:italic;&#125;p.oblique&#123;font-style:oblique;&#125; 字体大小font-size属性设置文本的大小。请务必使用正确的HTML标签，就h1-h6表示标题和p表示段落。字体大小的值是可以绝对或相对的大小。绝对大小： 设置一个指定大小的文本 不允许用户在所有浏览器中改变字体大小 确定了输出的物理尺寸时绝对大小很有用 相对大小： 相对于周围的元素来设置大小 允许用户在浏览器中改变文字大小 设置字体大小像素123h1 &#123;font-size:40px;&#125;h2 &#123;font-size:30px;&#125;p &#123;font-size:14px&#125; 用em来设置字体大小为了避免Internet Explorer 中无法调整文本的问题，许多开发者使用 em 单位代替像素。em的尺寸单位由W3C建议。1em和当前字体大小相等。在浏览器中默认的文字大小是16px。因此，1em的默认大小是16px。可以通过下面这个公式将像素转换为em：px/16=em 123h1 &#123;font-size:2.5em;&#125;/*40px/16=2.5em*/h2 &#123;font-size:1.875em;&#125;/*30px/16=1.875em*/p &#123;font-size:0.875em;&#125;/*14px/16=0.875em*/ 使用百分比和EM组合在所有浏览器的解决方案中，设置body元素的默认字体大小的是百分比：1234body &#123;font-size:100%;&#125;h1 &#123;font-size:2.5em;&#125;h2 &#123;font-size:1,875em;&#125;p &#123;font-size:0.875em;&#125; CSS 链接链接的样式 a:link - 正常，未访问过的链接 a:visited - 用户已访问过的链接 a:hover - 当用户鼠标放在链接上时 a:active - 链接被点击的那一刻1234a:link &#123;color:#000000;&#125; /* 未访问链接*/a:visited &#123;color:#00FF00;&#125; /* 已访问链接 */a:hover &#123;color:#FF00FF;&#125; /* 鼠标移动到链接上 */a:active &#123;color:#0000FF;&#125; /* 鼠标点击时 */ 常见的链接样式文本修饰text-decoration 属性主要用于删除链接中的下划线：1234a:link &#123;text-decoration:none;&#125;a:visited &#123;text-decoration:none;&#125;a:hover &#123;text-decoration:underline;&#125;a:active &#123;text-decoration:underline;&#125; 背景颜色背景颜色属性指定链接背景色： 1234a:link &#123;background-color:#B2FF99;&#125;a:visited &#123;background-color:#FFFF85;&#125;a:hover &#123;background-color:#FF704D;&#125;a:active &#123;background-color:#FF704D;&#125; CSS 列表列表属性作用： 设置不同的列表项标记问有序列表 设置不同的列表项为无序列表 设置列表项标记为图像 列表HTML有两种类型的列表： 无序列表 有序列表使用CSS可以列出进一步的样式，并可用图像作列表项标记。 不同的列表项标记list-style-type属性指定列表项标记的类型是：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;ul.a &#123;list-style-type:circle;&#125;ul.b &#123;list-style-type:square;&#125;ol.c &#123;list-style-type:upper-roman;&#125;ol.d &#123;list-style-type:lower-alpha;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;无序列表实例:&lt;/p&gt;&lt;ul class="a"&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt;&lt;/ul&gt;&lt;ul class="b"&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;有序列表实例:&lt;/p&gt;&lt;ol class="c"&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt;&lt;/ol&gt;&lt;ol class="d"&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;/html&gt; 作为列表项标记的图像要指定列表项标记的图像，使用列表样式图像属性：123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;ul &#123; list-style-image:url('sqpurple.gif');&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Tea&lt;/li&gt;&lt;li&gt;Coca Cola&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 浏览器兼容性解决方案同样在所有浏览器，下面的例子会显示的图像标记：12345678910111213ul&#123; list-style-type: none; padding: 0px; margin: 0px;&#125;ul li&#123; background-image: url(sqpurple.gif); background-repeat: no-repeat; background-position: 0px 5px; padding-left: 14px; &#125; 列表-简写属性在单个属性中可以指定所有的列表属性，这就是所谓的简写属性。为列表使用方便，列表样式属性设置如下：1234ul&#123; list-style: square url("sqpurple.gif");&#125; CSS 表格使用CSS可以使HTML表格更美观。 表格边框指定CSS表格边框，使用border属性。下面的例子指定了一个表格的th和td元素的黑色边框：1234table,th,td&#123; border:1px solid black;&#125; 折叠边框border-collapse属性设置的边框是否杯折叠成一个单一的边框或隔开：12345678table&#123;border-collapse:collapse;&#125;table,th, td&#123;border: 1px solid black;&#125; 表格宽度和高度Width和height属性定义表格的宽度和高度。下面的例子是设置100％的宽度，50像素的th元素的高度的表格： 12345678table &#123;width:100%;&#125;th&#123;height:50px;&#125; 表格文字对齐表格中的文本对齐和垂直对齐属性。text-align属性设置水平对齐方式，像左，右，或中心：1234td&#123;text-align:right;&#125; 垂直对齐属性设置垂直对齐，比如顶部，底部或中间：12345td&#123;height:50px;vertical-align:bottom;&#125; 表格填充如果在标的内容中控制空格之间的边框，应使用td和th元素的填充属性：1234td&#123; padding:15px;&#125; 表格颜色下面的例子指定边框的颜色，和th元素的文本和背景颜色：123456789table, td, th&#123;border:1px solid green;&#125;th&#123;background-color:green;color:white;&#125; CSS 盒子模型所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。下面的图片说明了盒子模型(Box Model)：不同部分的说明： Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像。 元素的宽度和高度指定一个CSS元素的宽度和高度属性时，只是设置内容区域的宽度和高度。要知道，完全大小的元素，还必须添加填充，边框和边距 123456div &#123; width: 300px; border: 25px solid green; padding: 25px; margin: 25px;&#125; 让我们自己算算：300px (宽) 50px (左 + 右填充) + 50px (左 + 右边框) + 50px (左 + 右边距)= 450px试想一下，你只有250像素的空间。让我们设置总宽度为250像素的元素: 123456div &#123; width: 220px; padding: 10px; border: 5px solid gray; margin: 0; &#125; 最终元素的总宽度计算公式是这样的：总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距元素的总高度最终计算公式是这样的：总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距 浏览器的兼容性问题一旦为页面设置了恰当的 DTD，大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。IE8 及更早IE版本不支持设置填充的宽度和边框的宽度属性。解决IE8及更早版本不兼容问题可以在HTML页面声明 !DOCTYPE html即可 CSS 边框CSS 边框属性CSS边框属性允许指定一个元素边框的样式和颜色。 边框样式边框样式属性指定要显示什么样的边界。 border-style值dotted: dotted:定义一个点线边框dashed: 定义一个虚线边框solid: 定义实线边框double: 定义两个边框。 两个边框的宽度和 border-width 的值相同groove: 定义3D沟槽边框。效果取决于边框的颜色值ridge: 定义3D脊边框。效果取决于边框的颜色值inset:定义一个3D的嵌入边框。效果取决于边框的颜色值outset: 定义一个3D突出边框。 效果取决于边框的颜色值 边框宽度可以通过Border-width属性为边框指定宽度。为边框指定宽度有两种方法：可以指定长度值，比如 2px 或 0.1em(单位为 px, pt, cm, em 等)，或者使用 3 个关键字之一，它们分别是 thick 、medium（默认值） 和 thin。CSS 没有定义 3 个关键字的具体宽度，所以一个用户可能把 thick 、medium 和 thin 分别设置为等于 5px、3px 和 2px，而另一个用户则分别设置为 3px、2px 和 1px。12345678910p.one&#123; border-style:solid; border-width:5px;&#125;p.two&#123; border-style:solid; border-width:medium;&#125; 边框颜色border-color属性用于设置边框的颜色。可以设置的颜色： name - 指定颜色的名称，如 “red” RGB - 指定 RGB 值, 如 “rgb(255,0,0)” Hex - 指定16进制值, 如 “#ff0000” 您还可以设置边框的颜色为”transparent”。注意：border-color单独使用是不起作用的，必须得先使用border-style来设置边框样式。12345678910p.one&#123; border-style:solid; border-color:red;&#125;p.two&#123; border-style:solid; border-color:#98bf21;&#125; 边框-单独设置各边在CSS中，可以指定不同的侧面不同的边框：1234567p&#123; border-top-style:dotted; border-right-style:solid; border-bottom-style:dotted; border-left-style:solid;&#125; 上面的例子可以设置一个单一属性：1border-style:dotted solid; 边框-简写属性上面的例子用了很多属性来设置边框。也可以在一个属性中设置边框。可以在”border”属性中设置： border-width border-style (required) border-color 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt;p&#123; border:5px solid red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;段落中的一些文本。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSS 轮廓轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。轮廓（outline）属性指定元素轮廓的样式、颜色和宽度.看几个例子就很明显了： 在元素周围画线123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;p &#123; border:1px solid red; outline:green dotted thick;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; 如果只有一个 !DOCTYP E指定 IE8 支持 outline 属性。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 设置轮廓样式123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;p &#123;border:1px solid red;&#125;p.dotted &#123;outline-style:dotted;&#125;p.dashed &#123;outline-style:dashed;&#125;p.solid &#123;outline-style:solid;&#125;p.double &#123;outline-style:double;&#125;p.groove &#123;outline-style:groove;&#125;p.ridge &#123;outline-style:ridge;&#125;p.inset &#123;outline-style:inset;&#125;p.outset &#123;outline-style:outset;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="dotted"&gt;点线轮廓&lt;/p&gt;&lt;p class="dashed"&gt;虚线轮廓&lt;/p&gt;&lt;p class="solid"&gt;实线轮廓&lt;/p&gt;&lt;p class="double"&gt;双线轮廓&lt;/p&gt;&lt;p class="groove"&gt;凹槽轮廓&lt;/p&gt;&lt;p class="ridge"&gt;垄状轮廓&lt;/p&gt;&lt;p class="inset"&gt;嵌入轮廓&lt;/p&gt;&lt;p class="outset"&gt;外凸轮廓&lt;/p&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; 如果只有一个 !DOCTYPE 指定 IE 8 支持 outline 属性。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 设置轮廓的颜色1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;p &#123; border:1px solid red; outline-style:dotted; outline-color:#00ff00;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; 如果只有一个 !DOCTYPE 指定 IE 8 支持 outline 属性。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 设置轮廓的宽度12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;p.one&#123; border:1px solid red; outline-style:solid; outline-width:thin;&#125;p.two&#123; border:1px solid red; outline-style:dotted; outline-width:3px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="one"&gt;This is some text in a paragraph.&lt;/p&gt;&lt;p class="two"&gt;This is some text in a paragraph.&lt;/p&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; 如果只有一个 !DOCTYPE 指定 IE8 支持 outline 属性。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSS Margin(外边距)外边距属性定义元素周围的空间。 Marginmargin清除周围的元素（外边框）的区域。margin没有背景颜色，是完全透明的margin可以单独改变元素的上，下，左，右边距。也可以一次改变所有的属性。 Margin - 单边外边距属性在CSS中，它可以指定不同的侧面不同的边距： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;p&#123; background-color:yellow;&#125;p.margin&#123; margin-top:100px; margin-bottom:100px; margin-right:50px; margin-left:50px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是一个没有指定边距大小的段落。&lt;/p&gt;&lt;p class="margin"&gt;这是一个指定边距大小的段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; Margin - 简写属性为了缩短代码，有可能使用一个属性中margin指定的所有边距属性。这就是所谓的缩写属性。所有边距属性的缩写属性是”margin”:1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;p&#123; background-color:yellow;&#125;p.margin&#123; margin:100px 50px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是一个没有指定边距大小的段落。&lt;/p&gt;&lt;p class="margin"&gt;这是一个指定边距大小的段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSS Padding（填充）CSS Padding（填充）属性定义元素边框与元素内容之间的空间。 Padding（填充）当元素的Padding（填充）（内边距）被清除时，所”释放”的区域将会受到元素背景颜色的填充。单独使用填充属性可以改变上下左右的填充。缩写填充属性也可以使用，一旦改变一切都改变。 填充- 单边内边距属性在CSS中，它可以指定不同的侧面不同的填充：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt;p&#123; background-color:yellow;&#125;p.padding&#123; padding-top:25px; padding-bottom:25px; padding-right:50px; padding-left:50px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是一个没有指定填充边距的段落。&lt;/p&gt;&lt;p class="padding"&gt;这是一个指定填充边距的段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 填充 - 简写属性为了缩短代码，它可以在一个属性中指定的所有填充属性。这就是所谓的缩写属性。所有的填充属性的缩写属性是”padding”: 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt;p&#123; background-color:yellow;&#125;p.padding&#123; padding:25px 50px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是一个没有指定填充边距的段落。&lt;/p&gt;&lt;p class="padding"&gt;这是一个指定填充边距的段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSS 分组和 嵌套 选择器Grouping Selectors在样式表中有很多具有相同样式的元素。123456789101112h1&#123;color:green;&#125;h2&#123;color:green;&#125;p&#123;color:green;&#125; 为了尽量减少代码，你可以使用分组选择器。每个选择器用逗号分隔.在下面的例子中，我们对以上代码使用分组选择器：1234h1,h2,p&#123;color:green;&#125; 嵌套选择器它可能适用于选择器内部的选择器的样式。在下面的例子设置了三个样式： 为所有p元素指定一个样式 为所有class=”marked”的元素指定一个样式 为所有class=”marked”元素内的p元素指定一个样式 12345678910111213p&#123;color:blue;text-align:center;&#125;.marked&#123;background-color:red;&#125;.marked p&#123;color:white;&#125; 来一个全的：123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;p&#123; color:blue; text-align:center;&#125;.marked&#123; background-color:red;&#125;.marked p&#123; color:white;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这个段落是蓝色文本，居中对齐。&lt;/p&gt;&lt;div class="marked"&gt;&lt;p&gt;这个段落不是蓝色文本。&lt;/p&gt;&lt;/div&gt;&lt;p&gt;所有 class="marked"元素内的 p 元素指定一个样式，但有不同的文本颜色。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSS 尺寸 (Dimension)CSS 尺寸 (Dimension) 属性允许你控制元素的高度和宽度。同样，它允许你增加行间距。 设置元素的高度123456789101112131415&lt;style&gt;img.normal&#123; height:auto;&#125;img.big&#123; height:120px;&#125;p.ex&#123; height:100px; width:100px;&#125;&lt;/style&gt; 使用百分比设置图像的高度1234567&lt;style&gt;html &#123;height:100%;&#125;body &#123;height:100%;&#125;img.normal &#123;height:auto;&#125;img.big &#123;height:50%;&#125;img.small &#123;height:10%;&#125;&lt;/style&gt; 使用像素值来设置元素的宽度123&lt;style&gt;img &#123;width:200px;&#125;&lt;/style&gt; 设置元素的最大高度1234567&lt;style type="text/css"&gt;p&#123; max-height:50px; background-color:yellow;&#125;&lt;/style&gt; 使用百分比来设置元素的最大宽度1234567&lt;style&gt;p&#123; max-width:20%; background-color:yellow;&#125;&lt;/style&gt; 设置元素的最低高度1234567&lt;style&gt;p&#123; min-height:100px; background-color:yellow;&#125;&lt;/style&gt; 使用像素值设置元素的最小宽度1234567&lt;style&gt;p&#123; min-width:150px; background-color:yellow;&#125;&lt;/style&gt; CSS Display(显示) 与 Visibility（可见性）display属性设置一个元素应如何显示，visibility属性指定一个元素应可见还是隐藏。 隐藏元素 - display:none或visibility:hidden隐藏一个元素可以通过把display属性设置为”none”，或把visibility属性设置为”hidden”。但是请注意，这两种方法会产生不同的结果。visibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。 12345&lt;body&gt;&lt;h1&gt;这是一个可见标题&lt;/h1&gt;&lt;h1 class="hidden"&gt;这是一个隐藏标题&lt;/h1&gt;&lt;p&gt;注意, 实例中的隐藏标题仍然占用空间。&lt;/p&gt;&lt;/body&gt; display:none可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。 1h1.hidden &#123;display:none;&#125; CSS Display - 块和内联元素块元素是一个元素，占用了全部宽度，在前后都是换行符。块元素的例子： &amp;lth1&amp;gt &amp;ltp&amp;gt &amp;ltdiv&amp;gt内联元素只需要必要的宽度，不强制换行。内联元素的例子： &amp;ltspan&amp;gt &amp;lta&amp;gt 如何改变一个元素显示可以更改内联元素和块元素，反之亦然，可以使页面看起来是以一种特定的方式组合，并仍然遵循web标准。下面的示例把列表项显示为内联元素：1li &#123;display:inline;&#125; 把span元素作为块元素：1span &#123;display:block;&#125; CSS Positioning(定位)position 属性指定了元素的定位类型。position 属性的四个值： static relative fixed absolute 元素可以使用的顶部，底部，左侧和右侧属性定位。然而，这些属性无法工作，除非是先设定position属性。他们也有不同的工作方式，这取决于定位方法。 static 定位HTML元素的默认值，即没有定位，元素出现在正常的流中。静态定位的元素不会受到 top, bottom, left, right影响。 fixed 定位元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动： 123456p.pos_fixed&#123; position:fixed; top:30px; right:5px;&#125; relative 定位相对定位元素的定位是相对其正常位置。 12345678910h2.pos_left&#123; position:relative; left:-20px;&#125;h2.pos_right&#123; position:relative; left:20px;&#125; 可以移动的相对定位元素的内容和相互重叠的元素，它原本所占的空间不会改变。12345h2.pos_top&#123; position:relative; top:-50px;&#125; absolute 定位绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于html: 123456h2&#123; position:absolute; left:100px; top:150px;&#125; absolute 定位使元素的位置与文档流无关，因此不占据空间。absolute 定位的元素和其他元素重叠。 重叠的元素元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面）一个元素可以有正数或负数的堆叠顺序： 1234567img&#123; position:absolute; left:0px; top:0px; z-index:-1;&#125; CSS Float(浮动)CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。Float（浮动），往往是用于图像，但它在布局时一样非常有用。 元素怎样浮动元素的水平方向浮动，意味着元素只能左右移动而不能上下移动。一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。浮动元素之后的元素将围绕它。浮动元素之前的元素将不会受到影响。如果图像是右浮动，下面的文本流将环绕在它左边： 1234img&#123; float:right;&#125; 彼此相邻的浮动元素如果把几个浮动的元素放到一起，如果有空间的话，它们将彼此相邻。在这里，对图片廊使用 float 属性： 1234567.thumbnail &#123; float:left; width:110px; height:90px; margin:5px;&#125; 清除浮动 - 使用 clear元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。clear 属性指定元素两侧不能出现浮动元素。使用 clear 属性往文本中添加图片廊：1234.text_line&#123; clear:both;&#125; CSS 布局 - 水平 &amp; 垂直对齐元素居中对齐要水平居中对齐一个元素(如 div), 可以使用 margin: auto;。设置到元素的宽度将防止它溢出到容器的边缘。元素通过指定宽度，并将两边的空外边距平均分配：123456.center &#123; margin: auto; width: 50%; border: 3px solid green; padding: 10px;&#125; 文本居中对齐如果仅仅是为了文本在元素内居中对齐，可以使用 text-align: center; 1234.center &#123; text-align: center; border: 3px solid green;&#125; 图片居中对齐要让图片居中对齐, 可以使用 margin: auto; 并将它放到 块 元素中: 12345img &#123; display: block; margin: auto; width: 40%;&#125; 左右对齐 - 使用定位方式可以使用 position: absolute; 属性来对齐元素:1234567.right &#123; position: absolute; right: 0px; width: 300px; border: 3px solid #73AD21; padding: 10px;&#125; 左右对齐 - 使用 float 方式我们也可以使用 float 属性来对齐元素: 123456.right &#123; float: right; width: 300px; border: 3px solid #73AD21; padding: 10px;&#125; 垂直居中对齐 - 使用 paddingCSS 中有很多方式可以实现垂直居中对齐。 一个简单的方式就是头部顶部使用 padding: 1234.center &#123; padding: 70px 0; border: 3px solid green;&#125; 如果要水平和垂直都居中，可以使用 padding 和 text-align: center: 12345.center &#123; padding: 70px 0; border: 3px solid green; text-align: center;&#125; 垂直居中 - 使用 line-height12345678910111213.center &#123; line-height: 200px; height: 200px; border: 3px solid green; text-align: center;&#125; /* 如果文本有多行，添加以下代码: */.center p &#123; line-height: 1.5; display: inline-block; vertical-align: middle;&#125; 垂直居中 - 使用 position 和 transform除了使用 padding 和 line-height 属性外,我们还可以使用 transform 属性来设置垂直居中:12345678910111213.center &#123; height: 200px; position: relative; border: 3px solid green; &#125; .center p &#123; margin: 0; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; CSS 组合选择符后代选取器后代选取器匹配所有值得元素的后代元素。以下实例选取所有 p 元素插入到 div元素中:123456789101112131415161718&lt;style&gt;div p&#123; background-color:yellow;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;p&gt;后代选择1&lt;/p&gt;&lt;p&gt;后代选择2&lt;/p&gt;&lt;/div&gt;&lt;p&gt;不在div3&lt;/p&gt;&lt;p&gt;不在div4&lt;/p&gt;&lt;/body&gt; 子元素选择器与后代选择器相比，子元素选择器（Childselectors）只能选择作为某元素子元素的元素。以下实例选择了div元素中所有直接子元素 p ：1234div&gt;p&#123; background-color:yellow;&#125; 相邻兄弟选择器相邻兄弟选择器（Adjacent sibling selector）可选择紧接在另一元素后的元素，且二者有相同父元素。如果需要选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器（Adjacent sibling selector）。以下实例选取了所有位于div元素后的第一个p元素:1234div+p&#123; background-color:yellow;&#125; 后续兄弟选择器后续兄弟选择器选取所有指定元素之后的相邻兄弟元素。以下实例选取了所有div元素之后的所有相邻兄弟元素p:1234div~p&#123; background-color:yellow;&#125; CSS 导航栏熟练使用导航栏，对于任何网站都非常重要。使用CSS你可以转换成好看的导航栏而不是枯燥的HTML菜单。 导航栏=链接列表作为标准的HTML基础一个导航栏是必须的。在我们的例子中我们将建立一个标准的HTML列表导航栏。导航条基本上是一个链接列表，所以使用ul和li元素非常有意义：123456&lt;ul&gt; &lt;li&gt;&lt;a href="#home"&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#news"&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#contact"&gt;联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#about"&gt;关于&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 注：这里用 href=”#”作为测试连接。但在一个真正的 web 站点上需要真实的 url。 从列表中删除边距和填充：12345ul&#123; list-style-type: none; margin: 0; padding: 0;&#125; 解析：list-style-type：none 是移除列表前小标志，导航栏不需要列表标志。移除浏览器的默认设置将边距和填充设置为0 垂直导航栏1234567891011121314151617181920212223242526272829303132333435&lt;style&gt;ul &#123; list-style-type: none; margin: 0; padding: 0; width: 200px; background-color: #f1f1f1;&#125; li a &#123; display: block; color: #000; padding: 8px 16px; text-decoration: none;&#125; /* 鼠标移动到选项上修改背景颜色 */li a:hover &#123; background-color: #555; color: white;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="#home"&gt;主页&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#news"&gt;新闻&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#contact"&gt;联系&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#about"&gt;关于&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;背景颜色添加到链接中显示链接的区域&lt;/p&gt;&lt;p&gt;注意,整个区域是可点击的链接,而不仅仅是文本。&lt;/p&gt;&lt;/body&gt; display:block - 显示块元素的链接，让整体变为可点击链接区域（不只是文本），它允许我们指定宽度width:60px - 块元素默认情况下是最大宽度。我们要指定一个60像素的宽度 垂直导航条实例创建一个简单的垂直导航条实例，在鼠标移动到选项时，修改背景颜色：1234567891011121314151617181920212223242526272829303132333435&lt;style&gt;ul &#123; list-style-type: none; margin: 0; padding: 0; width: 200px; background-color: #f1f1f1;&#125; li a &#123; display: block; color: #000; padding: 8px 16px; text-decoration: none;&#125; /* 鼠标移动到选项上修改背景颜色 */li a:hover &#123; background-color: #555; color: white;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="#home"&gt;主页&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#news"&gt;新闻&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#contact"&gt;联系&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#about"&gt;关于&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;背景颜色添加到链接中显示链接的区域&lt;/p&gt;&lt;p&gt;注意,整个区域是可点击的链接,而不仅仅是文本。&lt;/p&gt;&lt;/body&gt; 激活/当前导航条实例1234.active &#123; background-color: #4CAF50; color: white;&#125; 实现：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;html&gt;&lt;head&gt;&lt;style&gt;ul &#123; list-style-type: none; margin: 0; padding: 0; width: 200px; background-color: #f1f1f1;&#125;li a &#123; display: block; color: #000; padding: 8px 16px; text-decoration: none;&#125;li a.active &#123; background-color: #4CAF50; color: white;&#125;li a:hover:not(.active) &#123; background-color: #555; color: white;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;垂直导航条&lt;/h2&gt;&lt;p&gt;在点击了选项后，我们可以添加 "active" 类来标准哪个选项被选中。&lt;/p&gt;&lt;ul&gt; &lt;li&gt;&lt;a class="active" href="#home"&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#news"&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#contact"&gt;联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#about"&gt;关于&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 全屏高度的固定导航条接下来创建一个左边是全屏高度的固定导航条，右边是可滚动的内容。(这不是和我博客一样了吗)核心：12345678910ul &#123; list-style-type: none; margin: 0; padding: 0; width: 25%; background-color: #f1f1f1; height: 100%; /* 全屏高度 */ position: fixed; overflow: auto; /* 如果导航栏选项多，允许滚动 */&#125; 实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;style&gt;body &#123; margin: 0;&#125;ul &#123; list-style-type: none; margin: 0; padding: 0; width: 25%; background-color: #f1f1f1; position: fixed; height: 100%; overflow: auto;&#125;li a &#123; display: block; color: #000; padding: 8px 16px; text-decoration: none;&#125;li a.active &#123; background-color: #4CAF50; color: white;&#125;li a:hover:not(.active) &#123; background-color: #555; color: white;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;a class="active" href="#home"&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#news"&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#contact"&gt;联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#about"&gt;关于&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div style="margin-left:25%;padding:1px 16px;height:1000px;"&gt; &lt;h2&gt;Fixed Full-height Side Nav&lt;/h2&gt; &lt;h3&gt;Try to scroll this area, and see how the sidenav sticks to the page&lt;/h3&gt; &lt;p&gt;Notice that this div element has a left margin of 25%. This is because the side navigation is set to 25% width. If you remove the margin, the sidenav will overlay/sit on top of this div.&lt;/p&gt; &lt;p&gt;Also notice that we have set overflow:auto to sidenav. This will add a scrollbar when the sidenav is too long (for example if it has over 50 links inside of it).&lt;/p&gt; &lt;p&gt;Some text..&lt;/p&gt; &lt;p&gt;Some text..&lt;/p&gt; &lt;p&gt;Some text..&lt;/p&gt; &lt;p&gt;Some text..&lt;/p&gt; &lt;p&gt;Some text..&lt;/p&gt; &lt;p&gt;Some text..&lt;/p&gt; &lt;p&gt;Some text..&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS 下拉菜单实例：1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;下拉菜单实例&lt;/title&gt;&lt;meta charset="utf-8"&gt;&lt;style&gt;.dropdown &#123; position: relative; display: inline-block;&#125;.dropdown-content &#123; display: none; position: absolute; background-color: #f9f9f9; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); padding: 12px 16px;&#125;.dropdown:hover .dropdown-content &#123; display: block;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;鼠标移动后出现下拉菜单&lt;/h2&gt;&lt;p&gt;将鼠标移动到指定元素上就能看到下拉菜单。&lt;/p&gt;&lt;div class="dropdown"&gt; &lt;span&gt;鼠标移动到我这！&lt;/span&gt; &lt;div class="dropdown-content"&gt; &lt;p&gt;教程&lt;/p&gt; &lt;p&gt;www.runoob.com&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实例解析HTML 部分：我们可以使用任何的HTML元素来打开下拉菜单，如：span, 或a button元素。使用容器元素(如：div)来创建下拉菜单的内容，并放在任何你想放的位置上。使用div元素来包裹这些元素，并使用CSS来设置下拉内容的样式。CSS 部分：.dropdown类使用 position:relative, 这将设置下拉菜单的内容放置在下拉按钮 (使用 position:absolute) 的右下角位置。.dropdown-content 类中是实际的下拉菜单。默认是隐藏的，在鼠标移动到指定元素后会显示。 注意 min-width 的值设置为 160px。你可以随意修改它。注意: 如果你想设置下拉内容与下拉按钮的宽度一致，可设置 width 为 100% ( overflow:auto 设置可以在小尺寸屏幕上滚动)。我们使用 box-shadow 属性让下拉菜单看起来像一个”卡片”。:hover 选择器用于在用户将鼠标移动到下拉按钮上时显示下拉菜单。 下拉菜单实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;style&gt;/* 下拉按钮样式 */.dropbtn &#123; background-color: #4CAF50; color: white; padding: 16px; font-size: 16px; border: none; cursor: pointer;&#125;/* 容器 &lt;div&gt; - 需要定位下拉内容 */.dropdown &#123; position: relative; display: inline-block;&#125;/* 下拉内容 (默认隐藏) */.dropdown-content &#123; display: none; position: absolute; background-color: #f9f9f9; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);&#125;/* 下拉菜单的链接 */.dropdown-content a &#123; color: black; padding: 12px 16px; text-decoration: none; display: block;&#125;/* 鼠标移上去后修改下拉菜单链接颜色 */.dropdown-content a:hover &#123;background-color: #f1f1f1&#125;/* 在鼠标移上去后显示下拉菜单 */.dropdown:hover .dropdown-content &#123; display: block;&#125;/* 当下拉内容显示后修改下拉按钮的背景颜色 */.dropdown:hover .dropbtn &#123; background-color: #3e8e41;&#125;&lt;/style&gt;&lt;div class="dropdown"&gt; &lt;button class="dropbtn"&gt;下拉菜单&lt;/button&gt; &lt;div class="dropdown-content"&gt; &lt;a href="#"&gt;菜鸟教程 1&lt;/a&gt; &lt;a href="#"&gt;菜鸟教程 2&lt;/a&gt; &lt;a href="#"&gt;菜鸟教程 3&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; CSS 提示工具(Tooltip)如何使用 HTML 与 CSS 来创建提示工具。 基础提示框(Tooltip)提示框在鼠标移动到指定元素上显示：12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;style&gt;.tooltip &#123; position: relative; display: inline-block; border-bottom: 1px dotted black;&#125;.tooltip .tooltiptext &#123; visibility: hidden; width: 120px; background-color: black; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; /* 定位 */ position: absolute; z-index: 1;&#125;.tooltip:hover .tooltiptext &#123; visibility: visible;&#125;&lt;/style&gt;&lt;body style="text-align:center;"&gt;&lt;div class="tooltip"&gt;鼠标移动到这 &lt;span class="tooltiptext"&gt;提示文本&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实例解析：HTML) 使用容器元素 (like div) 并添加 “tooltip” 类。在鼠标移动到div 上时显示提示信息。提示文本放在内联函数上(如 span) 并使用class=”tooltiptext”。CSS)tooltip 类使用 position:relative, 提示文本需要设置定位值 position:absolute。 注意: 接下来的实例会显示更多的定位效果。tooltiptext 类用于实际的提示文本。模式是隐藏的，在鼠标移动到元素显示 。设置了一些宽度、背景色、字体色等样式。CSS3 border-radius 属性用于为提示框添加圆角。:hover 选择器用于在鼠标移动到到指定元素div上时显示的提示。 图片廊以下是使用 CSS 创建图片廊：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;style&gt;div.img &#123; margin: 5px; border: 1px solid #ccc; float: left; width: 180px;&#125;div.img:hover &#123; border: 1px solid #777;&#125;div.img img &#123; width: 100%; height: auto;&#125;div.desc &#123; padding: 15px; text-align: center;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="responsive"&gt; &lt;div class="img"&gt; &lt;a target="_blank" href="http://static.runoob.com/images/demo/demo1.jpg"&gt; &lt;img src="http://static.runoob.com/images/demo/demo1.jpg" alt="图片文本描述" width="300" height="200"&gt; &lt;/a&gt; &lt;div class="desc"&gt;这里添加图片文本描述&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class="responsive"&gt; &lt;div class="img"&gt; &lt;a target="_blank" href="http://static.runoob.com/images/demo/demo2.jpg"&gt; &lt;img src="http://static.runoob.com/images/demo/demo2.jpg" alt="图片文本描述" width="300" height="200"&gt; &lt;/a&gt; &lt;div class="desc"&gt;这里添加图片文本描述&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class="responsive"&gt; &lt;div class="img"&gt; &lt;a target="_blank" href="http://static.runoob.com/images/demo/demo3.jpg"&gt; &lt;img src="http://static.runoob.com/images/demo/demo3.jpg" alt="图片文本描述" width="300" height="200"&gt; &lt;/a&gt; &lt;div class="desc"&gt;这里添加图片文本描述&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class="responsive"&gt; &lt;div class="img"&gt; &lt;a target="_blank" href="http://static.runoob.com/images/demo/demo4.jpg"&gt; &lt;img src="http://static.runoob.com/images/demo/demo4.jpg" alt="图片文本描述" width="300" height="200"&gt; &lt;/a&gt; &lt;div class="desc"&gt;这里添加图片文本描述&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 叮：想到之前用的的博客排版，一直想做一个相册，其实这样就可以实现。 CSS 图像透明/不透明123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;style&gt;img&#123; opacity:0.4; filter:alpha(opacity=40); /* 适用 IE8 及其更早版本 */&#125;img:hover&#123; opacity:1.0; filter:alpha(opacity=100); /* 适用 IE8 及其更早版本 */&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;图片透明度&lt;/h1&gt;&lt;p&gt;opacity 属性通常与 :hover 选择器一起使用，在鼠标移动到图片上后改变图片的透明度：&lt;/p&gt;&lt;img src="klematis.jpg" width="150" height="113" alt="klematis"&gt;&lt;img src="/images/klematis2.jpg" width="150" height="113" alt="klematis"&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt;在 IE 中必须声明 &amp;lt;!DOCTYPE&amp;gt; 才能保证 :hover 选择器能够有效。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSS 图像拼合技术图像拼合就是单个图像的集合。有许多图像的网页可能需要很长的时间来加载和生成多个服务器的请求。使用图像拼合会降低服务器的请求数量，并节省带宽。 简单实例与其使用三个独立的图像，不如我们使用这种单个图像（”img_navsprites.gif”）：有了CSS，可以只显示需要的图像的一部分。在下面的例子CSS指定显示”img_navsprites.gif” 的图像的一部分：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;img.home &#123; width: 46px; height: 44px; background: url(/images/img_navsprites.gif) 0 0;&#125;img.next &#123; width: 43px; height: 44px; background: url(/images/img_navsprites.gif) -91px 0;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img class="home" src="/images/img_trans.gif"&gt;&lt;br&gt;&lt;br&gt;&lt;img class="next" src="/images/img_trans.gif"&gt;&lt;/body&gt;&lt;/html&gt; 实例解析：img class=”home” src=”img_trans.gif” / -因为不能为空,src属性只定义了一个小的透明图像。显示的图像将是我们在CSS中指定的背景图像宽度：46px;高度：44px; - 定义我们使用的那部分图像background:url(img_navsprites.gif) 0 0;定义背景图像和它的位置（左0px，顶部0px）这是使用图像拼合最简单的方法，现在我们使用链接和悬停效果。 CSS 媒体类型一些CSS属性只设计了某些媒体。例如”voice-family”属性是专为听觉用户代理。其他一些属性可用于不同的媒体类型。例如，”font-size”属性可用于屏幕和印刷媒体，但有不同的值。屏幕和纸上的文件不同，通常需要一个更大的字体，sans - serif字体比较适合在屏幕上阅读，而serif字体更容易在纸上阅读。 @media 规则@media 规则允许在相同样式表为不同媒体设置不同的样式。在下面的例子告诉我们浏览器屏幕上显示一个14像素的Verdana字体样式。但是如果页面打印，将是10个像素的Times字体。请注意，font-weight在屏幕上和纸上设置为粗体：12345678910111213141516171819202122&lt;html&gt;&lt;head&gt;&lt;style&gt;@media screen&#123; p.test &#123;font-family:verdana,sans-serif;font-size:14px;&#125;&#125;@media print&#123; p.test &#123;font-family:times,serif;font-size:10px;&#125;&#125;@media screen,print&#123; p.test &#123;font-weight:bold;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;....&lt;/body&gt;&lt;/html&gt; CSS 属性 选择器具有特定属性的HTML元素样式具有特定属性的HTML元素样式不仅仅是class和id。注意：IE7和IE8需声明!DOCTYPE才支持属性选择器！IE6和更低的版本不支持属性选择器。 属性选择器下面的例子是把包含标题（title）的所有元素变为蓝色：1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;[title]&#123;color:blue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Will apply to:&lt;/h2&gt;&lt;h1 title="Hello world"&gt;Hello world&lt;/h1&gt;&lt;a title="runoob.com" href="http://www.runoob.com/"&gt;runoob.com&lt;/a&gt;&lt;hr&gt;&lt;h2&gt;Will not apply to:&lt;/h2&gt;&lt;p&gt;Hello!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 属性和值选择器下面的实例改变了标题title=’runoob’元素的边框样式:123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;[title=runoob]&#123; border:5px solid green;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;将适用:&lt;/h2&gt;&lt;img title="runoob" src="logo.png" width="270" height="50" /&gt;&lt;br&gt;&lt;a title="runoob" href="http://www.runoob.com/"&gt;runoob&lt;/a&gt;&lt;hr&gt;&lt;h2&gt;将不适用:&lt;/h2&gt;&lt;p title="greeting"&gt;Hi!&lt;/p&gt;&lt;a class="runoob" href="http://www.runoob.com/"&gt;runoob&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; CSS 总结CSS创建样式表来同时控制多重页面的样式和布局。使用CSS来添加背景、格式化文本、以及格式化边框，并定义元素的填充和边距。使用CSS定位元素、控制元素的可见性和尺寸、设置元素的形状、将一个元素置于另一个之后，以及向某些选择器添加特殊的效果，比如链接。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门学习--HTML]]></title>
    <url>%2F2018%2F01%2F23%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-HTML%2F</url>
    <content type="text"><![CDATA[写在前面。前端知识真的还是比较有用的。一直要把前端的学习提上日程，因为各种事情各种拖延，写爬虫的时候也是捎带学习前端的东西，还是需要系统的了解下。All from W3school. HTML简介HTML是用来描述网页的一种语言。指的是超文本标记语言（Hyper Text Markup Language）,不是一种编程语言，而是一种标记语言。 标签HTML标签是由尖括号包围的关键词比如html，便签通常是成对出现的，比如1&lt;b&gt;和&lt;/b&gt; 第一个是开始，第二个标签是结束。 文档=网页HTML文档描述网页，包含HTML标签和纯文本。Web浏览器的作用就是读取HTML文档，并以网页的形式显示他们。123456&lt;html&gt;&lt;body&gt;&lt;h1&gt;hello world&lt;/h1&gt;&lt;p&gt;这是一个段落，嗯，我说他是他就是&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子解释1234&lt;html&gt;与&lt;/hrml&gt;之间的文本描述网页 &lt;body&gt;与&lt;/body&gt;之间的文本是可见的页面内容 &lt;h1&gt;与&lt;/h1&gt;之间的文本被显示为标题 &lt;p&gt;与&lt;/p&gt;之间的文本被显示为段落 HTML 基础HTML 标题HTML标题是通过h1-h6等标签进行定义的。 123&lt;h1&gt;这是个标题&lt;/h1&gt;&lt;h2&gt;嗯，这还是个标题&lt;/h2&gt;&lt;h3&gt;没错，又是一个标题&lt;/h3&gt; HTML 段落HTML段落通过p标签进行定义。12&lt;p&gt;段落一&lt;/p&gt;&lt;p&gt;段落二&lt;/p&gt; HTML 链接HTML链接是通过a进行定义的。1&lt;a href="https://x-nicolo.github.io/"&gt;这是肖洒的博客&lt;/a&gt; 注释：在href属性中指定链接的地址。 HTML 图像HTML图像是通过img标签进行定义的。 1&lt;img src="img.jpg" width="104" height="142" /&gt; 注释：图像的名称和尺寸是以属性的形式提供的。 HTML 元素HTML元素指的是从开始标签到结束标签的所有代码。 HTML 属性HTML标签可以拥有属性。属性提供了有关HTML元素的更多信息。属性总是以名称/值对的形式出现。比如：name=”value”.属性总是在HTML元素的开始标签中规定。 属性例子1234561. &lt;h1 align="center"&gt;拥有关于对齐方式的附加信息。 2. &lt;body bgcolor="yellow"&gt;拥有关于背景颜色的附加信息。 3. &lt;table border="1"&gt;拥有关于表格边框的附加信息 HTML 标题标题是通过h1-h6等标签进行定义的。h1定义最大的标题，h6定义最小的标题。 HTML 水平线1&lt;hr /&gt; 标签在HTML页面中创建水平线hr元素可用与分隔内容。例子： 12345&lt;p&gt;这是第一段&lt;/p&gt; &lt;hr /&gt;&lt;p&gt;这是第二段&lt;/p&gt; &lt;hr /&gt;&lt;p&gt;这是第三段&lt;/p&gt; 提示：使用水平线 (hr 标签)来分隔文章中的小节是一个办法（但并不是唯一的办法）。 HTML 注释科技将注释插入HTML代码中。例子： 1&lt;!--这里是注释，不显示--&gt; HTML 段落段落通过p标签定义。 HTML 折行不产生一个新段落的情况下进行换行。 1&lt;p&gt;我就是&lt;br /&gt;想试试&lt;br /&gt;这个功能&lt;/p&gt; 注：br / 元素是一个空的 HTML 元素。由于关闭标签没有任何意义，因此它没有结束标签。注:浏览器忽略了源代码中的排版（省略了多余的空格和换行） HTML 样式style属性用于改变HTML元素的样式。 HTML的style属性style属性的作用：提供了一种改变所有HTML元素的样式的通用方法。样式是 HTML 4 引入的，它是一种新的首选的改变 HTML 元素样式的方式。通过 HTML 样式，能够通过使用style属性直接将样式添加到HTML元素，或者间接地在独立的样式表中（CSS 文件）进行定义。 HTML 样式实例-背景颜色background-color属性为元素定义 了背景颜色：123456&lt;html&gt;&lt;body style="background-color:yellow"&gt;&lt;h2 style="background-color:red"&gt;这里是标题&lt;/h2&gt; &lt;p style="background-color:green"&gt;这里是一个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 注意：style属性淘汰了旧的bgcolor属性。 HTML 样式实例-字体、颜色和尺寸front-family、color以及front-size属性分别定义元素中文字的字体系列、颜色和字体大小。123456&lt;html&gt;&lt;body&gt;&lt;h1 style="front-family:verdana"&gt;标题&lt;/h1&gt;&lt;p style="front-family:arial;color:red;font-size:20px;"段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML 样式实例-文本对齐123456&lt;html&gt;&lt;body&gt;&lt;h1 style="text-align:center"&gt;又是标题啊&lt;/h1&gt; &lt;p&gt;听说上面的标题会居中&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML 引用HTML短的引用1&lt;p&gt;下面是引用：&lt;br /&gt;&lt;q&gt;上面说的对，我是引用&lt;/q&gt;&lt;/p&gt; HTML 长应用HTML blockquote 元素定义被引用的节。1234&lt;p&gt;下面的这个引用听说很长&lt;/p&gt;&lt;br /&gt; &lt;blockquote&gt; 我就是那个很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的引用。 &lt;/blockquote&gt; HTML 缩略词abbrHTML abbr 元素定义缩写或首字母缩略语。例子：1&lt;p&gt;&lt;abbr title="World Health Organization"&gt;WHO&lt;/abbr&gt; 成立于 1948 年。&lt;/p&gt; HTML 计算机代码元素HTML 键盘格式kbd 元素定义键盘输入12&lt;p&gt;打开一个文件，选择&lt;/p&gt;&lt;p&gt;&lt;kbd&gt;File|Open...&lt;/kbd&gt;&lt;/p&gt; HTML 样本格式HTML code 元素定义编程代码示例。注意：code 元素不保留多余的空格和折行。 例子：123456789&lt;p&gt;Coding Example:&lt;/p&gt;&lt;code&gt;var person = &#123; firstName:"Bill", lastName:"Gates", age:50, eyeColor:"bule"&#125;&lt;/code&gt; 如果需要保留多余的空格和折行，必须在pre元素中包围代码。1234567891011&lt;p&gt;Coding Example&lt;/p&gt;&lt;code&gt;&lt;pre&gt;var person = &#123; firstName:"Bill", lastName:"Gates", age:50, eyeColor:"bule"&#125;&lt;/pre&gt;&lt;/code&gt; HTML 变量格式化var 元素定义数学变量123&lt;p&gt;Einstein wrote:&lt;/p&gt;&lt;p&gt;&lt;var&gt;E = m c&lt;sup&gt;2&lt;/sup&gt;&lt;/var&gt;&lt;/p&gt; HTML 注释注释标签&lt;！–与–&gt;用于在HTML插入注释1&lt;!--这里是注释，什么意思呢，就是写在这里的东西都不会显示，所以你懂了吧，注释注释////--&gt; HTML CSS如何使用样式当浏览器读到一个样式表，它就会按照这个样式来度文档进行格式化。有以下三种方式： 外部样式表当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;&lt;/head&gt; 内部样式表当单个文件需要特别样式时，就可以使用内部样式表。可以在head部分通过style标签定义内部样式表。1234567&lt;head&gt;&lt;style type= "text/css"&gt;body&#123;background-color:red&#125;p&#123;margin-left:20px&#125;&lt;/style&gt;&lt;/head&gt; 内联样式当特殊的样式需要应用到个别元素时，就可以使用内联样式。使用内联样式的方法是在相关的标签中使用样式属性，样式属性可以包含任何CSS属性，下面的例子显示如何改变段落的颜色和左外边距。123&lt;P style = "color:red;margin-left:20px"&gt;这是一个段落。 &lt;/p&gt; HTML 链接HTML 使用超级链接与网络上的另一个文档相连。几乎可以在所有的网页中找到链接。点击链接可以从一张页面跳转到另一张页面。 HTML 链接语法1&lt;a href="url"&gt;link text&lt;/a&gt; href属性规定链接的目标。开始标签和结束标签之间的文字被作为超链接来显示。1&lt;a href="https://x-nicolo.github.io/"&gt;肖洒的博客&lt;/a&gt; HTML 链接-target属性使用Target属性，你可以定义被链接的文档显示在何处。1&lt;a href = "http://x-nicolo.github.io" target="_blank"&gt;访问肖洒的博客！&lt;/a&gt; HTML 链接-name属性name 属性规定锚（anchor）的名称。您可以使用name属性创建HTML页面中的书签.书签不会以任何特殊方式显示，它对读者是不可见的。当使用命名锚（named anchors）时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。 命名锚的语法：1&lt;a name = "label"&gt;锚&lt;/a&gt; 例子：首先，在HTML文档中对锚进行命名(创建一个书签)：1&lt;a name="tips"&gt;基本的注意事项-有用的提示&lt;/a&gt; 然后，在同一个文档中创建指向该锚的链接：1&lt;a href="#tips"&gt;有用的提示&lt;/a&gt; HTML 图像图像标签img 和源属性src在HTML中，图像由img标签定义，img是空标签，只包含属性，并且没有闭合标签。要在页面上显示图像，需要使用源属性src，源属性的值是图像的URL地址。定义图像的语法是：1&lt;img src = "url" /&gt; URL指存储图像的位置。如果名为 “boat.gif” 的图像位于www.w3school.com.cn的images 目录中，那么其URL为./images/boat.gif 替换文本属性alt 属性用来为图像定义一串预备的可替换的文本。替换文本属性的值是用户定义的。1&lt;img src="boat.gif" alt="Big Boat"&gt; 在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。为页面上的图像都加上替换文本属性是个好习惯，这样有助于更好的显示信息，并且对于那些使用纯文本浏览器的人来说是非常有用的。 HTML背景图片本例演示如何向HTML页面添加背景图片。1234567&lt;html&gt;&lt;body background="/i/eg_background.jpg"&gt;&lt;h3&gt;图像背景&lt;/h3&gt;&lt;p&gt;gif 和 jpg 文件均可用作 HTML 背景。&lt;/p&gt;&lt;p&gt;如果图像小于页面，图像会进行重复。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML 排列图片1234567891011&lt;html&gt;&lt;body&gt;&lt;h2&gt;未设置对齐方式的图像：&lt;/h2&gt;&lt;p&gt;图像 &lt;img src ="/i/eg_cute.gif"&gt; 在文本中&lt;/p&gt;&lt;h2&gt;已设置对齐方式的图像：&lt;/h2&gt;&lt;p&gt;图像 &lt;img src="/i/eg_cute.gif" align="bottom"&gt; 在文本中&lt;/p&gt;&lt;p&gt;图像 &lt;img src ="/i/eg_cute.gif" align="middle"&gt; 在文本中&lt;/p&gt;&lt;p&gt;图像 &lt;img src ="/i/eg_cute.gif" align="top"&gt; 在文本中&lt;/p&gt;&lt;p&gt;请注意，bottom 对齐方式是默认的对齐方式。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML 浮动图像如何使图片浮动至段落的左边或右边。123456789101112&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;img src ="/i/eg_cute.gif" align ="left"&gt; 带有图像的一个段落。图像的 align 属性设置为 "left"。图像将浮动到文本的左侧。&lt;/p&gt;&lt;p&gt;&lt;img src ="/i/eg_cute.gif" align ="right"&gt; 带有图像的一个段落。图像的 align 属性设置为 "right"。图像将浮动到文本的右侧。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML 调整图像大小如何将图片调整到不同的尺寸. 12345678910&lt;html&gt;&lt;body&gt;&lt;img src="/i/eg_mouse.jpg" width="50" height="50"&gt;&lt;br /&gt;&lt;img src="/i/eg_mouse.jpg" width="100" height="100"&gt;&lt;br /&gt;&lt;img src="/i/eg_mouse.jpg" width="200" height="200"&gt;&lt;p&gt;通过改变 img 标签的 "height" 和 "width" 属性的值，您可以放大或缩小图像。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML 制作图像链接如何将图像作为一个链接使用。12345678910&lt;html&gt;&lt;body&gt;&lt;p&gt;可以把图像作为链接来使用：&lt;a href="/example/html/lastpage.html"&gt;&lt;img border="0" src="/i/eg_buttonnext.gif" /&gt;&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML 表格表格由table标签来定义。每个表格均有若干行（由tr标签定义），每行被分割为若干单元格（由td标签定义）。字母td指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。 12345678910&lt;table border="1"&gt;&lt;tr&gt;&lt;td&gt;row 1, cell 1&lt;/td&gt;&lt;td&gt;row 1, cell 2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;row 2, cell 1&lt;/td&gt;&lt;td&gt;row 2, cell 2&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; HTML 表格和边框属性使用边框属性来显示一个带有边框的表格：123456&lt;table border="1"&gt;&lt;tr&gt;&lt;td&gt;Row 1, cell 1&lt;/td&gt;&lt;td&gt;Row 1, cell 2&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; HTML 表格的表头表格的表头使用th标签进行定义。大多数浏览器会把表头显示为粗体居中的文本：1234567891011121314&lt;table border="1"&gt;&lt;tr&gt;&lt;th&gt;Heading&lt;/th&gt;&lt;th&gt;Another Heading&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;row 1, cell 1&lt;/td&gt;&lt;td&gt;row 1, cell 2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;row 2, cell 1&lt;/td&gt;&lt;td&gt;row 2, cell 2&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; HTML 表格中的空单元格在一些浏览器中，没有内容的表格单元显示得不太好。如果某个单元格是空的（没有内容），浏览器可能无法显示出这个单元格的边框。比如： 12345678910&lt;table border="1"&gt;&lt;tr&gt;&lt;td&gt;row 1, cell 1&lt;/td&gt;&lt;td&gt;row 1, cell 2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;row 2, cell 2&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 注意：这个空的单元格的边框没有被显示出来。为了避免这种情况，在空单元格中添加一个 空格占位符，就可以将边框显示出来。12345678910&lt;table border="1"&gt;&lt;tr&gt;&lt;td&gt;row 1, cell 1&lt;/td&gt;&lt;td&gt;row 1, cell 2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;row 2, cell 2&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 跨行或跨列的表格单元格如何定义跨行或跨列的表格单元格123456789101112131415161718192021222324252627282930&lt;html&gt;&lt;body&gt;&lt;h4&gt;横跨两列的单元格：&lt;/h4&gt;&lt;table border="1"&gt;&lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th colspan="2"&gt;电话&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;Bill Gates&lt;/td&gt; &lt;td&gt;555 77 854&lt;/td&gt; &lt;td&gt;555 77 855&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;h4&gt;横跨两行的单元格：&lt;/h4&gt;&lt;table border="1"&gt;&lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;td&gt;Bill Gates&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;th rowspan="2"&gt;电话&lt;/th&gt; &lt;td&gt;555 77 854&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;555 77 855&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; HTML 列表HTML支持有序、无序和定义列表。 HTML 无序列表无序列表是一个项目的列表，此列项目使用粗体原点进行标记。无序列表使用 ul 标签。1234&lt;ul&gt;&lt;li&gt;牛奶&lt;li&gt;&lt;li&gt;咖啡&lt;li&gt;&lt;/ul&gt; HTML 有序列表自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以 dl 标签开始，每个自定义列表项以 dt开始，每个自定义列表项的定义以 dd 开始。12345&lt;dl&gt;&lt;dt&gt;Coffee&lt;/dt&gt; &lt;dd&gt;-black hot drink&lt;/dd&gt;&lt;dt&gt;-white cold drink&lt;/dd&gt;&lt;/dl&gt; HTML 区块HTML可以通过 div 和 span将元素组合起来。 HTML 区块元素块级元素在浏览器显示时，通常会以新行来开始。例如 h1 p ul table HTML 内联元素内联元素在显示时通常不会以新行开始。 HTML div 元素div 是块级元素，可用于组合其他HTML元素的容器。 HTML span 元素HTML span 元素是内联元素，可用作文本容器。 HTML 布局大多数网站可以使用 或者 元素来创建多列。CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观 HTML 布局-使用 div元素例子：1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;Nicolo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container" style="width:500px"&gt; &lt;div id="header" style="background-color:#FFA500;"&gt;&lt;h1 style="margin-bottom:0;"&gt;主要的网页标题&lt;/h1&gt;&lt;/div&gt; &lt;div id="menu" style="background-color:#FFD700;height:200px;width:100px;float:left;"&gt;&lt;b&gt;菜单&lt;/b&gt;&lt;br&gt;HTML&lt;br&gt;CSS&lt;br&gt;JavaScript&lt;/div&gt; &lt;div id="content" style="background-color:#EEEEEE;height:200px;width:400px;float:left;"&gt;内容在这里&lt;/div&gt; &lt;div id="footer" style="background-color:#FFA500;clear:both;text-align:center;"&gt;版权 © runoob.com&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; HTML 表单HTML表单用于收集不同类型的用户输入。表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。表单使用表单标签 来设置: HTML 表单-输入元素多数情况下被用到的表单标签是输入标签。input.输入类型是由类型属性定义的，大多数经常被用到的输入类型如下。1234&lt;form&gt;First name: &lt;input type="text" name="firstname"&gt;&lt;br&gt;Last name: &lt;input type="text" name="lastname"&gt;&lt;/form&gt; 密码字段密码字段通过标签 input type=”password”来定义。123&lt;form&gt;Password:&lt;input type="password" name="pwd"&gt;&lt;/form&gt; 单选按钮input type=”radio” 标签定义了表单单选边框选项。1234&lt;form&gt;&lt;input type="radio" name="sex" value="male"&gt;Male&lt;br&gt;&lt;input type="radio" name="sex" value="female"&gt;Female&lt;/form&gt; 复选框input type=”checkbox” 定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。 1234&lt;form&gt;&lt;input type="checkbox" name="vehicle" value="Bike"&gt;I have a bike&lt;br&gt;&lt;input type="checkbox" name="vehicle" value="Car"&gt;I have a car &lt;/form&gt; 提交按钮input type=”submit”定义了提交按钮.当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。:1234&lt;form name="input" action="html_form_action.php" method="get"&gt;Username: &lt;input type="text" name="user"&gt;&lt;input type="submit" value="Submit"&gt;&lt;/form&gt; HTML 框架通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。123iframe语法:&lt;iframe src="URL"&gt;&lt;/iframe&gt;该URL指向不同的网页。 Iframe-设置高度与宽度height和width属性用来定义iframe标签的高度与宽度。属性默认以像素为单位，但是可以指定其按比例显示。1&lt;iframe src="demo_iframe.html" frameborder="0"&gt;&lt;/iframe&gt; Iframe -移除边框frameborder属性用于定义iframe表示是否显示边框。设置属性值为”0”移除边框。1&lt;iframe src="demo_iframe.html" frameborder="0"&gt;&lt;/iframe&gt; 使用iframe来显示目标链接页面iframe可以显示一个目标链接的页面目标链接的属性必须使用iframe的属性，如下实例:12&lt;iframe src="demo_iframe.htm" name="iframe_a"&gt;&lt;/iframe&gt;&lt;p&gt;&lt;a href="http://x-nicolo.github.io" target="iframe_a"&gt;Nicolo&lt;/a&gt;&lt;/p&gt; HTML颜色HTML 颜色由红色、绿色、蓝色混合而成。 颜色值HTML 颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。每种颜色的最小值是0（十六进制：#00）。最大值是255（十六进制：#FF）。 例子：相对于使用rgb(255,255,0)使用rgba(255,255,0,0.25)可以实现设置颜色透明度的功能，这里的0.5表示透明度，范围0~1。123456789101112&lt;p style="background-color:rgb(255,255,0)"&gt;通过 rbg 值设置背景颜色&lt;/p&gt;&lt;p style="background-color:rgba(255,255,0,0.25)"&gt;通过 rbg 值设置背景颜色&lt;/p&gt;&lt;p style="background-color:rgba(255,255,0,0.5)"&gt;通过 rbg 值设置背景颜色&lt;/p&gt;&lt;p style="background-color:rgba(255,255,0,0.75)"&gt;通过 rbg 值设置背景颜色&lt;/p&gt; HTML 颜色名目前所有浏览器都支持以下颜色名。141个颜色名称是在HTML和CSS颜色规范定义的（17标准颜色，再加124）。下表列出了所有颜色的值，包括十六进制值。Remark 提示: 17标准颜色：黑色，蓝色，水，紫红色，灰色，绿色，石灰，栗色，海军，橄榄，橙，紫，红，白，银，蓝绿色，黄色。点击其中一个颜色名称（或一个十六进制值）就可以查看与不同文字颜色搭配的背景颜色。 HTML 颜色值颜色由红(R)、绿(G)、蓝(B)组成。 颜色值颜色值由十六进制来表示红、绿、蓝（RGB）。每个颜色的最低值为0(十六进制为00)，最高值为255(十六进制为FF)十六进制值的写法为#号后跟三个或六个十六进制字符。三位数表示法为：#RGB，转换为6位数表示为：#RRGGBB。 HTML 脚本JavaScript 使 HTML 页面具有更强的动态和交互性。插入一个脚本：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;Nicolo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;document.write("Hello World")&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML script 标签script标签用于定义客户端脚本，比如JavaScript。script元素既可包含脚本语句，也可通过 src 属性指向外部脚本文件。JavaScript 最常用于图片操作、表单验证以及内容动态更新。下面的脚本会向浏览器输出”Hello World!”：123&lt;script&gt;document.write("Hello World!");&lt;/script&gt; HTML noscript 标签noscript 标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本时。noscript元素可包含普通 HTML 页面的 body 元素中能够找到的所有元素。只有在浏览器不支持脚本或者禁用脚本时，才会显示 noscript&gt;元素中的内容：1234&lt;script&gt;document.write("Hello World!")&lt;/script&gt;&lt;noscript&gt;抱歉，你的浏览器不支持 JavaScript!&lt;/noscript&gt; JavaScript体验JavaScript可以直接在HTML输出:1document.write("&lt;p&gt;这是一个段落。&lt;/p&gt;"); JavaScript事件响应:1&lt;button type="button" onclick="myFunction()"&gt;点我！&lt;/button&gt; JavaScript处理 HTML 样式:1document.getElementById("demo").style.color="#ff0000"; HTML 字符实体HTML中的预留字符必须被替换为字符实体。一些在键盘上找不到的字符也可以使用字符实体来替换。 HTML 实体在 HTML 中，某些字符是预留的。在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。 字符实体类似这样：123&amp;entity_name;或&amp;#entity_number; 如需显示小于号，我们必须这样写：&lt; 或 &#60; 或 &#060; 不间断空格(Non-breaking Space)HTML 中的常用字符实体是不间断空格(&nbsp;)。浏览器总是会截短 HTML 页面中的空格。如果您在文本中写10个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，您需要使用&nbsp;字符实体。 HTML URLURL是一个网页地址。URL可以由字母组成，或互联网协议（IP）地址： 192.68.20.50。大多数人进入网站使用网站域名来访问，因为名字比数字更容易记住。 URL- 统一资源定位器Web浏览器通过URL从Web服务器请求页面。当您点击 HTML 页面中的某个链接时，对应的a标签指向万维网上的一个地址。一个统一资源定位器(URL) 用于定位万维网上的文档。 URL 字符编码URL只能使用ASCII字符集.来通过因特网进行发送。由于URL常常会包含ASCII合之外的字符，URL 必须转换为有效的 ASCII 格式。URL编码使用 “%”其后跟随两位的十六进制数来替换非 ASCII 字符。URL不能包含空格。URL编码通常使用 + 来替换空格。 HTML 速查列表备日常使用。 HTML 基本文档123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;文档标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;可见文本...&lt;/body&gt;&lt;/html&gt; HTML 基本标签1234567891011&lt;h1&gt;最大的标题&lt;/h1&gt;&lt;h2&gt; . . . &lt;/h2&gt;&lt;h3&gt; . . . &lt;/h3&gt;&lt;h4&gt; . . . &lt;/h4&gt;&lt;h5&gt; . . . &lt;/h5&gt;&lt;h6&gt;最小的标题&lt;/h6&gt; &lt;p&gt;这是一个段落。&lt;/p&gt;&lt;br&gt; （换行）&lt;hr&gt; （水平线）&lt;!-- 这是注释 --&gt; HTML 文本格式化123456789101112131415161718&lt;b&gt;粗体文本&lt;/b&gt;&lt;code&gt;计算机代码&lt;/code&gt;&lt;em&gt;强调文本&lt;/em&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;kbd&gt;键盘输入&lt;/kbd&gt; &lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;small&gt;更小的文本&lt;/small&gt;&lt;strong&gt;重要的文本&lt;/strong&gt; &lt;abbr&gt; （缩写）&lt;address&gt; （联系信息）&lt;bdo&gt; （文字方向）&lt;blockquote&gt; （从另一个源引用的部分）&lt;cite&gt; （工作的名称）&lt;del&gt; （删除的文本）&lt;ins&gt; （插入的文本）&lt;sub&gt; （下标文本）&lt;sup&gt; （上标文本） HTML 链接123456普通的链接：&lt;a href="http://www.example.com/"&gt;链接文本&lt;/a&gt;图像链接： &lt;a href="http://www.example.com/"&gt;&lt;img src="URL" alt="替换文本"&gt;&lt;/a&gt;邮件链接： &lt;a href="mailto:webmaster@example.com"&gt;发送e-mail&lt;/a&gt;书签：&lt;a id="tips"&gt;提示部分&lt;/a&gt;&lt;a href="#tips"&gt;跳到提示部分&lt;/a&gt; 图片1&lt;img src="URL" alt="替换文本" height="42" width="42"&gt; 样式/区块123456&lt;style type="text/css"&gt;h1 &#123;color:red;&#125;p &#123;color:blue;&#125;&lt;/style&gt;&lt;div&gt;文档中的块级元素&lt;/div&gt;&lt;span&gt;文档中的内联元素&lt;/span&gt; 无序列表1234&lt;ul&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt;&lt;/ul&gt; 有序列表1234&lt;ol&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt; 定义列表123456&lt;dl&gt; &lt;dt&gt;项目 1&lt;/dt&gt; &lt;dd&gt;描述项目 1&lt;/dd&gt; &lt;dt&gt;项目 2&lt;/dt&gt; &lt;dd&gt;描述项目 2&lt;/dd&gt;&lt;/dl&gt; 表格12345678910&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 框架1&lt;iframe src="demo_iframe.htm"&gt;&lt;/iframe&gt; 表单12345678910111213141516&lt;form action="demo_form.php" method="post/get"&gt;&lt;input type="text" name="email" size="40" maxlength="50"&gt;&lt;input type="password"&gt;&lt;input type="checkbox" checked="checked"&gt;&lt;input type="radio" checked="checked"&gt;&lt;input type="submit" value="Send"&gt;&lt;input type="reset"&gt;&lt;input type="hidden"&gt;&lt;select&gt;&lt;option&gt;苹果&lt;/option&gt;&lt;option selected="selected"&gt;香蕉&lt;/option&gt;&lt;option&gt;樱桃&lt;/option&gt;&lt;/select&gt;&lt;textarea name="comment" rows="60" cols="20"&gt;&lt;/textarea&gt; &lt;/form&gt; 实体123&amp;lt; 等同于 &lt;&amp;gt; 等同于 &gt;&amp;#169; 等同于 ©]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跳一跳刷分指南（作弊攻略）]]></title>
    <url>%2F2018%2F01%2F02%2F%E8%B7%B3%E4%B8%80%E8%B7%B3%E5%88%B7%E5%88%86%E6%8C%87%E5%8D%97%EF%BC%88%E4%BD%9C%E5%BC%8A%E6%94%BB%E7%95%A5%EF%BC%89-1%2F</url>
    <content type="text"><![CDATA[略略略。自从刷了分好多好友都来问我，我还是写一个指（作）南（弊）吧。游戏虽好玩，且刷且珍惜。（谢好友们不删之恩没耐心的直接拉到最后的总结，两步到位。 外挂最近在微博看到好多物理外挂，还有一些基于图像识别的外挂。其实都算是伤神费力，毛爷爷说过，看问题要抓住关键矛盾,一切问题迎刃而解。所以抓包去看看。 抓包以前使用过fiddle，觉得非常nice。但是这玩意在电脑端抓包，不还得设置代理，再去抓微信数据，比较烦，所以找个安卓机直接抓包。 Packet Capture安卓机上下载这个，一步一步来，会提示安装证书，安装即可。安装好后长这样： session ID点三角形开始的按钮，在抓包软件里找到微信，然后打开跳一跳玩一把。 返回抓包软件，查找有SSL的文件，点开找json文件，找session ID。 就在这里。把session ID后面双引号的序列保存下来。 代码此为开源的一个代码，直接改下面的session_id，和自己想要的”score”: 10086就可以，应该能跑起来，但是python的环境配置有时还是挺恶心的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requestsimport jsonimport timefrom Crypto.Cipher import AESimport base64action_data = &#123; "score": 10086, "times": 666, "game_data": "&#123;&#125;"&#125;session_id = "5TrXoE7IXtM/Nr7vITnbU9bmR53VH0u8RkVnm6m/Fezg=="aes_key = session_idaes_iv = aes_keycryptor = AES.new(aes_key, AES.MODE_CBC, aes_iv)str_action_data = json.dumps(action_data).encode("utf-8")print("json_str_action_data ", str_action_data)#Pkcs7length = 16 - (len(str_action_data) % 16)str_action_data += bytes([length])*lengthcipher_action_data = base64.b64encode(cryptor.encrypt(str_action_data)).decode("utf-8")print("action_data ", cipher_action_data)post_data = &#123; "base_req": &#123; "session_id": session_id, "fast": 1, &#125;, "action_data": cipher_action_data&#125;headers = &#123; "charset": "utf-8", "Accept-Encoding": "gzip", "referer": "https://servicewechat.com/wx7c8d593b2c3a7703/3/page-frame.html", "content-type": "application/json", "User-Agent": "MicroMessenger/6.6.1.1200(0x26060130) NetType/WIFI Language/zh_CN", "Content-Length": "0", "Host": "mp.weixin.qq.com", "Connection": "Keep-Alive"&#125;url = "https://mp.weixin.qq.com/wxagame/wxagame_settlement"response = requests.post(url, json=post_data, headers=headers)print(json.loads(response.text)) web提交当然，游戏通关的策略当然是越简单越好，有位大神写了一个这个程序的Java版，直接可以web端提交。 【点这个】填写sessionID和想要的分数，提交即可真的是太暴力了。。这个漏洞目前还没修复。 总结 第一步：抓包，获取sessionID（请看Packet Capture） 第二步：web提交]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西电睿思年度非官方关键字榜单]]></title>
    <url>%2F2017%2F12%2F19%2F%E7%9D%BF%E6%80%9D%E6%A6%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[西电睿思 西电睿思，建立于2009年9月，是一个面向西安电子科技大学师生的以资源共享为主，包括论坛在内诸多功能的综合集娱乐、学习、资源交流的平台。名字取自“睿智善思”和“resource”的谐音，网站的宗旨是“永远不去谋求任何商业利益，只为西电人有一个高速下载的地方，有一个开心聊天交朋友的地方而努力”。 初衷首先要说的是真的特别喜欢睿思，也特别喜欢它的宗旨！“永远不去谋求任何商业利益，只为西电人有一个高速下载的地方，有一个开心聊天交朋友的地方而努力”。睿思背后的技术团队一定是伟大，灿烂的！技术也是有温度的！ 之前写了一个简单的爬虫登录睿思领金币（其实我也没怎么领，因为金币够用。[偷笑][偷笑]）。就有一个想法，希望年底能对睿思做一个报告分析,特别好奇西电er在学习磕盐之余关心什么。 本来的计划是爬取睿思全站的信息，后来因为种种事情忙的不可开交，只对西电睿思灌水专区、相聚睿思板块的发帖人、帖子标题。帖子内容进行了采集。当然，采集的时长和网速都有控制，不会对睿思服务器造成影响的~(采集过程中出了好多幺蛾子！xue微的用了人工“断点采集”……) 采集内容统计1234板块：西电睿思灌水专区 时间段： 2017-12-18~2016-10-7 有效帖子数：24940 字数：4102465 1234板块：相聚睿思 时间段： 2017-12-19~2010-11-24 有效帖子数：2618 字数：439649 12帖子总计：27558 字数总计：4130023 灌水专区关键字榜单对采集的信息首先进行了结巴分词，然后做了词频统计。使用了停用表过滤（就是过滤嗯、啊、的这些没意思的词语），发现还是有很多BBS的用语，就自己又建立了一个过滤表，体现我个人倾向以及非官方的时候到了[哈哈]。得到以下排行： “可以”“可以”？什么可以？可以什么？ Are you ok ?可以可以，很可以。我电孩纸们难道很佛系？当然，也希望大家可以一直可以下去，2018年里一直可以!一直ok下去！ “他” “她”“他”的次数出现了3280次。“她”的次数出现了1739次。 本来以为“食堂”（580）、“餐厅”（249）、“空调”（359）会上榜。看到这个榜单，其实还是比较符合睿思上的情况的。“工作”、“毕业”、“手机”、“研究生”、“流量”、“宿舍”等等，就是我们日常的日常啊。 缘聚睿思关键字榜单 “老乡”缘聚睿思的板块，采集的数据比较久远。“老乡”一共出现了734次。看来大家还是喜欢找一个老乡或者喜欢给老乡找一个。“可以”又出现了，到底什么可以呢？？？希望一切都可以吧。 “妹子”“妹子”出现排行第三，不知道怎么解释了。[尴尬] “身高”我觉得这个可能是最有意义的了，到底睿思的标准是不是173？？刚刚写了个正则，发现还是不能很好的匹配出好的结果。（然而我要去忙了，后面再做分析吧） （updating）~~~ 问题集合遇到的问题:捕获异常、重复处理、网络异常502,504，数据库数据类型错误]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络数据采集]]></title>
    <url>%2F2017%2F12%2F17%2F%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%2F</url>
    <content type="text"><![CDATA[“网络数据采集是为普通大众所喜闻乐见的计算机巫术”。 bug 是产品生命中的挑战，好产品是不断面对 bug 并战胜 bug 的结果。 有人说编程语言就是宗教，不同语言的设计哲学不同，行为方式各异，“非我族类，其心必异”，但本着美好生活、快乐修行的初衷，我们对所有语言都时刻保持敬畏之心，尊重信仰自由，努力做好自己的功课。对爱好Python的人来说，人生苦短，Python当歌！ 学习笔记。ALL FROM：Web Scraping with Python: Collecting Data from the Modern Web先填坑。 第一部分 创建爬虫 第1章 初见网络爬虫第2章 复杂HTML解析第3章 开始采集第4章 使用API第5章 存储数据第6章 读取文档 第二部分 高级数据采集 第7章 数据清洗第8章 自然语言处理第9章 穿越网页表单与登录窗口进行采集第10章 采集JavaScript第11章 图像识别与文字处理第12章 避开采集陷阱第13章 用爬虫测试网站第14章 远程采集 第一部分 创建爬虫重点介绍网络数据采集的基本原理。如何用 Python 从网络服务器请求信息，如何对服务器的响应进行基本处理，以及如何以自动化手段与网站进行交互。 第1章 初见网络爬虫网络链接1234from urllib.request import urlopen #查找 Python 的 request 模块（在 urllib库里面），只导入一个urlopen 函数。html = urlopen("http://pythonscraping.com/pages/page1.html")print(html.read()) 这是一个获取http://pythonscraping.com/pages/page1.html 网页的全部HTML代码的程序。 urllib &amp; urllib2:在 Python 3.x 里，urllib2改名为urllib，被分成一些子模块： urllib.request、urllib.parse 和 你urllib.error。urllib是Python的标准库（就是说不用额外安装就可以运行这个例子），包含了从网络请求数据，处理 cookie，甚至改变像请求头和用户代理这些元数据的函数。 urlopen:用来打开并读取一个从网络获取的远程对象。因为它是一个非常通用的库（它可以轻松读取HTML文件、图像文件，或其他任何文件流)。 BeautifulSoup简介BeautifulSoup通过定位HTML标签来格式化和组织复杂的网络信息，用简单易用的Python对象展现XML结构信息。 安装安装 Python 的包管理器 pip，然后运行:1$pip install beautifulsoup4 注意:Python2、Python3的版本问题。 运行Beautifulsoup412345678from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen("http://www.pythonscraping.com/pages/page1.html") bsObj = BeautifulSoup(html.read())#调用 html.read() 获取网页的 HTML 内容 print(bsObj.h1) 输出结果：1&lt;h1&gt;An Interesting Title&lt;/h1&gt; 从网页中提取的h1标签被嵌在 BeautifulSoup 对象 bsObj 结构的第二层（html → body→ h1）。但是，当我们从对象里提取 h1 标签的时候，可以直接调用它:1bsObj.h1 其实，下面的所有函数调用都可以产生同样的结果：123bsObj.html.body.h1bsObj.body.h1bsObj.html.h1 可靠的网络链接1html = urlopen("http://www.pythonscraping.com/pages/page1.html") 这行代码主要可能会发生两种异常：• 网页在服务器上不存在（或者获取页面的时候出现错误）• 服务器不存在第一种异常发生时，程序会返回HTTP错误。HTTP错误可能是“404 Page Not Found”“500Internal Server Error”等。所有类似情形，urlopen函数都会抛出“HTTPError”异常。我们可以用下面的方式处理这种异常：1234567try: html = urlopen("http://www.pythonscraping.com/pages/page1.html")except HTTPError as e: print(e) # 返回空值，中断程序，或者执行另一个方案else: # 程序继续。注意：如果你已经在上面异常捕捉那一段代码里返回或中断（break）那么就不需要使用else语句了，这段代码也不会执行 如果程序返回 HTTP 错误代码，程序就会显示错误内容，不再执行else语句后面的代码。 第2章 复杂HTML解析面对页面解析难题（Gordian Knot）的时候，不假思索地直接写几行语句来抽取信息是非常直接的做法。但是，像这样鲁莽放纵地使用技术，只会让程序变得难以调试或脆弱不堪，甚至二者兼具。正确的做法：• 寻找“打印此页”的链接，或者看看网站有没有 HTML 样式更友好的 移动版（把自己的请求头设置成处于移动设备的状态，然后接收网站移动版。移动版后面还会提到，是一个获取数据非常好的渠道。当有一个网页很难爬去的时候，应该去试试它的移动版。• 寻找隐藏在 JavaScript 文件里的信息。要实现这一点，你可能需要查看网页加载的JavaScript 文件。• 虽然网页标题经常会用到，但是这个信息也许可以从网页的URL链接里获取。• 如果要找的信息只存在于一个网站上， 别处没有，那确实是运气不佳。如果不只限于这个网站，那么可以找找其他数据源。有没有其他网站也显示了同样的数据？网站上显示的数据是不是从其他网站上抓取后攒出来的？ BeautifulSoup将介绍通过属性查找标签的方法，标签组的使用，以及标签解析树的导航过程。CSS的发明是网络爬虫的福音。CSS可以让HTML元素呈现出差异化，使那些具有完全相同修饰的元素呈现出不同的样式。 例子：创建一个网络爬虫来抓取http://www.pythonscraping.com/pages/warandpeace.html 这个网页。 创建一个 BeautifulSoup 对象，和第1章里使用的程序类似：1234from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen("http://www.pythonscraping.com/pages/warandpeace.html")bsObj = BeautifulSoup(html) 通过BeautifulSoup对象，可以用findAll函数抽取只包含在1&lt;span class="green"&gt;&lt;/span&gt; 标签里的文字，这样就会得到一个人物名称的Python列表（findAll是一个非常灵活的函数，后面会经常用到它）：123nameList = bsObj.findAll("span", &#123;"class":"green"&#125;)for name in nameList: print(name.get_text()) 之前调用 bsObj.tagName 只能获取页面中的第一个指定的标签。现在调用 bsObj.findAll(tagName, tagAttributes)可以获取页面中所有指定的标签，不再只是第一个了。获取人名列表之后,程序遍历列表中所有的名字，然后打印name.get_text()，就可以把标签中的内容分开显示了。 get_text():.get_text()会把正在处理的HTML文档中所有的标签都清除，然后返回一个只包含文字的字符串。 假如正在处理一个包含许多超链接、段落和标签的大段源代码，那么 .get_text()会把这些超链接、段落和标签都清除掉，只剩下一串不带标签的文字。用BeautifulSoup对象查找想要的信息，比直接在HTML文本里查找信息要简单得多。 通常在准备打印、存储和操作数据时，应该最后才使用.get_text()。一般情况下，应该尽可能地保留HTML文档的标签结构。后面说不定还会用到的。 BeautifulSoup的find()和findAll()BeautifulSoup里的find()和findAll()可能是最常用的两个函数。借助它们可以通过标签的不同属性轻松地过滤 HTML页面，查找需要的标签组或单个标签。这两个函数非常相似，BeautifulSoup文档里两者的定义就是这样：12findAll(tag, attributes, recursive, text, limit, keywords)find(tag, attributes, recursive, text, keywords) 标签参数tag前面已经介绍过——可以传一个标签的名称或多个标签名称组成的Python列表做标签参数。例如，下面的代码将返回一个包含HTML文档中所有标题标签的列表: 1.findAll(&#123;"h1","h2","h3","h4","h5","h6"&#125;) 属性参数attributes是用一个Python字典封装一个标签的若干属性和对应的属性值。例如，下面这个函数会返回HTML文档里红色与绿色两种颜色的span标签： 1.findAll("span", &#123;"class":&#123;"green", "red"&#125;&#125;) 递归参数recursive是一个布尔变量。你想抓取HTML文档标签结构里多少层的信息？如果recursive 设置为True，findAll就会根据你的要求去查找标签参数的所有子标签，以及子标签的子标签。如果recursive设置为False，findAll 就只查找文档的一级标签。findAll默认是支持递归查找的（recursive默认值是True）；一般情况下这个参数不需要设置，除非你真正了解自己需要哪些信息，而且抓取速度非常重要，那时你可以设置递归参数。 PS：之前感觉都是在瞎胡爬啊，现在再回头看，遇到的问题都是讲过的。书，还是要看三遍才算看过。 文本参数text有点不同，它是用标签的文本内容去匹配，而不是用标签的属性。假如想查找前面网页中包含“the prince”内容的标签数量，可以把之前的findAll方法换成下面的代码：12nameList = bsObj.findAll(text="the prince")print(len(nameList)) 输出结果为“ 7”。 范围限制参数limit，显然只用于findAll方法。find其实等价于findAll的limit等于1时的情形。如果你只对网页中获取的前x项结果感兴趣，就可以设置它。但是要注意，这个参数设置之后，获得的前几项结果是按照网页上的顺序排序的，未必是你想要的那前几项。PS:之前的爬虫，也遇到过这种情况。解决的办法是切片的方法。 还有一个关键词参数keyword，可以让你选择那些具有指定属性的标签。例如： 12allText = bsObj.findAll(id="text") print(allText[0].get_text()) 其他BeautifulSoup对象BeautifulSoup库里的两种对象。• BeautifulSoup对象：前面代码示例中的bsObj• 标签Tag对象：BeautifulSoup对象通过find和findAll，或者直接调用子标签获取的一列对象或单个对象，就像：bsObj.div.h1• NavigableString对象：用来表示标签里的文字，不是标签（有些函数可以操作和生成NavigableString 对象，而不是标签对象）。• Comment对象：用来查找HTML文档的注释标签，1&lt;!-- 像这样 --&gt; 导航树findAll函数通过标签的名称和属性来查找标签。但是如果需要通过标签在文档中的位置来查找标签，该怎么办？这就是导航树（Navigating Trees）的作用。在第1章里，我们看过用单一方向进行BeautifulSoup标签树的导航：1bsObj.tag.subTag.anotherSubTag。 处理子标签和其他后代标签在 BeautifulSoup库里，孩子（child）和后代（descendant）有显著的不同：和人类的家谱一样，子标签就是一个父标签的下一级，而后代标签是指一个父标签下面所有级别的标签。例如，tr标签是tabel标签的子标签，而tr、th、td、img和span标签都是tabel 标签的后代标签（我们的示例页面中就是如此）。所有的子标签都是后代标签，但不是所有的后代标签都是子标签。如果你只想找出子标签，可以用 .children 标签：123456from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen("http://www.pythonscraping.com/pages/page3.html")bsObj = BeautifulSoup(html)for child in bsObj.find("table",&#123;"id":"giftList"&#125;).children:print(child) 这段代码会打印giftList表格中所有产品的数据行。如果你用descendants()函数而不是children() 函数，那么就会有二十几个标签打印出来，包括img标签、span标签，以及每个td标签。掌握子标签与后代标签的差别十分重要！ 处理兄弟标签BeautifulSoup 的 next_siblings()函数可以让收集表格数据成为简单的事情，尤其是处理带标题行的表格：123456from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen("http://www.pythonscraping.com/pages/page3.html")bsObj = BeautifulSoup(html)for sibling in bsObj.find("table",&#123;"id":"giftList"&#125;).tr.next_siblings: print(sibling) 这段代码会打印产品列表里的所有行的产品，第一行表格标题除外。为什么标题行被跳过了呢？有两个理由。首先，对象不能把自己作为兄弟标签。任何时候你获取一个标签的兄弟标签，都不会包含这个标签本身。其次，这个函数只调用后面的兄弟标签。例如，如果我们选择一组标签中位于中间位置的一个标签，然后用next_siblings()函数，那么它就只会返回在它后面的兄弟标签。因此，选择标签行然后调用next_siblings，可以选择表格中除了标题行以外的所有行。 让标签的选择更具体:如果我们选择bsObj.table.tr或直接就用bsObj.tr来获取表格中的第一行，上面的代码也可以获得正确的结果。但是，我们还是采用更长的形式写了一行代码，这可以避免各种意外：1bsObj.find("table",&#123;"id":"giftList"&#125;).tr 即使页面上只有一个表格（或其他目标标签），只用标签也很容易丢失细节。另外，页面布局总是不断变化的。一个标签这次是在表格中第一行的位置，没准儿哪天就在第二行或第三行了。 如果想让你的爬虫更稳定，最好还是让标签的选择更加具体。如果有属性，就利用标签的属性。和next_siblings一样，如果你很容易找到一组兄弟标签中的最后一个标签，那么previous_siblings函数也会很有用。当然，还有next_sibling和previous_sibling函数，与next_siblings和previous_siblings的作用类似，只是它们返回的是单个标签，而不是一组标签。 父标签处理偶尔在特殊情况下你也会用到BeautifulSoup 的父标签查找函数， parent 和 parents。例如：123456from urllib.request import urlopenfrom bs4 import BeautifulSoup html = urlopen("http://www.pythonscraping.com/pages/page3.html")bsObj = BeautifulSoup(html)print(bsObj.find("img",&#123;"src":"../img/gifts/img1.jpg"&#125;).parent.previous_sibling.get_text()) 这是如何实现的呢？下面的图形是我们正在处理的HTML页面的部分结构，用数字表示步骤的话：1234567• &lt;tr&gt; — &lt;td&gt; — &lt;td&gt; — &lt;td&gt;(3) — "$15.00" (4) — &lt;td&gt;(2) — &lt;img src="../img/gifts/img1.jpg"&gt; (1) (1) 选择图片标签 src=”../img/gifts/img1.jpg”；(2) 选择图片标签的父标签（在示例中是 td 标签）；(3)选择td标签的前一个兄弟标签previous_sibling（在示例中是包含美元价格的td标签）；(4) 选择标签中的文字，“ $15.00”。 正则表达式 如果你有一个问题要用到正则表达式，那么这就成两个问题了。 之所以叫正则表达式，是因为它们可以识别正则字符串（regular string）；也就是说，它们可以这么定义：“如果你给我的字符串符合规则，我就返回它”，或者是“如果字符串不符合规则，我就忽略它”。这在要求快速浏览大文档，以查找像电话号码和邮箱地址之类的字符串时是非常方便的。比如：“aaaabbbbbccccd”“aabbbbbcc”等正则表达式就是表达这组规则的缩写。这组规则的正则表达式如下所示：1aa*bbbbb(cc)*(d|) 分解之后就会很清楚了。• aaa后面跟着的a（读作a星）表示“重复 任意次 a，包括0次”。这样就可以保证字母a至少出现一次。• bbbbb这没有什么特别的——就是5次b。• (cc)任意偶数个字符都可以编组， 这个规则是用括号两个c，然后后面跟一个星号，表示有任意次两个c（也可以是0次）。• (d|)增加一个竖线（ |）在表达式里表示“这个 或* 那个”。本例是表示“增加一个后面跟着空格的d，或者只有一个空格”。这样我们可以保证字符串的结尾最多是一个后面跟着空格的d。正则表达式在实际中的一个经典应用是识别邮箱地址。虽然不同邮箱服务器的邮箱地址的具体规则不尽相同， 但是我们还是可以创建几条通用规则. 规则：邮箱地址的第一部分至少包括一种内容： 大写字母、小写字母、数字 0~9、点号（.）、加号（+）或下划线（ _） 正则表达式：[A-Za-z0-9._+]+：这个正则表达式简写非常智慧。例如，它用“A-Z”表示“任意A~Z的大写字母”。把所有可能的序列和符号放在中括号（不是小括号）里表示“括号中的符号里任何一个”。要注意后面的加号，它表示“这些符号都可以出现多次，且至少出现1次” 规则：邮箱地址会包含一个@符号正则表达式：@：这个符号很直接。@符号必须出现在中间位置，有且仅有 1 次 规则：在符合@之后，邮箱地址还必须至少包含一个大写或小写字母正则表达式：[A-Za-z]+：可能只在域名的前半部分、符号@后面用字母。而且，至少有一个字。 规则：之后跟一个点号（ .）正则表达式：.：在域名前必须有一个点号（ .） 规则：最后邮箱地址用com、org、edu、net结尾（实际上，顶级域名有很多种可能，但是作为示例演示这四个后缀够用了）。正则表达式：(com|org|edu|net)：这样列出了邮箱地址中可能出现在点号之后的字母序列把上面的规则连接起来，就获得了完整的正则表达式： 1[A-Za-z0-9\._+]+@[A-Za-z]+\.(com|org|edu|net) 正则表达式和BeautifulSoup直接定位那些标签来查找信息。直接通图片的文件路径来查找：12345678from urllib.request import urlopenfrom bs4 import BeautifulSoupimport rehtml = urlopen("http://www.pythonscraping.com/pages/page3.html")bsObj = BeautifulSoup(html)images = bsObj.findAll("img",&#123;"src":re.compile("\.\.\/img\/gifts/img.*\.jpg")&#125;)for image in images:print(image["src"]) 这段代码会打印出图片的相对路径，都是以../img/gifts/img开头，以.jpg结尾，其结果如下所示：12345../img/gifts/img1.jpg../img/gifts/img2.jpg../img/gifts/img3.jpg../img/gifts/img4.jpg../img/gifts/img6.jpg 正则表达式可以作为BeautifulSoup语句的任意一个参数，让目标元素查找工作极具灵活性。 获取属性在网络数据采集时经常不需要查找标签的内容，而是需要查找标签属性。比如标签:a指向的URL链接包含在href属性中，或者img标签的图片文件包含在src属性中，这时获取标签属性就变得非常有用了。对于一个标签对象，可以用下面的代码获取它的全部属性：myTag.attrs要注意这行代码返回的是一个Python字典对象，可以获取和操作这些属性。比如要获取图片的资源位置 src，可以用下面这行代码：1myImgTag.attrs["src"] Lambda表达式这个在前博客的Python3集合学习中已经提交到了。Lambda表达式本质上就是一个函数，可以作为其他函数的变量使用；也就是说，一个函数不是定义成 f(x, y)，而是定义成 f(g(x), y)，或f(g(x),h(x))的形式。BeautifulSoup 允许我们把特定函数类型当作findAll函数的参数。唯一的限制条件是这些函数必须把一个标签作为参数且返回结果是布尔类型。BeautifulSoup用这个函数来评估它遇到的每个标签对象，最后把评估结果为“真”的标签保留，把其他标签剔除。例如，下面的代码就是获取有两个属性的标签： 1soup.findAll(lambda tag: len(tag.attrs) == 2) 这行代码会找出下面的标签： 12&lt;div class="body" id="content"&gt;&lt;/div&gt;&lt;span style="color:red" class="title"&gt;&lt;/span&gt; 超越BeautifulSoup• lxml这个库（ http://lxml.de/） 可以用来解析HTML和XML文档，以非常底层的实现而闻名于世，大部分源代码是用C语言写的。虽然学习它需要花一些时间（其实学习曲线越陡峭，表明你可以越快地学会它），但它在处理绝大多数HTML文档时速度都非常快。• HTML parser这是Python自带的解析库（ https://docs.python.org/3/library/html.parser.html）。 因为它不用安装（只要装Python就有），所以可以很方便地使用。 第3章 开始采集遍历单个域名西电睿思首页： 获取西电睿思首页并提取页面链接的 Python 代码：1234567891011121314from urllib.request import urlopenfrom bs4 import BeautifulSoup html = urlopen("http://rs.xidian.edu.cn/portal.php") bsObj = BeautifulSoup(html) for link in bsObj.findAll("a"): if 'href' in link.attrs: if (link.attrs['href'][:5] == "forum"): print("http://rs.xidian.edu.cn/" + link.attrs['href']) elif((link.attrs['href'][:4] == "home")): print("http://rs.xidian.edu.cn/" + link.attrs['href']) elif ((link.attrs['href'][:6] == "portal")): print("http://rs.xidian.edu.cn/" + link.attrs['href']) else: print(link.attrs['href']) forum和home开头的RUL都是主页的链接。 首页爬取的URL：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412http://rs.xidian.edu.cn/http://weibo.com/xdrsbthttp://rs.xidian.edu.cn/static/image/common/banner/weichat.jpghttp://bbs.rs.xidian.mehttp://rs.xidian.edu.cn/uTorrent.ziphttp://rs.xidian.edu.cn/utorrentForMac.ziphttp://rs.xidian.edu.cn/AndroidRS.apkhttps://jq.qq.com/?_wv=1027&amp;k=43TLwVIjavascript:;javascript:;member.php?mod=register./javascript:;member.php?mod=registerjavascript:;http://rs.xidian.edu.cn/portal.phphttp://rs.xidian.edu.cn/forum.phpbt.php?mod=browse&amp;t=allbt.php?mod=upload#http://rs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=566http://doufm.info/#rsjc.phpmisc.php?mod=faqmisc.php?mod=ranklistplugin.php?id=dsu_paulsign:signhttp://bbs.xidian.edu.cnhttp://123.xidian.edu.cnplugin.php?id=dsu_paulsign:signbt.php?mod=browse&amp;t=digestbt.php?mod=browse&amp;t=hotbt.php?mod=browse&amp;t=highlighthttp://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=662797http://hdtv.neu6.edu.cn/http://tv.byr.cn/javascript:;search.php?mod=forum&amp;srchtxt=%E5%81%9A%E7%A7%8D%20%E6%95%99%E7%A8%8B&amp;formhash=0ede9aec&amp;searchsubmit=true&amp;source=hotsearchsearch.php?mod=forum&amp;srchtxt=%E7%94%B5%E5%BD%B1%20%E6%AC%A7%E7%BE%8E&amp;formhash=0ede9aec&amp;searchsubmit=true&amp;source=hotsearchsearch.php?mod=forum&amp;srchtxt=%E5%89%A7%E9%9B%86%20%E9%9F%A9%E5%89%A7&amp;formhash=0ede9aec&amp;searchsubmit=true&amp;source=hotsearchsearch.php?mod=forum&amp;srchtxt=%E8%A7%86%E9%A2%91&amp;formhash=0ede9aec&amp;searchsubmit=true&amp;source=hotsearchjavascript:;http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=285587http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=880644http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=285411http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=862260http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=298698http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=862155http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=287561http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=861570http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=284186http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=860952http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=304543http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=860425http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=288755http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=855711http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=301434http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=855579http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=62484http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=847337http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=71870http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=837603http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=898059http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=896025http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=889965http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=887913http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=885831http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=885753http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=885651http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=870379http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=885048http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=880420http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=869432http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=874905http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=874304http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=872229http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=869049http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=868111http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=867138http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=867859http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=866769http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=820179http://rs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=157http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901386http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=287668http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901386http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901350http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=42884http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901350http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900991http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=42884http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900991http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900689http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=42884http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900689http://rs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=21http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=276989http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=895317http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=300656http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=890614http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=190294http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=890170http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=64489http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=889730http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=260560http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=889749http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=262727http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=889568http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=284115http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=732034http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=214850http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=457107http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=214850http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=721807http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=193867http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=649913http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=241562http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=720116http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901529http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901528http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901527http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901526http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901525http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901524http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901523http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901522http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901521http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901520http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=898030http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=309281http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=898030http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=899628http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=284864http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=899628http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=897855http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=309281http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=897855http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=897772http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=287887http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=897772http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900547http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=297044http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900547http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=896544http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=276989http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=896544http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=898344http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307663http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=898344http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=898217http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=297712http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=898217http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=896939http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=276989http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=896939http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=897157http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=285304http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=897157http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900044http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=298621http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900044http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=896872http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=300590http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=896872http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=897235http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=284908http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=897235http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=897655http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=298003http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=897655http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900110http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=298621http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900110http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=898835http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=297712http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=898835http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900341http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=297712http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900341http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=896838http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=276989http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=896838http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=896817http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=297712http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=896817http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=899482http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=295399http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=899482http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900162http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=276989http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900162http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900161http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=276989http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900161http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901281http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=260969http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901281http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=899262http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=306330http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=899262http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=899630http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=284864http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=899630http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=791978http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=276190http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=791978http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=792036http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=279056http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=792036http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=791500http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=214409http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=791500http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790482http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=295512http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790482http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=792195http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=288815http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=792195http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=791826http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=272010http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=791826http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790813http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=19696http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790813http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790630http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=260560http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790630http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790729http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=278537http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790729http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790172http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=293161http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790172http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790194http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=280451http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790194http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=791029http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=241562http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=791029http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790691http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=268786http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790691http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790862http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=268789http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790862http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790669http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=284320http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790669http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790164http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=167042http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790164http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=791694http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=276989http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=791694http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=791037http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=241562http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=791037http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=791386http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=241562http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=791386http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790912http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=241562http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=790912http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=96501http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=195196http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=19530http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=143142http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=397http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=452http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=15621http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=1390http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=5029http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=18833http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=116495http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=259166http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=269195http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=17917http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=241562http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=39423http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=272685http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=98773http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=275662http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=193867http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=275662http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=291835http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=116495http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=127482http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=57588http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=238092http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=269642http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=244973http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=98773http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=269195http://shang.qq.com/wpa/qunwpa?idkey=89cc0b526cd16ab6cee4506996b3963ceb22f7c9007c8810572122c7c5d838a4http://jq.qq.com/?_wv=1027&amp;k=2IofhVVhttp://rs.xidian.edu.cn/home.php?mod=space&amp;uid=285032http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901435http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=268862http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901399http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=0http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901548http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=300782http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901458http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=285032http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901406http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=252309http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901467http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=295850http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901395http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=299876http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901464http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=217937http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901530http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=295399http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901544http://rs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=142http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901579http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901507http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901450http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901438http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901314http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901270http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901250http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901217http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901165http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901117http://rs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=554http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901564http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901562http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901547http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901543http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901540http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901530http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901503http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901496http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901485http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=901479http://rs.xidian.edu.cn/portal.php?mod=list&amp;catid=1http://rs.xidian.edu.cn/portal.php?mod=view&amp;aid=52http://rs.xidian.edu.cn/portal.php?mod=view&amp;aid=51http://rs.xidian.edu.cn/portal.php?mod=view&amp;aid=50http://rs.xidian.edu.cn/portal.php?mod=view&amp;aid=49http://rs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=115http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=900642&amp;from=portalhttp://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=897118&amp;from=portalhttp://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=895378&amp;from=portalhttp://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=893467&amp;from=portalhttp://rs.xidian.edu.cn/home.php?mod=space&amp;uid=311203http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=311203&amp;do=blog&amp;id=1900http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307289http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307289&amp;do=blog&amp;id=1898http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=310426http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=310426&amp;do=blog&amp;id=1897http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307289http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307289&amp;do=blog&amp;id=1896http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307331http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307331&amp;do=blog&amp;id=1894http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307289http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307289&amp;do=blog&amp;id=1893http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=308946http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=308946&amp;do=blog&amp;id=1891http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=305834http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=305834&amp;do=blog&amp;id=1890http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=287055http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=287055&amp;do=blog&amp;id=1889http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=291359http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=291359&amp;do=blog&amp;id=1888http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=309479http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=309479&amp;do=blog&amp;id=1885http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=310727http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=310727&amp;do=blog&amp;id=1881http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307541http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307541&amp;do=blog&amp;id=1878http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307289http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307289&amp;do=blog&amp;id=1893http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307541http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=307541&amp;do=blog&amp;id=1887http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=291359http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=291359&amp;do=blog&amp;id=1888http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=298067http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=298067&amp;do=blog&amp;id=1882http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=287055http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=287055&amp;do=blog&amp;id=1889http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=308946http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=308946&amp;do=blog&amp;id=1891http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=309134http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=309134&amp;do=blog&amp;id=1877http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=298086http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=298086&amp;do=blog&amp;id=1665http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=302366http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=302366&amp;do=blog&amp;id=1699http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=302489http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=302489&amp;do=blog&amp;id=1673http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=298086http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=298086&amp;do=blog&amp;id=1670http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=304068http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=304068&amp;do=blog&amp;id=1685http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=285379http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=285379&amp;do=blog&amp;id=1664http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=311126http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=311126&amp;do=blog&amp;id=1871http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=298086http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=298086&amp;do=blog&amp;id=1738http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=252175http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=252175&amp;do=blog&amp;id=1719http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=309479http://rs.xidian.edu.cn/home.php?mod=space&amp;uid=309479&amp;do=blog&amp;id=1857http://rs.xidian.edu.cn/forum.php?mod=misc&amp;action=showdarkroomhttp://weibo.com/xdrsbthttp://rs.xidian.edu.cn/data/attachment/forum/201411/20/131007gaghl2s997wxzhy8.jpghttp://rs.xidian.edu.cnhttp://www.discuz.nethttp://www.comsenz.com 采集整个网站爬取一个页面比较简单，但是如果需要系统地把整个网站按目录分类，或者要搜索网站上的每一个页面，怎么办？那就得采集整个网站，那是一种非常耗费内存资源的过程，尤其是处理大型网站时，最合适的工具就是用一个数据库来储存采集的资源。但是，我们可以掌握这类工具的行为，并不需要通过大规模地运行它们。 遍历整个网站的网络数据采集有许多好处。 生成网站地图 收集数据“ 5 个页面深度，每页 10 个链接”是网站的主流配置。为了避免一个页面被采集两次，链接去重是非常重要的。在代码运行时，把已发现的所有链接都放到一起，并保存在方便查询的列表里（下文示例指Python的集合set类型）。只有“新”链接才会被采集，之后再从页面中搜索其他链接： 1234567891011121314151617from urllib.request import urlopenfrom bs4 import BeautifulSoupimport repages = set()def getLinks(pageUrl): global pages html = urlopen("http://en.wikipedia.org"+pageUrl) bsObj = BeautifulSoup(html) for link in bsObj.findAll("a", href=re.compile("^(/wiki/)")): if 'href' in link.attrs: if link.attrs['href'] not in pages: # 我们遇到了新页面 newPage = link.attrs['href'] print(newPage) pages.add(newPage) getLinks(newPage)getLinks("") 采集睿思发现了一个新的公网地址 美滋滋123456789101112131415161718192021222324252627# -*-coding:utf-8-*-from urllib.request import urlopenfrom bs4 import BeautifulSoupclass Rspider: def Store(self): for i in range(10): pages = 'http://rsbbs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=72&amp;page='+str(i)+'&amp;mobile=2' html = urlopen(pages) bsObj = BeautifulSoup(html.read()) tiezi = bsObj.findAll("ul") for tiaos in tiezi: for tiao in tiaos.findAll('a'): for person in tiao.findAll('span', attrs=&#123;'class': "by"&#125;): print("发帖人： " + person.get_text().strip()) [s.extract() for s in tiao.findAll('span', attrs=&#123;'class': "by"&#125;)] print("帖子: "+tiao.get_text().strip())if __name__ == '__main__': RS = Rspider() RS.Store() 存入数据库1234567891011121314151617181920212223242526272829303132333435363738# -*-coding:utf-8-*-from urllib.request import urlopenfrom bs4 import BeautifulSoupimport csvimport pymysqlclass Rspider: def Store(self): connection = pymysql.connect(host='127.0.0.1', user='root', password='root', db='rs', charset='utf8', cursorclass=pymysql.cursors.DictCursor) cur = connection.cursor() cur.execute("USE rs") for i in range(10): pages = 'http://rsbbs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=72&amp;page='+str(i)+'&amp;mobile=2' html = urlopen(pages) bsObj = BeautifulSoup(html.read()) tiezi = bsObj.findAll("ul") for tiaos in tiezi: for tiao in tiaos.findAll('a'): for person in tiao.findAll('span', attrs=&#123;'class': "by"&#125;): T = person.get_text().strip() print("发帖人： " + person.get_text().strip()) [s.extract() for s in tiao.findAll('span', attrs=&#123;'class': "by"&#125;)] P = tiao.get_text().strip() print("帖子: "+tiao.get_text().strip()) cur.execute("INSERT INTO rstiezi (person,tiezi) VALUES (\"%s\",\"%s\")", (T, P)) cur.connection.commit()if __name__ == '__main__': RS = Rspider() RS.Store() 更新123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*-coding:utf-8-*-from urllib.request import urlopenfrom bs4 import BeautifulSoupimport csvimport pymysqlclass Rspider: def Store(self): connection = pymysql.connect(host='127.0.0.1', user='root', password='root', db='rs', charset='utf8', cursorclass=pymysql.cursors.DictCursor) cur = connection.cursor() cur.execute("USE rs") for i in range(1): pages = 'http://rsbbs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=72&amp;page='+str(i)+'&amp;mobile=2' html = urlopen(pages) bsObj = BeautifulSoup(html.read()) tiezi = bsObj.findAll("ul") for tiaos in tiezi: for tiao in tiaos.findAll('a'): for person in tiao.findAll('span', attrs=&#123;'class': "by"&#125;): T = person.get_text().strip() print("发帖人：" + person.get_text().strip()) [s.extract() for s in tiao.findAll('span', attrs=&#123;'class': "by"&#125;)] P = tiao.get_text().strip() print("标题: "+tiao.get_text().strip()) #get every tiao Likn if 'href' in tiao.attrs: tiao_links= "http://rsbbs.xidian.edu.cn/" + tiao.attrs['href'] tiao_html = urlopen(tiao_links) tiao_bsObj = BeautifulSoup(tiao_html.read()) # [q.extract() for q in tiao_bsObj.findAll('blockquote')] content = tiao_bsObj.findAll("div", &#123;"class": "message"&#125;)[0] R = content.get_text().strip() print("帖子内容: "+R) print('\n') #将发帖人、帖子标题、帖子内容插入数据库 cur.execute("INSERT INTO rstiezi (person,tiezi,content) VALUES (\"%s\",\"%s\",\"%s\")", (T, P, R)) cur.connection.commit()if __name__ == '__main__': RS = Rspider() RS.Store() 遇到异常、重复处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*-coding:utf-8-*-from urllib.request import urlopenfrom bs4 import BeautifulSoupimport csvimport pymysqlclass Rspider: def Store(self): connection = pymysql.connect(host='127.0.0.1', user='root', password='root', db='rs', charset='utf8', cursorclass=pymysql.cursors.DictCursor) cur = connection.cursor() cur.execute("USE rs") for i in range(3): pages = 'http://rsbbs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=72&amp;page='+str(i)+'&amp;mobile=2' html = urlopen(pages) bsObj = BeautifulSoup(html.read()) tiezi = bsObj.findAll("ul") for tiaos in tiezi: for tiao in tiaos.findAll('a'): for person in tiao.findAll('span', attrs=&#123;'class': "by"&#125;): T = person.get_text().strip() print("发帖人：" + person.get_text().strip()) [s.extract() for s in tiao.findAll('span', attrs=&#123;'class': "by"&#125;)] P = tiao.get_text().strip() print("标题: "+tiao.get_text().strip()) #get every tiao Likn if 'href' in tiao.attrs: tiao_links= "http://rsbbs.xidian.edu.cn/" + tiao.attrs['href'] tiao_html = urlopen(tiao_links) tiao_bsObj = BeautifulSoup(tiao_html.read()) # [q.extract() for q in tiao_bsObj.findAll('blockquote')] try: content = tiao_bsObj.findAll("div", &#123;"class": "message"&#125;)[0] R = content.get_text().strip() print("帖子内容: " + R) print('\n') finally: pass #将发帖人、帖子标题、帖子内容插入数据库 cur.execute("INSERT INTO rstiezi (person,tiezi,content) VALUES (\"%s\",\"%s\",\"%s\")", (T, P, R)) cur.connection.commit()if __name__ == '__main__': RS = Rspider() RS.Store() 1218备份1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# -*-coding:utf-8-*-from urllib.request import urlopenfrom bs4 import BeautifulSoupimport csvimport pymysqlclass Rspider: def Store(self): #链接数据库 connection = pymysql.connect(host='127.0.0.1', user='root', password='root', db='rs', charset='utf8', cursorclass=pymysql.cursors.DictCursor) cur = connection.cursor() cur.execute("USE rs") pageURL = set() for i in range(5): pages = 'http://rsbbs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=72&amp;page='+str(i)+'&amp;mobile=2' print(pages) if pages not in pageURL: html = urlopen(pages) bsObj = BeautifulSoup(html.read()) tiezi = bsObj.findAll("ul") for tiaos in tiezi: for tiao in tiaos.findAll('a'): for person in tiao.findAll('span', attrs=&#123;'class': "by"&#125;): T = person.get_text().strip() print("发帖人：" + person.get_text().strip()) [s.extract() for s in tiao.findAll('span', attrs=&#123;'class': "by"&#125;)] P = tiao.get_text().strip() print("标题: "+tiao.get_text().strip()) #get every tiao Likn if 'href' in tiao.attrs: tiao_links= "http://rsbbs.xidian.edu.cn/" + tiao.attrs['href'] tiao_html = urlopen(tiao_links) tiao_bsObj = BeautifulSoup(tiao_html.read()) # [q.extract() for q in tiao_bsObj.findAll('blockquote')] try: content = tiao_bsObj.findAll("div", &#123;"class": "message"&#125;)[0] R = content.get_text().strip() print("帖子内容: " + R) print('\n') finally: pass pageURL.add(pages) #将发帖人、帖子标题、帖子内容插入数据库 cur.execute("INSERT INTO rstiezi (person,tiezi,content) VALUES (\"%s\",\"%s\",\"%s\")", (T, P, R)) cur.connection.commit()if __name__ == '__main__': RS = Rspider() RS.Store() 灌水区and缘聚睿思终极版灌水区1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# -*-coding:utf-8-*-from urllib.request import urlopenfrom urllib import requestfrom bs4 import BeautifulSoupimport csvimport pymysqlimport time#导入包import urllib.requestclass Rspider: def Store(self): #链接数据库 connection = pymysql.connect(host='127.0.0.1', user='root', password='root', db='rs', charset='utf8', cursorclass=pymysql.cursors.DictCursor) cur = connection.cursor() cur.execute("USE rs") pageURL = set() for i in range(1,1000): pages = 'http://rsbbs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=72&amp;page='+str(i)+'&amp;mobile=2' print("【这是第"+str(i)+"页】"+pages) if pages not in pageURL: #header # url = r'http://rsbbs.xidian.edu.cn' headers = &#123; 'User-Agent': r'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) ' r'Chrome/45.0.2454.85 Safari/537.36 115Browser/6.0.3', 'Referer': r'http://rsbbs.xidian.edu.cn', 'Connection': 'keep-alive'&#125; req = request.Request(pages, headers=headers) html = request.urlopen(req) # html = urlopen(pages) bsObj = BeautifulSoup(html.read()) tiezi = bsObj.findAll("ul") for tiaos in tiezi: for tiao in tiaos.findAll('a'): for person in tiao.findAll('span', attrs=&#123;'class': "by"&#125;): T = person.get_text().strip() print("发帖人：" + person.get_text().strip()) [s.extract() for s in tiao.findAll('span', attrs=&#123;'class': "by"&#125;)] P = tiao.get_text().strip() print("标题: "+tiao.get_text().strip()) #get every tiao Likn if 'href' in tiao.attrs: try: tiao_links = "http://rsbbs.xidian.edu.cn/" + tiao.attrs['href'] tiao_html = urlopen(tiao_links) tiao_bsObj = BeautifulSoup(tiao_html.read()) # [q.extract() for q in tiao_bsObj.findAll('blockquote')] content = tiao_bsObj.findAll("div", &#123;"class": "message"&#125;)[0] R = content.get_text().strip() print("帖子内容: " + R) print('\n') except (ValueError, IndexError) as e: pass pageURL.add(pages) #将发帖人、帖子标题、帖子内容插入数据库 cur.execute("INSERT INTO rstiezi (person,tiezi,content) VALUES (\"%s\",\"%s\",\"%s\")", (T, P, R)) cur.connection.commit() time.sleep(3) # 设置时间间隔为3秒if __name__ == '__main__': RS = Rspider() RS.Store()板块：西电睿思灌水专区时间段： 2017-12-18~2016-10-7 有效帖子数：24940 缘聚睿思123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# -*-coding:utf-8-*-from urllib.request import urlopenfrom urllib import requestfrom bs4 import BeautifulSoupimport csvimport pymysqlimport time#导入包import urllib.requestclass Rspider: def Store(self): #链接数据库 connection = pymysql.connect(host='127.0.0.1', user='root', password='root', db='rs', charset='utf8', cursorclass=pymysql.cursors.DictCursor) cur = connection.cursor() cur.execute("USE rs") pageURL = set() for i in range(1,122): pages = 'http://rsbbs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=217&amp;page='+str(i)+'&amp;mobile=2' print("【这是第"+str(i)+"页】"+pages) if pages not in pageURL: headers = &#123; 'User-Agent': r'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) ' r'Chrome/45.0.2454.85 Safari/537.36 115Browser/6.0.3', 'Referer': r'http://rsbbs.xidian.edu.cn', 'Connection': 'keep-alive'&#125; req = request.Request(pages, headers=headers) html = request.urlopen(req) bsObj = BeautifulSoup(html.read()) tiezi = bsObj.findAll("ul") for tiaos in tiezi: for tiao in tiaos.findAll('a'): for person in tiao.findAll('span', attrs=&#123;'class': "by"&#125;): X = person.get_text().strip() # print("发帖人：" + person.get_text().strip()) print("发帖人：" + X) [s.extract() for s in tiao.findAll('span', attrs=&#123;'class': "by"&#125;)] Y = tiao.get_text().strip() print("标题: "+tiao.get_text().strip()) #get every tiao Likn if 'href' in tiao.attrs: try: tiao_links = "http://rsbbs.xidian.edu.cn/" + tiao.attrs['href'] tiao_html = urlopen(tiao_links) tiao_bsObj = BeautifulSoup(tiao_html.read()) content = tiao_bsObj.findAll("div", &#123;"class": "message"&#125;)[0] Z = content.get_text().strip() print("帖子内容: " + Z) print('\n') cur.execute("INSERT INTO love (person,tiezi,content) VALUES (\"%s\",\"%s\",\"%s\")", (X, Y, Z)) cur.connection.commit() except (ValueError, IndexError) as e: pass pageURL.add(pages) #将发帖人、帖子标题、帖子内容插入数据库 # cur.execute("INSERT INTO love (person,tiezi,content) VALUES (\"%s\",\"%s\",\"%s\")", (X, Y, Z)) # cur.execute("INSERT INTO love (person,tiezi,content) VALUES (\"%s\",\"%s\",\"%s\")", (X, Y, Z)) # cur.connection.commit() time.sleep(3) # 设置时间间隔为3秒if __name__ == '__main__': RS = Rspider() RS.Store()板块：相聚睿思时间段： 2017-12-19~2010-11-24 有效帖子数：2618]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动终端比赛之旅]]></title>
    <url>%2F2017%2F12%2F04%2F%E7%A7%BB%E5%8A%A8%E7%BB%88%E7%AB%AF%E6%AF%94%E8%B5%9B%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[轮子哥说他都是用编译的时间来刷微博，那我也不知羞耻的（不想学习）来更博。 敲代码的水平没有增长多少，PS和做视频的本事倒是提高了不少。 快铃PPT 快铃宣传视频 谈谈这次的全国移动终端的比赛吧。 一一个偶然的机会加入工作室，从还没开始学Python就直接上手爬虫。最深的体会就是，结果导向的驱动真的最有用。看了一万本书可能真的不如亲手去操作一番。开始学Python，了解协议，抓包，去学HTML，去学数据库。我都不敢相信我本科四年搞硬件的。整个流程走下来，好像是真的有学习到很多。但是还是差很远，现在也是。从不认为自己牛逼，敬畏一切可敬畏的。 二后面就是多花时间去尝试，去调代码，从一开始的不知道写什么，到后来去想能不能用好一点的算法去实现。感谢团队的力量，代码写到半夜也是有的。这是一段很难忘的经历。去明白、去了解一个产品从无到有的流程。 三先是准备校内赛。我还记得我第一次做的PPT，和第一次预演答辩的样子。磕磕绊绊，简直尴尬到死。还在背答辩的稿子。整个过程也是极度的不自信。 后来进入决赛，指导老师每周一次的答辩演练。我的PPT也开始不是以版本来命名，而是以日期来命名，每天都会出一个新的版本。 四去了大连理工，还是非常见了世面的。有敬畏之心是对的。总有人比你准备的更充分，东西比你做的更好。这些差距不是没有的。 还好算是发挥出自己最好的状态，整个答辩环节也算是十分自信不磕绊，感觉人只要自信了，问题就会解决掉一半。 五Say Little, Do Much.做自己想做的，最纯粹的。最后，感谢队友。 很享受这次角色的转变 表达自我很重要 也是这一年多来成长最多的虽然没有摆脱千年二等的怪圈 不过这次真的离一只差2.8分 不遗憾感谢给力的队友 指导老师和Holi团队不求凛冬的暮色天光 只乞胸前的微束心火]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Python的微信好友分析]]></title>
    <url>%2F2017%2F10%2F23%2FPython%E5%BE%AE%E4%BF%A1%E5%A5%BD%E5%8F%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[“如果我比别人看得远,那是因为我站在巨人的肩膀上”–不知道牛顿说了没本文利用Python3的itchat包简单的分析了一下自己的微信好友。 itchatitchat itchat是一个开源的微信个人号接口，使用python调用微信从未如此简单。使用不到三十行的代码，你就可以完成一个能够处理所有信息的微信机器人。当然，该api的使用远不止一个机器人，更多的功能等着你来发现，比如这些。该接口与公众号接口itchatmp共享类似的操作方式，学习一次掌握两个工具。如今微信已经成为了个人社交的很大一部分，希望这个项目能够帮助你扩展你的个人的微信号、方便自己的生活。 运行环境本文采用Python3，然后顺便吐槽下Python的向后不兼容真的好烦好烦，真的是体验超差。当然为了解决这个不是问题的小问题，我装了两个运行环境，毕竟是要站在巨人肩膀上去瞭望远方，那就站在两个肩膀上好了。sublime的Python3和2的配置（点进去往下翻。。。） =_+关于Pycharm里面Py2和Py3的转换更是简单，百度一下就ok。转换如下： 准备需要安装itchat、matplotlib、numpy等依赖。老生常谈之安装方式：1234pip install itchatpip install matplotlibpip install numpypip install PIL/Pillow 注意：是不是上面的命令我早都忘了（我此时此刻觉得应该是这样的!），所以。。你们自己看着安装吧，反正不出问题都感觉不正常。按照使用的Python运行环境来安装相应的依赖包。pip/pip3 安装包介绍itchat本文的主角，我给它起个slogan吧“不仅仅是微信机器人。” MatplotlibMatplotlib是Python的可视化包。 Matplotlib是Python中最常用的可视化工具之一，可以非常方便地创建海量类型地2D图表和一些基本的3D图表。Matplotlib最早是为了可视化癫痫病人的脑皮层电图相关的信号而研发，因为在函数的设计上参考了MATLAB，所以叫做Matplotlib。Matplotlib首次发表于2007年，在开源和社区的推动下，现在在基于Python的各个科学计算领域都得到了广泛应用。Matplotlib的原作者John D. Hunter博士是一名神经生物学家，2012年不幸因癌症去世，感谢他创建了这样一个伟大的库。 numpyNumpy是Python的科学计算包。 numpy(Numerical Python extensions)是一个第三方的Python包，用于科学计算。这个库的前身是1995年就开始开发的一个用于数组运算的库。经过了长时间的发展，基本上成了绝大部分Python科学计算的基础包，当然也包括所有提供Python接口的深度学习框架。 关于Matplotlib和numpy，推荐知乎上的一篇文章，感觉不错：给深度学习入门者的Python快速教程 - numpy和Matplotlib篇 PIL/PillowPIL:Python Imaging Library，已经是Python平台事实上的图像处理标准库了。Pillow 是 PIL的对Python3支持的另外一个分支，当然他对Python2也兼容，由于PIL安装起来比较烦，而使用pip可以很轻松的安装Pillow，所以我选择Pillow使用，但是其核心还是PIL库的。 开始 好了，奠基石和肩膀都已经准备好了，上车！ 12345678910111213141516 #-*-coding:utf-8-*-import itchatimport reimport osimport matplotlib as mplfrom matplotlib import pyplot as pltimport numpy as npimport PIL.Image as Imagefrom os import listdirimport mathplt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号zhfont = mpl.font_manager.FontProperties(fname='E:\PythonWorkSpace\WeChat\msyh.ttf', size=14) 有时候不得不说说外国的月亮比较圆啊。使用的Matplotlib绘图是不能显示中文字符的，需要做一点小设置。这两句：12plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号 这一句为指定字体的设置：1zhfont = mpl.font_manager.FontProperties(fname='E:\PythonWorkSpace\WeChat\msyh.ttf', size=14) 关于上面的xx.tff为c盘windows下front字体包里的字体，我拷到目录下面了。这样，我们就可以好好编程了+_+ ，想编个程序心也是蛮累的，不是在配置环境的路上，就是在改bug的路上，奈何程序员都是打不死的小强！ 登录 爬取目标网站的时候，看看有没有 HTML样式更友好的移动版（把自己的请求头设置成处于移动设备的状态，然后接收网站移动版。移动版是一个获取数据非常好的渠道。当有一个网页很难爬去的时候，应该去试试它的移动版。） 微信就已经是移动设备上的了，腾讯粑粑又没有开发微信的API，所以我们只能另辟蹊径！反向思维-&gt;Web端有木有！This is itChat! 使用itchat登录Web端的微信，代码很简单：1itchat.auto_login(hotReload=True) 注： 传入True hotReload使得程序关闭后一定时间内也可以登录，该方法会生一个静态文件itchat.pkl，用于存储登陆的状态。即使程序关闭，一定时间内重新开启也可以不用重新扫码。 执行上面这句代码后会弹出一个Web微信登录的二维码QR，拿手机微信扫一扫后有以下显示：这样就登录成功了！好简单有木有！用大神的包就是好，自己写模拟登陆的话还得抓包，分析报头，然后模拟登录。itchat简直良心到想哭。&gt;_&lt; 获取好友信息12friends = itchat.get_friends(update=True) # 爬取好友的相关信息，返回json文件 上面这个json文件就包括了微信好友的信息。 好友性别直接上代码:123456789101112131415161718def friend_analysis(friends): labels = ['男', '女', '其他'] data = [0, 0, 0] # friends[0] 是自己的信息 for friend in friends[1:]: sex = friend["Sex"] if sex == 1: data[0] += 1 elif sex == 2: data[1] += 1 else: data[2] += 1 fig = plt.figure() plt.pie(data, labels=labels,autopct="%.2f%%") plt.title("微信好友分析",fontsize=18,fontproperties=zhfont) plt.show() labels是我们要画的饼图的标注。男、女和其他性别的提取很简单了，当然需要注意的是如果没有我们准备阶段对于Matplotlib绘图的中文字符的处理，画出来的图是显示不了汉字滴！运行结果： 看来我的微信好友男女差不多是1:1吧，还有那5.31%不知性别的好友，他们可能对性别的要求并不是那么严格吧，毕竟人与人也没那么多的隔阂是不是 =_* 区域分析关于这个，自己之前写了一个简单的省份分析，就是从friends里去匹配Province，但是画的太丑了。所以，又找到一个肩膀12345678910111213141516171819202122232425262728293031# extract the variables: NickName, Sex, City, Province, Signaturedef get_features(friends): features = [] for friend in friends: feature = &#123;'NickName': friend['NickName'], 'Sex': friend['Sex'], 'City': friend['City'], 'Province': friend['Province'], 'Signature': friend['Signature']&#125; features.append(feature) return pd.DataFrame(features)features = get_features(friends[1:])print(features.columns)features.head()locations = features.loc[:, ['Province', 'City']] # get location columnslocations = locations[locations['Province'] != ''] # clean empty city or province recordsdata = locations.groupby(['Province', 'City']).size().unstack() # group by and countcount_subset = data.take(data.sum(1).argsort())[-20:] # obtain the 20 highest data# plotsubset_plot = count_subset.plot(kind='bar', stacked=True, figsize=(24, 24))# set fontsxtick_labels = subset_plot.get_xticklabels()for label in xtick_labels: label.set_fontproperties(font)legend_labels = subset_plot.legend().textsfor label in legend_labels: label.set_fontproperties(font) label.set_fontsize(10)plt.xlabel('Province', fontsize=20)plt.ylabel('Number', fontsize=20)plt.show() 上面这段代码更是厉害，提取了昵称,性别, 城市, 省份, 签名。我只用他的省市画图部分locations，结果如下；emmmm,放不大了，全图看不到，而且放大拖动起来巨卡，这个图也是辛苦了i3了。从上面可以看到，我大陕西的乡党们在哪里！！我大西安的乡党们在哪里!!排名第二、三的北京和广东，就是那群在北（上？）广深那一波人吧，向他们致敬！从排名第四开始，某种程度上可以说是在陕西的各省学霸的分布了吧！尤其是河北、河南、山东！这些省份的同学一直都是学神一样的存在，陕西欢迎你们，学生生涯请轻虐+_+ 签名1234567def signature_analysis(friends): signature_list = list() for friend in friends[1:]: signature = friend['Signature'].strip() signature_list.append(signature) print(friend['NickName'] + "\t" + signature) 这是从friends中分析出好友签名的，.strip()是用来删除空白符。最后的输出是打印出昵称+签名。这个比较隐私就不展示了哈。有时间的还可以整理下这些签名，使用jieba分词+Wordcloud云词生成一个图片。 获取好友头像123456789101112131415161718192021222324252627282930313233343536def getImage(friends): #下载所有好友的头像图片 num = 0 for i in friends: img = itchat.get_head_img(i["UserName"]) with open('./headImg/' + str(num) + ".png",'wb') as f: f.write(img) f.close() num += 1 #获取文件夹内的文件个数 length = len(os.listdir('./headImg')) #根据总面积求每一个的大小 each_size = int(math.sqrt(float(810*810)/length)) #每一行可以放多少个 lines = int(810/each_size) #生成白色背景新图片 image = Image.new('RGBA', (810, 810),'white') x = 0 y = 0 for i in range(0,length): try: img = Image.open('./headImg/' + str(i) + ".png") except IOError: print(i) print("Error") else: img = img.resize((each_size, each_size), Image.ANTIALIAS) #resize image with high-quality image.paste(img, (x * each_size, y * each_size)) x += 1 if x == lines: x = 0 y += 1 image.save('./headImg/' + "all.png") #通过文件传输助手发送到自己微信中 itchat.send_image('./headImg/' + "all.png",'filehelper') image.show() 注释里写的应该算很清楚，需要注意的是：开始想截取好友头像图片遇到了一个报错：1cannot write mode rgba as jpg google后如下: 这是因为，JPG只有三个通道，而程序中一定用到了RGBA四个通道，所以程序不知道多出来的一个通道怎么处理，就会报错了。 解决如下: PNG图像有RGBA四个通道，而BMP和JPG图像只有RGB三个通道，所以我们可以将程序中所有图片的保存形式改为PNG.(本文采用的是这种方法。) 不想改变图片格式，就添加判断，进行转换 1234if len(toImage.split())==4: r,g,b,a=toImage.split() #利用split和merge将通道从四个转换为三个 toImage=Image.merge("RGB",(r,g,b)) toImage.save(user + ".jpg") “全世界的程序员们联合起来，那些bug的坑我们填一个它就少一个！”结果：来来来，找自己，找到三个自己就可以Bingo了… 最后，人生苦短，且行且珍惜强烈建议仅使用小号（小号怎么会有好友？反正我给你们建议了…日后可不要搞个大新闻把我批判一番）小道消息：从近期 (17年6月下旬)反馈来看，使用itchat及其他微信机器人（类爬虫程序）存在一定概率被限制登录的可能性。主要表现为无法登陆 Web 微信 (但不影响手机等其他平台)。现在感觉都是爬一次少一次，Web微信有时候也登不上去+_+，前几天还被封号两天，微信消息只能看，不能回复，朋友圈不能评论，不能点赞，这对一个话痨来说简直就是无声的摧残！ 最后的最后：反思微信是不是太强大了，生活、学习、工作中真的是一分一秒都离不开！所以，还是建议大家时不时的用下QQ，用下微博，多和新老好友们尬聊下，不然，真到了微信垄断那一天，你我联系只能靠漂流瓶了！全看缘分！ 后记一晚上的访问量破三百了！三百！1024程序员节日快乐！盖个戳！本文的访问数据，google analytics：访问数据：访问者国家和地区：地理位置： 访问者城市分布：服务提供商：网页浏览分析：访问者行为流：]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV学习笔记（Python）]]></title>
    <url>%2F2017%2F10%2F17%2FOpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Python%EF%BC%89-1%2F</url>
    <content type="text"><![CDATA[一 OpenCV中的GUI特性图片读入图像使用函数 cv2.imread() 读入图像。 cv2.IMREAD_COLOR：读入一副彩色图像。图像的透明度会被忽略，这是默认参数。 cv2.IMREAD_GRAYSCALE：以灰度模式读入图像 cv2.IMREAD_UNCHANGED：读入一幅图像，并且包括图像的 alpha 通道 123456# -*- coding: utf-8 -*-import numpy as npimport cv2# Load an color image in grayscaleimg = cv2.imread('messi5.jpg',0) 警告： 就算图像的路径是错的， OpenCV 也不会提醒你的，但是当你使用命令print img时得到的结果是None。 显示图像使用函数 cv2.imshow() 显示图像。窗口会自动调整为图像大小。第一个参数是窗口的名字，其次才是我们的图像。123cv2.imshow('image',img)cv2.waitKey(0)cv2.destroyAllWindows() cv2.waitKey() 是一个键盘绑定函数。需要指出的是它的时间尺度是毫秒级。函数等待特定的几毫秒，看是否有键盘输入。特定的几毫秒之内，如果按下任意键，这个函数会返回按键的 ASCII 码值，程序将会继续运行。如果没有键盘输入，返回值为-1，如果我们设置这个函数的参数为0，那它将会无限期的等待键盘输入。它也可以被用来检测特定键是否被按下，例如按键 a 是否被按下。 cv2.destroyAllWindows() 可以轻易删除任何建立的窗口。如果想删除特定的窗口可以使用 cv2.destroyWindow()，在括号内输入你想删除的窗口名。 建议：一种特殊的情况是，也可以先创建一个窗口，之后再加载图像。这种情况下，可以决定窗口是否可以调整大小。使用到的函数cv2.namedWindow()。初始设定函数标签是cv2.WINDOW_AUTOSIZE。但是如果把标签改成cv2.WINDOW_NORMAL，就可以调整窗口大小了。当图像维度太大，或者要添加轨迹条时，调整窗口大小将会很有用.1234567import numpy as npimport cv2cv2.namedWindow('image', cv2.WINDOW_NORMAL)cv2.imshow('image',img)cv2.waitKey(0)cv2.destroyAllWindows() 保存图像使用函数 cv2.imwrite() 来保存一个图像。首先需要一个文件名，之后才是要保存的图像。1cv2.imwrite('messigray.png',img) 下面的程序将会加载一个灰度图， 显示图片，按下’s’键保存后退出，或者按下 ESC 键退出不保存。 1234567891011import numpy as npimport cv2img = cv2.imread('messi5.jpg',0)cv2.imshow('image',img)k = ccv2.waitKey(0)&amp;0xFFif k == 27: # wait for ESC key to exit cv2.destroyAllWindows()elif k == ord('s'): # wait for 's' key to save and exit cv2.imwrite('messigray.png',img) cv2.destroyAllWindows() 警告： 如果用的是 32 位系统，需要将 k = cv2.waitKey(0)&amp;0xFF 这行改成k = cv2.waitKey(0)。 使用MatplotlibMatplotib 是 python 的一个绘图库，里头有各种各样的绘图方法。 12345678# -*- coding: utf-8 -*- import numpy as np import cv2 from matplotlib import pyplot as plt img = cv2.imread（'messi5.jpg',0）plt.imshow(img,cmap = 'gray',interpolation = 'bicubic')plt.xticks([]), plt.yticks([])plt.show() 视频用摄像头捕获视频OpenCV提供了一个非常简单的接口。123456789101112131415161718#-*-coding:utf-8-*-import numpy as np import cv2 cap = cv2.VideoCapture(0)while(True): #捕获帧 ret,frame = cap.read() #对帧进行操作 gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY) #展示结果 cv2.imshow('frame',gray) if cv2.waitKey(1)&amp;0xFF == ord('q'): break #当所有操作都已完成，停止捕获视频 cap.release()cv2.destroyAllWindows() cap.read()返回一个布尔值。可以使用函数cap.get(propID)来获得视频的一些参数信息。cap.set(propID,value)可以来修改其中的一些值。例如:使用cap.get(3)和cap.get(4)来查看每一帧的宽和高。默认是640X480。但是可以使用ret = cap.set(3,320)和ret = cap.set(4,240)来把宽和高改成320X240。 从文件中播放视频1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-import numpy as npimport cv2cap = cv2.VideoCapture(0)# Define the codec and create VideoWriter objectfourcc = cv2.VideoWriter_fourcc(*'XVID')out = cv2.VideoWriter('output.avi',fourcc, 20.0, (640,480))while(cap.isOpened()): ret, frame = cap.read() if ret==True: frame = cv2.flip(frame,0) # write the flipped frame out.write(frame) cv2.imshow('frame',frame) if cv2.waitKey(1) &amp; 0xFF == ord('q'): break else: break# Release everything if job is finishedcap.release()out.release()3cv2.destroyAllWindows() 注意： 你应该确保你已经装了合适版本的 ffmpeg 或者gstreamer。如果你装错了那就比较头疼了。 保存视频对于图片来时很简单只需要使用 cv2.imwrite()。但对于视频来说就要多做点工作。要创建一个 VideoWriter的对象。确定一个输出文件的名字。接下来指定FourCC编码。播放频率和帧的大小也都需要确定。最后一个是 isColor 标签。FourCC码以下面的格式传给程序，以MJPG为例：cv2.cv.FOURCC(‘M’,’J’,’P’,’G’)或者cv2.cv.FOURCC(*’MJPG’)。 下面的代码是从摄像头中捕获视频，沿水平方向旋转每一帧并保存它。123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-import numpy as npimport cv2cap = cv2.VideoCapture(0)# 定义编码格式 创建写入视频类fourcc = cv2.cv.FOURCC(*'XVID')out = cv2.VideoWriter('output.avi',fourcc, 20.0, (640,480))while(cap.isOpened()): ret, frame = cap.read() if ret==True: frame = cv2.flip(frame,0) # 写入 out.write(frame) cv2.imshow('frame',frame) if cv2.waitKey(1) &amp; 0xFF == ord('q'): break else: break# Release everything if job is finishedcap.release()out.release()cv2.destroyAllWindows() OpenCV中的绘图函数需要设置的参数：• img：你想要绘制图形的那幅图像。• color：形状的颜色。以RGB 为例，需要传入一个元组，例如：（255,0,0）代表蓝色。对于灰度图只需要传入灰度值。• thickness：线条的粗细。如果给一个闭合图形设置为-1，那么这个图形就会被填充。默认值是1.• linetype：线条的类型，8 连接，抗锯齿等。默认情况是 8 连接。cv2.LINE_AA为抗锯齿，这样看起来会非常平滑。 画线要画一条线只需要告诉画这条线的起点和终点。12345678import numpy as npimport cv2img=np.zeros((512,512,3), np.uint8)# Draw a diagonal blue line with thickness of 5 pxcv2.line(img,(0,0),(511,511),(255,0,0),5) 画矩形需要矩形的左上角顶点和右下角顶点坐标。1cv2.rectangle(img,(384,0),(510,128),(0,255,0),3) 画圆指定圆形的中心坐标和半径大小。1cv2.circle(img,(447,63), 63, (0,0,255), -1) 画椭圆画椭圆比较复杂，要多输入几个参数。一个参数是中心点的位置坐标。下一个参数是长轴和短轴的长度。椭圆沿逆时针方向旋转的角度。椭圆弧演顺时针方向起始的角度和结束角度，如果是0和360，就是整个椭圆。查看cv2.ellipse()可以得到更多信息。下面的例子是在图片的中心绘制半个椭圆。1cv2.ellipse(img,(256,256),(100,50),0,0,180,255,-1) 画多边形画多边形，需要指出每个顶点的坐标。用这些点的坐标构建一个大小等于行数 X1X2 的数组，行数就是点的数目。这个数组的数据类型必须为int32。这里画一个黄色的具有四个顶点的多边形。123pts=np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)pts=pts.reshape((-1,1,2))# 这里 reshape 的第一个参数为-1, 表明这一维的长度是根据后面的维度的计算出来的。 注意： 如果第三个参数是 False，我们得到的多边形是不闭合的（首尾不相连）。注意： cv2.polylines() 可以被用来画很多条线。 只需要把想要画的线放在一个列表中，将这个列表传给函数就可以了。每条线都会被独立绘制。这会比用cv2.line() 一条一条的绘制要快一些。 在图片上添加文字要在图片上绘制文字，需要设置下列参数：• 要绘制的文字• 要绘制的位置• 字体类型（通过查看 cv2.putText() 的文档找到支持的字体）• 字体的大小• 文字的一般属性如颜色，粗细，线条的类型等。为了更好看一点推荐使用linetype=cv2.LINE_AA。 在图像上绘制白色的 OpenCV。12font=cv2.FONT_HERSHEY_SIMPLEXcv2.putText(img,'OpenCV',(10,500), font, 4,(255,255,255),2) 警告：所有的绘图函数的返回值都是None，所以不能使用img=cv2.line(img,(0,0),(511,511),(255,0,0),5)。 结果下面就是最终结果了，通过你前面几节学到的知识把他显示出来吧。12345winname = 'example'cv2.namedWindow(winname)cv2.imshow(winname, img)cv2.waitKey(0)cv2.destroyWindow(winname) 完整代码如下：123456789101112131415161718#-*-coding:utf-8-*-import numpy as npimport cv2img=np.zeros((512,512,3), np.uint8)# Draw a diagonal blue line with thickness of 5 pxcv2.line(img,(0,0),(511,511),(255,0,0),5)cv2.rectangle(img,(384,0),(510,128),(0,255,0),3)cv2.circle(img,(447,63), 63, (0,0,255), -1)cv2.ellipse(img,(256,256),(100,50),0,0,180,255,-1)pts=np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)pts=pts.reshape((-1,1,2))font=cv2.FONT_HERSHEY_SIMPLEXcv2.putText(img,'OpenCV',(10,500), font, 4,(255,255,255),2)winname = 'example'cv2.namedWindow(winname)cv2.imshow(winname, img)cv2.waitKey(0)cv2.destroyWindow(winname) 把鼠标当画笔将要学习的函数是：cv2.setMouseCallback() 简单演示创建一个简单的程序，会在图片上双击过的位置绘制一个圆圈。首先来创建一个鼠标事件回调函数，但鼠标事件发生就会被执行。鼠标事件可以是鼠标上的任何动作，比如左键按下，左键松开，左键双击等。可以通过鼠标事件获得与鼠标对应的图片上的坐标。根据这些信息可以做任何想做的事。可以通过执行下列代码查看所有被支持的鼠标事件。鼠标事件回调函数只用做一件事：在双击过的地方绘制一个圆圈。下面是代码，不懂的地方可以看看注释。123456789101112131415import cv2import numpy as np#mouse callback functiondef draw_circle(event,x,y,flags,param): if event==cv2.EVENT_LBUTTONDBLCLK: cv2.circle(img,(x,y),100,(0,0,255),-1)# 创建图像与窗口并将窗口与回调函数绑定img=np.zeros((512,512,3),np.uint8)cv2.namedWindow('image')cv2.setMouseCallback('image',draw_circle)while(1): cv2.imshow('image',img) if cv2.waitKey(20)&amp;0xFF==27: breakcv2.destroyAllWindows() 结果: 高级一点的示例现在来创建一个更好的程序。这次的程序要完成的任务是根据选择的模式在拖动鼠标时绘制矩形或者是圆圈（就像画图程序中一样）。所以回调函数包含两部分，一部分画矩形，一部分画圆圈。这是一个典型的例子可以更好理解与构建人机交互式程序，比如物体跟踪，图像分割等。123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-import cv2import numpy as np# 当鼠标按下时变为 Truedrawing=False# 如果 mode 为 true 绘制矩形。按下'm' 变成绘制曲线。mode=Trueix,iy=-1,-1# 创建回调函数def draw_circle(event,x,y,flags,param): global ix,iy,drawing,mode # 当按下左键是返回起始位置坐标 if event==cv2.EVENT_LBUTTONDOWN: drawing=True ix,iy=x,y # 当鼠标左键按下并移动是绘制图形。 event 可以查看移动， flag 查看是否按下 elif event==cv2.EVENT_MOUSEMOVE and flags==cv2.EVENT_FLAG_LBUTTON: if drawing==True: if mode==True: cv2.rectangle(img,(ix,iy),(x,y),(0,255,0),-1) else: # 绘制圆圈，小圆点连在一起就成了线， 3 代表了笔画的粗细 cv2.circle(img,(x,y),3,(0,0,255),-1) # 下面注释掉的代码是起始点为圆心，起点到终点为半径的 # r=int(np.sqrt((x-ix)**2+(y-iy)**2)) # cv2.circle(img,(x,y),r,(0,0,255),-1) # 当鼠标松开停止绘画。 elif event==cv2.EVENT_LBUTTONUP: drawing==Falseimg=np.zeros((512,512,3),np.uint8)cv2.namedWindow('image')cv2.setMouseCallback('image',draw_circle)while(1): cv2.imshow('image',img) k=cv2.waitKey(1)&amp;0xFF if k==ord('m'): mode=not mode elif k==27: break 结果： 用滑动条做调色板• 把滑动条绑定到 OpenCV 的窗口• 学习这些函数：cv2.getTrackbarPos()，cv2.creatTrackbar()等。 代码示例创建一个简单的程序：通过调节滑动条来设定画板颜色。要创建一个窗口来显示显色，还有三个滑动条来设置B，G，R的颜色。当滑动滚动条是窗口的颜色也会发生相应改变。默认情况下窗口的起始颜色为黑。 cv2.getTrackbarPos()函数的一个参数是滑动条的名字，第二个参数是滑动条被放置窗口的名字，第三个参数是滑动条的默认位置。第四个参数是滑动条的最大值，第五个函数是回调函数，每次滑动条的滑动都会调用回调函数。回调函数通常都会含有一个默认参数，就是滑动条的位置。在本例中这个函数不用做任何事情，只需要 pass 就可以了。 滑动条的另外一个重要应用就是用作转换按钮。默认情况下 OpenCV 本身不带有按钮函数。所以使用滑动条来代替。在程序中，要创建一个转换按钮，只有当装换按钮指向 ON 时，滑动条的滑动才有用，否则窗户口都是黑的。12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-import cv2import numpy as npdef nothing(x):pass# 创建一副黑色图像img=np.zeros((300,512,3),np.uint8)cv2.namedWindow('image')cv2.createTrackbar('R','image',0,255,nothing)cv2.createTrackbar('G','image',0,255,nothing)cv2.createTrackbar('B','image',0,255,nothing)switch='0:OFF\n1:ON'cv2.createTrackbar(switch,'image',0,1,nothing)while(1):cv2.imshow('image',img)k=cv2.waitKey(1)&amp;0xFFif k==27:breakr=cv2.getTrackbarPos('R','image')g=cv2.getTrackbarPos('G','image')b=cv2.getTrackbarPos('B','image')s=cv2.getTrackbarPos(switch,'image')if s==0:img[:]=0else:img[:]=[b,g,r]cv2.destroyAllWindows() 附录：数字图像处理基础知识数字图像处理基础知识]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MOOC】Python网络爬虫与信息提取]]></title>
    <url>%2F2017%2F10%2F15%2FPython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%2F</url>
    <content type="text"><![CDATA[Python网络爬虫与信息提取-北京理工大学-嵩天发布大学：北京理工大学发布课程：Python网络爬虫与信息提取授课老师：嵩天课程简介：“The website is the API.”网络爬虫逐渐成为自动获取网络信息的主要形式还等什么？快写个爬虫探索世界吧！ 单元1：Requests库入门Request库的安装win + R,pip install requests Requests库的7个主要方法 requests.request() 构造一个请求，支撑以下各方法的基础方法 requests.get() 获取HTML网页的主要方法，对应于HTTP的GET requests.head 获取HTML网页头信息的方法，对应于HTTP的HEAD requests.post 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put() 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch() 向HTML网页提交局部修改请求，对应于HTTP的PATCH requests.delete（） 向HTML页面提交删除请求，对应于HTTP的DELETE requests.get()r = requests.get(url) 获得一个网页最简单的方法r = requests.get(url)完整的使用方法：r = requests.get(url,params=None,kwargs)url:拟获取页面的URL链接params: URL中的额外参数、字典或字节流格式，可选 kwargs:12个控制访问的参数根据源代码可知，Requests库的7个主要方法,后面6个都是调用requests.request()来实现的 requests库的2个重要对象 Response对象的属性 r.status_code:HTTP请求的返回状态，200表示连接成功，404表示失败 r.text:HTTP响应内容的字符串形式，即URL对应的页面内容 r.encoding：从HTTP header中猜测的响应内容编码方式 r.apparent_encoding:从内容中分析出响应内容编码方式（备选编码方式） r.content:HTTP响应内容的二进制形式 基本流程： 理解Response的编码r.encoding:从HTTP header中猜测的响应内容编码形式r.apparent_encoding：从内容中分析出的响应内容编码方式（备选编码方式） requests库的主要解析方法 requests的13个访问控制参数requests.request(method,url,**kwargs) **kwargs:控制访问的参数，均为可选项params：字典或字节序列，作为参数增加到URL中 例子：1234kv = &#123;'key1':'value1','key2':'value2'&#125;r = requests.request('get','http://python123.io/ws,params=kv')print(r.url) 结果:http://python123.io/ws?key1=value1&amp;key2=value2 通过改方法可以把一些键值对增加到URL中。服务器可以根据此去筛选一些资源。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西安西安]]></title>
    <url>%2F2017%2F09%2F26%2F%E8%A5%BF%E5%AE%89%E8%A5%BF%E5%AE%89%2F</url>
    <content type="text"><![CDATA[数次我站在钟鼓楼下听不到钟鼓奏响无数次我走在雁翔路上看不见大雁飞翔 突然想到今年是2017，马上2018小时候我们还写半命题作文：十年后的XX而今，还差几个月就要跨到2018 2006，我小学毕业2006，我劝我爸戒烟，到今天戒了11年仿佛一夜之间我长大 爸妈沧桑 2006年小学毕业2009年初中毕业2012年高中毕业2016年大学毕业2017，我还在校园里 小时候想当科学家高考志愿只有通信工程这一项现在立志于作为一名优秀的程序员到底学会了什么？ 自洽的价值观明白自己的局限懂得适当的克制和谦让随心所欲而不逾矩 感觉地理决定论是有道理的西安就是这样，纵使千百年来变换不卑不亢，稳重四方四四方方，东南西北 西安西安看到城墙就心安 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374《西安事变》-----------黑撒我把房子买到了红专路旁边不远就是纬二街向北一站就到了小寨我爱的女娃就在那儿上班夏天来了我吹着空调冬天晚上我抱着暖气睡觉烟瘾上来我抽根好猫开车兜风去子午大道平淡的生活里偶尔会怀念有理想的日子 虽然兜里没钱光阴不等人 转眼已十年我和这城市一起在改变想起我爸给我做的纸扇想起我妈点着蜂窝煤做饭在学校厕所抽着一块五的窄版骑着二八钢驴跟伙计去吃个凉皮套餐------------------------------------------那些日子已经 离你八丈远阳台上再也看不到终南山高楼大厦挡住了我的眼看不到当年那张叛逆的脸那些日子已经 离你八丈远就好像曾经蓝蓝的天我的家乡和我的初恋一样那些最美的回忆 已经消失不见-------------------------------------------我买了新电脑 打游戏很展可还是想念 在游戏厅对练整了个投影仪 开家庭影院可还是难忘 录像厅的老板给我的吉他 装了套进口琴弦可再也不像当年 天天都苦练电视上的女明星 越来越性感可哪有初三时的同桌 让我迷恋其实想起过去 也有过很多不满有时候喝酒我也会忆苦思甜可苦 也有苦的幸福甜也有甜的伤感那些曾在一起单纯的伙伴啊现在埋在人海 为生活埋头苦干你是否会在某个失眠的夜晚想起曾经执着追求的浪漫-------------------------------------无数次我站在钟鼓楼下听不到钟鼓奏响无数次我走在雁翔路上看不见大雁飞翔能不能再次牵起你的手回到那灿烂的时光长安路一眼望不到尽头那么漫长--------------------------------------西边的太阳就要落山了鬼子的末日就要来到弹起我心爱的木吉他唱起那动人的歌谣]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>旧事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于OpenCV全景拼接（Python）]]></title>
    <url>%2F2017%2F09%2F19%2F%E5%9F%BA%E4%BA%8EOpenCV%E5%85%A8%E6%99%AF%E6%8B%BC%E6%8E%A5%EF%BC%88Python%EF%BC%89%2F</url>
    <content type="text"><![CDATA[翻译自https://www.pyimagesearch.com基于OpenCV（Python）的图片拼接和全景图构建。“缝合”两张有重叠区域的图来创建一张全景图。构建全景图利用到了计算机视觉和图像处理技术有：关键点检测、局部不变特征、关键点匹配、RANSAC(Random Sample Consensus，随机采样一致性)和透视变形。因为在处理关键点检测和局部不变性在OpenCV 2.4.X和OpenCV 3.X中有很大的不同，比如SIFT和SURF。这里将给出兼容两个版本的代码。在之后的博客会解决多张图片的拼接，而不仅仅只是针对两张图片。 OpenCV全景拼接全景拼接算法有四部分组成 Step1:从输入的两张图片里检测关键点、提取局部不变特征。 Step2:匹配的两幅图像之间的特征 Step3:使用RANSAC算法利用匹配特征向量估计单应矩阵（homography matrix）。 Step4:利用Step3得到的单应矩阵应用扭曲变换。 将所有的步骤都封装在panorama.py，定义一个Stitcher类来构建全图。Stitcher类将会依赖Python的包imutils，安装方法：1pip install imutils 关于panorama.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125# import the necessary packagesimport numpy as npimport imutilsimport cv2class Stitcher: def __init__(self): # determine if we are using OpenCV v3.X self.isv3 = imutils.is_cv3() def stitch(self, images, ratio=0.75, reprojThresh=4.0, showMatches=False): # unpack the images, then detect keypoints and extract # local invariant descriptors from them (imageB, imageA) = images (kpsA, featuresA) = self.detectAndDescribe(imageA) (kpsB, featuresB) = self.detectAndDescribe(imageB) # match features between the two images M = self.matchKeypoints(kpsA, kpsB, featuresA, featuresB, ratio, reprojThresh) # if the match is None, then there aren't enough matched # keypoints to create a panorama if M is None: return None # otherwise, apply a perspective warp to stitch the images # together (matches, H, status) = M result = cv2.warpPerspective(imageA, H, (imageA.shape[1] + imageB.shape[1], imageA.shape[0])) result[0:imageB.shape[0], 0:imageB.shape[1]] = imageB # check to see if the keypoint matches should be visualized if showMatches: vis = self.drawMatches(imageA, imageB, kpsA, kpsB, matches, status) # return a tuple of the stitched image and the # visualization return (result, vis) # return the stitched image return result def detectAndDescribe(self, image): # convert the image to grayscale gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # check to see if we are using OpenCV 3.X if self.isv3: # detect and extract features from the image descriptor = cv2.xfeatures2d.SIFT_create() (kps, features) = descriptor.detectAndCompute(image, None) # otherwise, we are using OpenCV 2.4.X else: # detect keypoints in the image detector = cv2.FeatureDetector_create("SIFT") kps = detector.detect(gray) # extract features from the image extractor = cv2.DescriptorExtractor_create("SIFT") (kps, features) = extractor.compute(gray, kps) # convert the keypoints from KeyPoint objects to NumPy # arrays kps = np.float32([kp.pt for kp in kps]) # return a tuple of keypoints and features return (kps, features) def matchKeypoints(self, kpsA, kpsB, featuresA, featuresB, ratio, reprojThresh): # compute the raw matches and initialize the list of actual # matches matcher = cv2.DescriptorMatcher_create("BruteForce") rawMatches = matcher.knnMatch(featuresA, featuresB, 2) matches = [] # loop over the raw matches for m in rawMatches: # ensure the distance is within a certain ratio of each # other (i.e. Lowe's ratio test) if len(m) == 2 and m[0].distance &lt; m[1].distance * ratio: matches.append((m[0].trainIdx, m[0].queryIdx)) # computing a homography requires at least 4 matches if len(matches) &gt; 4: # construct the two sets of points ptsA = np.float32([kpsA[i] for (_, i) in matches]) ptsB = np.float32([kpsB[i] for (i, _) in matches]) # compute the homography between the two sets of points (H, status) = cv2.findHomography(ptsA, ptsB, cv2.RANSAC, reprojThresh) # return the matches along with the homograpy matrix # and status of each matched point return (matches, H, status) # otherwise, no homograpy could be computed return None def drawMatches(self, imageA, imageB, kpsA, kpsB, matches, status): # initialize the output visualization image (hA, wA) = imageA.shape[:2] (hB, wB) = imageB.shape[:2] vis = np.zeros((max(hA, hB), wA + wB, 3), dtype="uint8") vis[0:hA, 0:wA] = imageA vis[0:hB, wA:] = imageB # loop over the matches for ((trainIdx, queryIdx), s) in zip(matches, status): # only process the match if the keypoint was successfully # matched if s == 1: # draw the match ptA = (int(kpsA[queryIdx][0]), int(kpsA[queryIdx][1])) ptB = (int(kpsB[trainIdx][0]) + wA, int(kpsB[trainIdx][1])) cv2.line(vis, ptA, ptB, (0, 255, 0), 1) # return the visualization return vis 2-4行是导入需要的包。用NumPy来进行矩阵操作。imutils是一套OpenCV的工具包。最后把cv2导入OpenCV。在第6行定义了Stitcher类，可以检测我们是否使用了OpenCV3。由于在opencv 2.4和OpenCV 3处理关键点检测和局部不变特征的有明显的差异，OpenCV的版本对我们的使用是很重要的。接下来是定义方法stitch，stitch方法只需要一个单一的参数：images。这是传入图片的列表，后面是要缝合在一起形成全景图。还可以提供ratio ，用于特征匹配时David Lowe比率测试，reprojthresh 是RANSAC算法中最大像素“回旋的余地”，最后的showMatches，是一个布尔类型的值，用于表明是否应可以可视化关键点匹配。第15行是所有图片的列表，这一次我们只包含两张图片的情况。照片列表的顺序很重要，我们希望能够提供的图像是从左到右的顺序。如果提供的不是这样的顺序，程序仍然可以跑，但是输出全景是不正确的。我们拆包图片列表后，调用detectAndDescribe方法（16-17行）这个方法可以检测到两张图片里关键点、提取局部不变特征。有了关键点和特征，我们可以用matchKeypoints方法（20-21行）来匹配两张图片里的特征。这个方法后面会做解释。如果返回匹配的M为None，就是因为现有的关键点不足以匹配生成全景图。返回函数为25-26行。 接下来就是准备应用透视变换：假设M不返回None，我们在第30行拆包这个元组，是一个包含关键点匹配、从RANSAC算法中得到的单应矩阵H以及最后的status，用来表明那些已经成功匹配的关键点。有了单应矩阵H后，就可将两张图片“缝合起来”。首选调用cv2.warpPerspective，需要三个参数：想要“缝合”上来的照片（本程序里的右边的图片）；还有3*3的转换矩阵H；最后就是塑造出要输出的照片。我们得到输出图像的宽是两图片之和，高即为第二张图像的高度。第36行检查看是否应该将关键点匹配，如果是的话就调用drawMatches函数，然后返回一个包含全图和可视化的图的元组。（37-42行）这样，就简单的返回一个拼接的图片。（第45行）stitch的方法已经被定义，接下来介绍下那些辅助方法。首先从detectAndDescribe方法开始。顾名思义，detectAndDescribe方法用来接收照片，检测关键点和提取局部不变特征。在我们的实现中用到了高斯差分（Difference of Gaussian (DoG)）关键点检测，和SIFT特征提取。在第52行我们检测是否用了OpenCV 3.X，如果是，就用cv2.xfeatures2d.SIFT_create方法来实现DoG关键点检测和SIFT特征提取。detectAndCompute方法用来处理提取关键点和特征。（第54和55行）有一点必须要注意的是编译OpenCV3.X的opencv_contrib是可用的。如果没有，必然会出错：AttributeError: ‘module’ object has no attribute ‘xfeatures2d’。如果出现这种问题，请正确安装OpenCV和opencv_contrib，这样就能支持后面一系列的操作。第58-65行是我们用OpenCV2.4的情况。cv2.FeatureDetector_create方法来实现关键点的检测（DoG）。detect方法返回一系列的关键点。到这里，我们需要用SIFT关键字来初始化cv2.DescriptorExtractor_create，设置SIFT特征提取。调用extractor的compute方法返回一组关键点周围量化检测的特征向量。最后，关键点从KeyPoint对象转换为NumPy数列后返回给调用函数。（第69行）下一步，我们看看matchKeypoints方法。matchKeypoints方法需要四个参数，第一张图片的关键点和特征向量，第二张图片的关键点特征向量。David Lowe’s ratio测试变量和RANSAC重投影门限也应该被提供。匹配的特征实际上是一个相当简单的过程。我们循环每张图片的描述子，计算距离，最后找到每对描述子的最小距离。因为这是计算机视觉中的一个非常普遍的做法，OpenCV已经内置了一个cv2.DescriptorMatcher_create方法，用来匹配特征。BruteForce的值表示我们能够更详尽计算两张图片直接的欧式距离，以此来寻找每对描述子的最短距离。79行的knnMatch方法是在K=2的两个特征向量的k-NN匹配（k-nearest neighbors algorithm，K近邻算法），表明每个匹配的前两名作为特征向量返回。之所以我们要的是匹配的前两个而不是只有第一个，是因为我们需要用David Lowe’s ratio来测试假匹配然后做修剪。之后，用第79行的rawMatches来计算每对描述子，但是这些描述子可能是错误的，也就是这是图片不是真正的匹配。去修剪这些有误的匹配，我们可以运用 Lowe’s ratio测试特别的来循环rawMatches，这是用来确定高质量的特征匹配。正常的Lowe’s ratio 值在[0.7,0.8].我们用Lowe’s ratio 测试得到matche的值后，我们就可以计算这两串关键点之间的单应性。计算两串关键点的单应性需要至少四个匹配。为了获得更为可信的单应性，我们至少需要超过四个匹配点。最后，Stitcher里的最后一个方法drawMatches–用来将两张图片关键点的联系可视化。这种方法需要我们通过两张原始图像来对每个图像的关键点进行设置，应用Lowe’s ratio 试验后的初始匹配，和最后由单应计算提供的状态列表。运用这些变量，我们可以通过将两张图片“里面”的关键点N和关键点M画直线来可视化。 驱动脚本stitch.py到此为止已经定义好了Stitcher类。接着么建立一个stitch.py的驱动脚本。123456789101112131415161718192021222324252627282930# import the necessary packagesfrom pyimagesearch.panorama import Stitcherimport argparseimport imutilsimport cv2 # construct the argument parse and parse the argumentsap = argparse.ArgumentParser()ap.add_argument("-f", "--first", required=True, help="path to the first image")ap.add_argument("-s", "--second", required=True, help="path to the second image")args = vars(ap.parse_args())# load the two images and resize them to have a width of 400 pixels# (for faster processing)imageA = cv2.imread(args["first"])imageB = cv2.imread(args["second"])imageA = imutils.resize(imageA, width=400)imageB = imutils.resize(imageB, width=400) # stitch the images together to create a panoramastitcher = Stitcher()(result, vis) = stitcher.stitch([imageA, imageB], showMatches=True) # show the imagescv2.imshow("Image A", imageA)cv2.imshow("Image B", imageB)cv2.imshow("Keypoint Matches", vis)cv2.imshow("Result", result)cv2.waitKey(0) 第2-5行我们导入需要的包。注意我们已经将panorama.py和Stitcher类整合到pyimagesearch模块里，这样只是为了保持我们代码的整洁。 第8-14行是解析参数的命令行：–first是我们全景图的第一张图片（左边的图），–second是全景图的第二张图片（右边的图）。注意：这些图像的路径一定是从左到右的顺序！stitch.py剩下的程序是驱动脚本，会简单处理载入图片，调整大小（适合屏幕大小），构建全图。 图片载入调整大小后，我们需要初始化类Stitcher（第23行）。之后调用stitch方法，通过两张图片的可视化可以很清晰的观察两张图片之间的关键点匹配。 最后，第27-31行展示我们输出的照片。 全景拼接测试12python stitch.py --first images/bryce_left_01.png --second images/bryce_right_01.pngpython stitch.py --first images/IMG_4674.JPG --second images/IMG_4678.JPG 注意：这两张图片为我用iPhone拍摄，所以是自动对焦。虽然自动对焦在两张图片之间有轻微的不同，但是两张图片“缝合”的地方还是有裂缝，图片拼接和全景图构建最好用同一焦距去拍摄。 附录SIFT算法详解随机抽样一致性算法（RANSAC）RANSAC算法详解（updating）]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenCV</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-Opencv的安装]]></title>
    <url>%2F2017%2F09%2F15%2FPython-Opencv%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Windows下安装python2和python3双版本Python2的Opencv的安装Python整出的向下不兼容简直是败笔，无奈，还是要处理。一直都在使用Python2，后来爬虫为了和team统一，使用上Python3。现在上手图像处理的一下学习，不想用C++，Opencv有Python的接口，还是Python2成熟点，为了后续的出现问题少，还是用Python2吧。 Windows下安装python2和python3双版本安装python 2.x双击 python-2.7.12.amd64.msi 然后一路 Next就可以了。需要注意的是python 2.x 默认安装在 C盘根目录下。 配置python 2.x 的环境变量此处需要将两个目录添加到path环境变量中： python命令文件所在目录： python 2.x安装目录 pip、easy_install等其他脚本文件所在目录： python 2.x安装目录下的Scripts目录 将下面这行内容添加到Path变量的开始位置：1C:\Python27;C:\Python27\Scripts; 安装python 3.x此处选择自定义安装，因为要修改默认安装位置。另外这里勾选了 “Add Python 3.5 to PATH” 选项，会自动配置环境变量. 将python 2.x 和 python 3.x的相关命令区分开来解决方案是：将python 3.x 下的所有命令文件名称后都添加一个3，Python ==&gt; python3删除Python35\Scripts下面的pip.exe 测试说明：一定要重新启动命令终端，否则的path变量不会被重新加载 测试发现pip3有问题，其实就是pip的版本太低了，升级一下就可以了：1python3 -m pip install -U pip Python2的Opencv的安装安装Numpy安装numpy，打开cmd，输入pip install numpy 测试： 安装opencv 在官网自行下载，这里下载的是opencv2.4.13 复制cv2.pyd 将”\opencv\build\python\2.7\x64”或”\opencv\build\python\2.7\x86”（根据python版本）文件夹中找到cv2.pyd”，复制到Python安装文件的”C:\Python27\Lib\site-packages”文件夹中。 测试：出现错误。错误原因：Python2的版本为32位，opencv的版本为64位，window的版本为64位。解决方法: 卸载Python2 32bit,安装Python2 64bit。接着重复“Python2的Opencv的安装” 搞定！ 再测试：123456import cv2import numpy as npimg = cv2.imread("C:\lena.jpg")cv2.imshow("lena",img)cv2.waitKey(10000) ok! 补：sublime的Python3和2的配置sublime作为Python的日常使用，还是需要在Python2和Python3直接切换的。 打开Sublime Text 3，依次进入Tools–&gt;Build System–&gt;New Build System Python3的配置：12345&#123; "cmd": ["D:/Python35/python3.exe","-u","$file"], "file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)", "selector": "source.python",&#125; Python2的配置： 12345&#123; "cmd": ["C:/Python27/python.exe","-u","$file"], "file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)", "selector": "source.python",&#125; 最后，选择需要的即可：]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像拼接]]></title>
    <url>%2F2017%2F09%2F14%2F%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[图像拼接技术是计算机视觉和数字图像处理领域中一个研究的重点。图像拼接是指将描述同一场景的两张或者多张有重叠区域的图像,通过图像配准和图像融合技术拼接成一幅大场景全新图像的过程。 一图像的拼接过程示具体应用情况不同有很多步骤，但主要包括三个重要步骤,为：图像的预处理、图像配准以及图像融合。 图像的预处理由于在图像获取的过程中存在这很多干扰，光线不统一的情况，常常产生图像模糊、灰度偏移及几何变形。所以对图像进行预处理是很有必要的。图像预处理的主要目的是为了：消除干扰降低图像的配准难度，提高图像配准的准确度。图像预处理包括：图像去噪、图像投影、图像修正等。 图像预处理通过硬件传感器获取到的模拟图像在转换成数字图像的过程中，由于设备存在一些自身缺陷，所采集到的原始图像中有很多不同的干扰，获取的图像达不到人们期望的质量，就必须对原始图像进行准确、有效的图像去噪，图像修正等图像前期的预处理工作，确保图像之间具有精确到像素级的校准精度。因为，图像预处理阶段的精度对最终拼接图像的质量有直接影响，所以，有必要首先研究图像拼接前的预处理。 图像的投影模型由于图像序列是实体景物在不同坐标系下的二维投影，直接对拍摄图像进行拼接无法满足视觉一致性，所以需要将待拼接的图像分别投影到一个标准的坐标系下，然后再进行图像的拼接。常见的投影模型有：平面投影、柱面投影、球面投影、立方体投影。 平面投影模式平面投影方式是指：一组有重叠的图片序列，把其中一张图片作为基准，将其它图片投影到这个基准坐标系中，使相邻图片重叠区域对齐，平面投影模式是最简单也是最直接的图像投影方式。 球面投影模式球面投影是指：将图像序列投影到以一点为坐标中心的球面上。人的眼睛在看东西时的原理就类似于球面投影，因此，以视点为中心的球面投影模型是最自然的投影模型。但是球面投影模型也存在着一些缺点，比如球面上的像素点不是行列均匀排列的关系，球面不能展开成平面，这些都使得很多图像处理算法很难用在平面投影上。 立方体投影模型立方体投影是为了克服球形投影缺点最近提出的一种新的投影模型。这种投影模型的优点是方便计算机处理与储存图像，缺点是计算机形成的图像的投影比较简单，但对于实景拍摄的图像比较困难，原因是需要很好的校正相机的拍摄位置才不会使图片在投影时出现光学变形，并且这种投影在图像拼接时难以确定立方体定点与边的对应关系。 柱面投影模型柱面投影的核心是以相机为圆柱中心点，相机焦距为半径的一个柱面作为投影面。相比立方体和球面投影方式，柱面投影只能在水平方向上转动，在垂直方向上的转动有一定的限制，只允许在较小的范围上转动。 柱面投影可以使用计算机内的图像格式直接进行存取。 柱面可以很好的展开成平面图像，使得图像处理方法更容易进行操作。 图像采集过程相比较球形投影和立方体投影简单，相机在拍摄过程中只需要固定一点然后旋转拍摄，期间使图像之间有一定的重合即可。 基于以上对各个投影模型的分析，可以发现不同的投影模式有其特定的应用背景，目前，在图像拼接算法中比较常用的是柱面投影模型，在使用中，需要对相机焦距进行估值，然后将图片投影到以焦距为半径的柱面上，再进行之后的图像拼接算法处理。 图像去噪数字图像噪声产生原因很多，有来自内部的干扰，如：电器机械产生的抖动、相机的热噪声、模数转换产生的误差等，也有来自外部的干扰，如：电磁波的冲击等。在图像拼接中，图像去噪的目的是为了方便之后算法处理过程，同时也起到改善图像视觉效果的作用。 图像去噪可分为基于图像空间域和基于图像变换域的处理方法。 图像空间域去噪方法有很多，主要是通过设计一种加权求和滤波器，对图像进行滤波是图像更加的平滑与模糊，通过平滑模糊图像牺牲图像纹理信息的方法来达到去噪的目的，比较常用的有：领域平均法，其算法取掩模内像素灰度值的平均值作为中心像素点的灰度值；空间域低通滤波发，其算法是通过一个低通卷积模版在空间域进行图像卷积运算，达到图像去噪的目的；中值滤波法一种非线性空间域滤波算法，在一定条件下，可以避免线性滤波器带来的图像变模糊的缺点。 图像变换域去噪方法原理是：将空间域图像线性变换到变换域进行处理，然后将处理后的图片反变换回空间域，达到去除图像噪声的目的。进行线性变换的方法有很多种，其中比较常用的有：傅里叶变换、余弦变换、小波变换以及Ridgelet变换等，各种变换都有各自不同的特点，合理的利用这些特点处理变换域的系数，在反变换回空间域将很有效地达到去除图像噪声的目的。 图像的增强增强的首要目的是处理图像，使其比原始图像更适合于特定目的。 图像增强的方法分为两大类：空间域法和频域法。“空间域法”是以对图像的像素直接处理为基础的。“频域法”以修改图像的傅氏为基础的。图像空间域增强根据变换函数的不同可分为：对数变换法、幂级数变换法、直方图处理法等；频域增强法有：低通滤波、高通滤波、同态滤波等。 图像配准图像配准的目的是确定一组图像序列的重叠部分和重叠位置，并且对于不同角度、不同时间和不同光照等随机条件下采集的图片做到最佳的配准效果，所以，图像配准算法是图像拼接里最为关键的步骤，图像配准算法的好坏直接影响到最后图像拼接的效率与准确率，近年来，国内外对图像拼接的研究重心基本都是在图像配准上。 图像配准的原理及概念假设给定两幅图像和,其中是两幅图像空间和中的某一点。图像配准算法的目标是找到一种变换,使得变换某一图后两幅图像的相似程度：达到最大。相似性测度是一个跟变换有关并借助两幅图像数据计算出的用来衡量相似程度的函数，最后通过一种数学优化算法找到该函数的最优解，即变换。 图像配准算法图像配准算法可以分为基于区域和基于特征的算法。在待配准的图像中，以一幅图像作为参考图像，其它图像则称为目标图像。图像配准需要将目标图像进行空间几何变换使得与参考图像对齐。基于区域灰度强度的配准方法是通过模板在拼接图像中寻找与参考图像相似度最高的模版，从而找到最佳的配准位置；基于特征的配准方法则是通过匹配几幅图像中相似度最高的特征点，来找到最好的配准效果，其中特征点有：角点、线和轮廓，基于特征的配准算法包括：Harris角点检测算法、SIFT尺度不变转换算法、SURF尺度不变算法等。 基于空间域像素灰度值的方法。早期的像素配准算法一般都是直接利用图像中的像素选定一定区域来建立模板进行拼接,而其中模板的选取一般都不会很复杂，最简单的方法是利用整幅图像作为模版，然后利用选取的模版在相邻有重叠部分的图片上平移，通过计算比较模版覆盖区域的相似程度，找到一种最佳的匹配方式。这种基于灰度的算法计算量大运算速度慢。针对全局图像搜索慢的缺点，Toyama提出了一种在一幅图片中选取一块矩形区域作为模版进行搜索，然后通过计算比较最后的相关度，最后找到相关度最大的位置即为最佳配准位置，该算法相比之前的算法运算速度上有了一定的提升，但计算量仍然很大。Faugeras提出基于多层分辨率金字塔的配准算法，该算法通过从粗到细的顺序寻找相似度最佳的匹配位置，该方法在很大程度上提高了运算速率，但对于图像存在尺度变化、旋转角度大等情况匹配的效果不是很好。 Faugeras等提出了基于金字塔数据结构的多分辨率图像配准算法,按由粗到细的顺序寻找最佳配准位置,首先算出图像邻域内的像素点的灰度平均值,得到分辨率低一级的数字图像,再照此算法继续下去，可得到一组金字塔式的数字图像,在对两幅待拼接的数字图像都做了此处理后,从两幅数字图像的某一低级的分辨率开始进行搜索,直到搜索到一个最佳的配准位置。此算法的搜索速度很快，拼接图像尺度缩放小的情况下具有良好的效果，但如果图像的旋转的角度很大,配准效果就不是很好。 基于图像特征的配准算法由于基于区域的图像配准算法在试图利用图像的全局信息进行图像配准时，出现计算量大和对图像本身特征敏感的问题，决定了该算法只能应用于一部分图像尺度、几何、亮度变化比较简单的图像，因此，另一种基于特征的图像配准算法就显得更加有效。基于特征的配准算法是目前应用最广的一种图像配准算法，该方法具有计算量少、对图像（尺度、几何、亮度）变化不敏感、配准效果好等特点，这类方法主要是提取图像中对几何、尺度、亮度变化不敏感特征，生成一对图像的特征集合，最后通过计算比较这对特征集合的相似度，寻找出最佳的配准位置。 图像的几何变换模型通常待拼接的图像之间一般都有不同程度的几何形变，为了实现图像的拼接，就必须找到图像之间存在的几何变换模型，空间变换模型的方式有平移模型、刚性模型、相似模型、仿射模型以及投影模型等。 矩阵M里面未知数的不同形式对应于不同的几何变换。 刚性变换 该变换代表相机模型平移和绕光轴旋转运动，对应的物体形状大小不变。 仿射变换 仿射变换的特点是：变换是线性的，经过仿射变换的直线仍然是直线。可以表示相机的平移、旋转、缩放运动。仿射变换后的平行线依然是平行线，仿射变换有6个自由度 透视变换 透视变换是最一般的变换形式，前面提到的几种变换：刚性变换、仿射变换等都是透视变换的特殊形式，透视变换具有8个自由度 上面介绍的几种变换是图像拼接中经常用到的模型，每一种图像变换模型都有其各自适用的领域，在数字图像拼接中都会应用其中的某种图像变换模型。图像变换模型的选择将直接关系到拼接图像的结果。 图像的重采样在确定了图像之间的变换矩阵之后，接下来就是对拼接图像进行重采样，将拼接图像上的像素点采样到同一坐标系下。图像重采样有两种方法，分别是：直接法和间接法。 直接法：是从原始数字图像上的像素点坐标出发，通过变换矩阵求出拼接后图像上对应的像素点的坐标，再将原始图像上像素点的灰度值赋给拼接后数字图像上的对应像素点。 间接法：是从拼接后图像上像素点坐标出发，求出原始图像上对应的像素点坐标，然后将原始图像上像素点的灰度值赋给拼接后图像上对应坐标的像素点。 在对坐标点进行矩阵运算求对应坐标点时，无论是直接法还是间接法都会出现计算得出非整数坐标值的问题，因此，需要用到邻域范围内像素点的灰度信息，通过插值的方法求出目标点的灰度值。比较常用的插值算法有：最近邻值法、双线性插值法和立方卷积法。通过分析可以知道，三种算法的精确度由低到高，同时计算复杂度也是由低到高。 图像配准是图像拼接的关键步骤，直接决定了最后图像拼接的质量。数字图像配准目的是能够找到一个空间变换,使得数字图像序列之间相互重叠的部分的坐标点能够准确地对准。图像配准算法不但要保证图像配准时的准确度,而且要能够减小计算量，图像配准是数字图像拼接技术的关键步骤。 图像融合图像配准后，通过对配准图像重采样就可以进行图像的拼接。但由于图像灰度差异等原因，拼接后的图像很容易出现亮度差异和拼接接缝，所以在图像拼接后需要进行图像融合，使拼接后的图片看起来自然准确。 在建立参考图像与拼接图像的配准关系后，就可以将图像进行拼接了，由于图像之间无可避免地存在着灰度差异，使得拼接后的图片出现拼缝或者亮度差异的情况。图像融合就是在图像拼接过程中尽量减少亮度差异以及消除拼缝的过程。图像融合分成图像合并和拼缝消除两个过程。 图像融合意义图像融合是指：在确定参考图像与拼接图像的几何变换关系之后，接着将待拼接图像的像素点投影到参考图像坐标系中 图像融合方法分类在图像拼接中，图像融合主要用来将拼接后得到的图像重叠部分进行融合，使图像在视觉上保持一致性，图像融合根据拼缝消除方法的不同可分为：直接平均法、加权平均法和渐入渐出法等。 图像拼接需要从待拼接图像中检测出重叠部分才能进行拼接，这需要对待拼接图像提取关键信息从而确定图像的拼接部分。之前介绍分析过基于图像像素块查找法和图像特征点提取法，在实际应用中，直接匹配图像像素点运算量大，对图像几何变换、灰度差异、尺度缩放都比较敏感，因此很少直接应用。一般的实际应用中，主要采取了特征点提取的方法。图像的特征点因为具有可重复性、特殊性、鲁棒性，使得在图像拼接中，我们只要提取待拼接图像的特征点，然后通过特征点确定图像直接的配准关系，这无疑大大减小计算量，也提高了匹配的精确度。 二简介图像拼接分为四个步骤：图像匹配、重投影、缝合和融合。 图像匹配：是指一对描绘相同场景之间的几张图片的几何对应关系。一组照片可以是不同时间不同位置的拍摄，或者由多个传感器同时拍摄多张图像。 重投影：通过图像的几何变换，把一系列图片转换成一个共同的坐标系 缝合：通过合并重叠部分的像素值并保持没有重叠的像素值使之生成更大画布的图像 融合：通过几何和光度偏移错误通常导致对象的不连续，并在两个图像之间的边界附近产生可见的接缝。因此，为了减小接缝的出现，需要在缝合时或缝合之后使用混合算法. 图像拼接算法分类如图二所示，对“图像匹配方法”分类，图像拼接算法可分为基于“空间域”和“频域”。基于空间域的图像拼接可以进一步划分为基于区域的图像拼接和基于特征的图像拼接。基于特征的图像拼接可以再细分为基于底层特征的图像拼接（low level feature-based image mosaicing）和基于轮廓的图像拼接（contour-based image mosaicing）。基于底层特征的拼接可以分为四类：基于Harris角点检测器的拼接、基于FAST角点检测器的拼接、基于SIFT特征检测器的拼接、以及基于SURF特征检测器的拼接。如图三所示，根据“融合方法”，拼接算法可分为基于平滑过渡（transition smoothening-based）和基于最佳接缝（optimal seam-based）。基于平滑过渡拼接可以进一步被分成基于羽化（feathering-based）、基于金字塔（pyramid-based）、和基于梯度（gradient-based）的拼接。 对图像拼接的“图像匹配方法(registration)”分类基于空间域(Spatial domain)图像拼接算法这类算法使用像素的属性进行图像匹配，因此它们是最直接的图像拼接的方法。现有的图像拼接算法大部分都属于这一类。图像拼接算法大部分都属于这一类。“基于空间域图像拼接算法”可以是基于区域（area-based）或基于特征（feature-based）的。“基于区域“的图像拼接算法依赖于计算待拼接的两个图像的“窗口”像素值基本方法是将图像有关联的“窗口”互相转移，看看有多少像素的匹配。最常用的两个基于空间域的图像拼接算法 是基于“归一化互相关”（normalized cross correlation）的拼接和基于“互信息”（mutual information）的拼接。这两种方法都提供了图像相似性的量度，这些指标的较大值来自匹配区域或“窗口”大小。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构笔记（二）]]></title>
    <url>%2F2017%2F09%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第4章 栈与队列第5章 串第6章 树 第4章 栈与队列栈是限定仅在表尾进行插入和删除操作的线性表。队列是只允许在一段进行插入操作、而在另一端进行删除操作的线性表。 栈把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom）,不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out）的线性表。 队列队列是一种先进先出的线性表，允许插入的一端称为队尾，允许删除的一端称为队头。 第5章 串串：串是由零个或多个字符组成的有限序列，又名叫字符串。 第6章 树树是n(n&gt;=0)个结点的有限集。n=0时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（root）的结点；（2）当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、Tn,其中每一个集合本身又是一棵树，并且称为根的子树（subtree） 二叉树的定义二叉树是n(n&gt;=0)个节点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根节点和两颗互不相交的、分别称为跟节点的左子树和右子树的二叉树组成。 二叉树特定 每个节点最多有两棵子树，所以二叉树中不存在度大于2的节点。 左子树和右子树是有顺序的，次序不能任意颠倒。 即使树种某节点只有一棵子树，也有区分它是左子树还是右子树。 特殊二叉树斜树所有的节点都只有左子树的二叉树叫左斜树。所有节点都是只有右子树的二叉树叫右斜树。 满二叉树在一棵二叉树中，如果所有分支节点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 完全二叉树对一棵具有n个结点的二叉树俺层序编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这课二叉树称为完全二叉树。 二叉树的性质 性质1：在二叉树的第i层上至多有2^(i-1)个结点(i&gt;=1)。 性质2：深度为K的二叉树至多有2^(k)-1个结点(K&gt;=1)。 性质3: 对任何一棵二叉树T，如果其终端结点数为n0,度为2的结点数为n2,则n0=n2+1. 性质4：具有n个结点的完全二叉树的深度为[Log2n]+1([x]表示不大于x的最大整数)。 二叉树的存储结构二叉树顺序存储结构二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。 二叉链表二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法。称这样的链表叫做二叉链表。 遍历二叉树二叉树遍历原理二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。两个关键词：访问和次序。 二叉树的遍历方法前序遍历规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。 中序遍历规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。 后续遍历规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。 层序遍历规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂言杂语]]></title>
    <url>%2F2017%2F09%2F10%2F%E5%9F%8E%E5%86%85%E5%A2%99%E5%A4%96%2F</url>
    <content type="text"><![CDATA[“当任何时候你觉得难受了，其实你的大脑是在进化，当任何时候你觉得轻松，其实都在使用以前的坏习惯。” 研一结束，研二开始。从进了俱乐部到现在作为俱乐部主席。其实我很不喜欢听到别人叫我“主席”这两个字，这两个字好像有更远的距离，这两个字更多的意味着责任。我总觉得自己十分幸运。幸运的遇到能一直无私帮助我的人，无私促使我成长。 这段时间一直在忙俱乐部纳新的事情，看到新生申请的报名表，优秀的人真的好多，在他们面前我都汗颜。让我想到之前的科协，好像回到了从前。这几天事情比较多，用回了锤子便签，同步后发现自己当初写的一段话： 一年来，作为科协第23界主席我觉得自己也成长了不少。对一切事情的认识，对人的认识都感觉不是以一个人的眼光来看，是以一个全局的眼光去看待一件事情是否有利于这个组织的发展。在科协待了三年许，其中感情不言而喻。少了些许个人意气用事，收敛了些许暴戾的脾气，一切都以这个大集体为重。 作为科协主席，一定要有大局观。不管科协主席团其他人是怎么样的主席一定要坚持到最后，将事情做完。讨论事情的错在于谁或者错在哪里在时候再做讨论。主席团需要批评的存在，一家人有问题就说问题，完了以后还是一家人。 作为主席，是所有活动的制定者而不是执行者。这一点一定要谨记！！！要细而再细的去安排，去安排到各部责任到人。主席只是安排与检查他们执行完后的反馈。确保每个任务都有它的反馈机制，不要上边安排，下面并没有执行。有事没事都要去考虑一下科协的未来发展方向，接下来科协要做什么？这段时间的主要任务是什么？该怎么分配时间？该如何去安排各部开展工作？预期结果如何？实际结果？以后的工作需要怎么改进？要为科协留下宝贵的财富。记得将所有的东西存档，归类。要均衡发展各部，督促他们完成他们应该完成的事情。 不管自己以前脾气怎么样，安排如何，做到主席这个位子，就一定要以大局为重，这也是在当主席来一年来成长最多的地方。要学的会艺术的讲话，会与人沟通，在正式场合，所有的讲话都不是代表个人的，而是代表科协，必须注意这点。多去主动找负责科协的老师，有事情找老师，没事情找老师汇报工作。也要多去找有科研项目的老师，为科协的主席团，技术团，大二成员找事情做。对于科协比赛，科协的规章制度，科协的种种要敢于创新的去创新，不要一味的照搬前几届的做法，科协需要新鲜血液的注入，需要敢于闯，敢于大干的人！ 去年印包科协纳新是宣讲会邀请我去发言，归来是主管的徐老师送我们回金花，一路上夸我们自动化科协，批评他们印包科协，说了一句话我记忆犹新，也是我写在自己工作本上的一句话”把科协当做事业来做！” 没想到我当时竟然有如此大的目标：”把科协当做事业来做！”我觉得我在科协是付出了，也和大家一起做出了成绩，是给科协留下了一些宝贵的东西的。研究生生活确实蛮苦逼的，但是我仍然想在俱乐部里做点事情，留下点东西。 说点其他的。 人啊，认清自己很重要！情商也是属于智商的一部分！总有人的脾气比能力还大，井底之蛙最可怕的就是没有敬畏之心。当所有人都想削尖脑袋往一个地方挤的时候，你觉得自己如何与别人竞争？自己想要的东西就去积极争取啊，而不是总想着天上掉馅饼! 最后，永怀敬畏之心，好好说话，情绪稳定。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3学习集合]]></title>
    <url>%2F2017%2F08%2F31%2FPython3%E5%AD%A6%E4%B9%A0%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[打印 list的使用 tuple元组 条件判断 循环 定义函数 函数的参数 递归函数 函数作为返回值 切片 列表生成器 生成器 迭代器 map/reduce filter sorted lambda 匿名函数 Decorator装饰器 偏函数 字典dic和set 模块 面向对象编程 类和实例 private 访问限制 继承和多态 获取对象信息 打印12345print("hello")print("这样","可以","连接","起来吗？",",自动识别为空格")print("试试"+"加好可以连接吗?","事实证明是可以的")print("100+200 =",100+200)print(len("abc")) list的使用12345678910111213classmates = ["Nicolo","Tom","Jerry"]print("从开始取：",classmates[0])print("从末尾取：",classmates[-1])print("获取list的长度：",len(classmates))classmates.append('Adam')print("list中追加元素到末尾：",classmates[-1])classmates.insert(1, 'Jack')print("按照索引插值：",classmates[1])print("要删除list末尾的元素，用pop()方法,删除的东西",classmates.pop())print("要删除指定位置的元素，用pop(i)方法，其中i是索引位置：", classmates.pop(1))print("要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：")classmates[1] = 'Sarah'print(classmates) tuple元组123456print("tuple一旦初始化就不能修改，比如同样是列出同学的名字")classmates = ('Michael', 'Bob', 'Tracy')print(classmates)# 现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。# 其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。# 不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 条件判断1234567891011121314# 输入用户年龄，根据年龄打印不同的内容，在Python程序中，用if语句实现：age = 24if age &gt; 18: print("他的年龄是",age) print("他长大了")else: print("他还是个小男孩")if age &gt;= 18: print('adult')elif age &gt;= 6: print('teenager')else: print('kid') 循环123456789101112131415161718# Python的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来names = ['Michael', 'Bob', 'Tracy']for name in names: print (name) # 所以for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。# 计算1-10的整数之和，可以用一个sum变量做累加sum = 0for n in [1,2,3,4,5,6,7,8,9,10]: sum = sum +nprint(sum)# 如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数# 可以生成一个整数序列，再通过list()函数可以转换为list。# print(list(range(101)))sum1 = 0for n in list(range(101)): sum1 = sum1 + nprint(sum1) 定义函数12345678910111213141516171819202122232425262728293031323334353637# 定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:# 然后，在缩进块中编写函数体，函数的返回值用return语句返回。# 自定义一个求绝对值的my_abs函数def my_abs(x): if x &gt; 0: return x else: return - xprint(my_abs(0))print(my_abs(-1))# 定义空函数# 占位符作用def nop(): pass# 数据类型检查可以用内置函数isinstance()实现def my_abs(x): if not isinstance(x, (int, float)): raise TypeError('bad operand type') if x &gt;= 0: return x else: return -x# 返回多个值import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 函数的参数12345678910111213141516171819202122232425262728293031# 定义注册函数def enroll(name,gender,age,city): print('name:',name) print('gender:',gender) print('age:',age) print('city:',city)enroll("Nicolo","male",24,"Xian")#或定义某几个参数def enroll2(name,gender,age= 24,city = "Xian"): print('name:',name) print('gender:',gender) print('age:',age) print('city:',city)enroll2("Nicolo","male")#可变参数def calc(*numbers): sum = 0 for n in numbers: sum = sum +n return sum#testprint("1-2之和：",calc(1,2))# Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去nums = [1,2,3,4,5,6,7,8,9,10]print("1-10之和：",calc(*nums))# *nums表示把nums这个list的所有元素作为可变参数传进去。 递归函数123456789# 在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。# 计算阶乘n! = 1 x 2 x 3 x ... x ndef fact(n): if n == 1: return 1 return n * fact(n-1)print(fact(10))# 使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。 函数作为返回值12345678910111213141516171819202122232425262728293031323334353637# 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。# 通常情况下，求和的函数是这样定义的：def calc_sum(*args): ax = 0 for n in args: ax = ax +n return axprint(calc_sum(1,2,3))# 但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax +n return ax return sum# 当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：f = lazy_sum(1, 3, 5, 7, 9)# 调用函数f时，才真正计算求和的结果：print(f())# 在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，# 当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。# 闭包# 注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用# 小结# 一个函数可以返回一个计算结果，也可以返回一个函数。# 返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。 切片12345678910111213141516171819202122232425262728293031323334# 1行代码能实现的功能，决不写5行代码。请始终牢记，代码越少，开发效率越高。#切片# 取一个list或tuple的部分元素是非常常见的操作L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']# 取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：print(L[0:3])print(L[:3])# L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。# 从索引1开始，取出2个元素出来：print(L[1:3])# 支持倒数切片print("倒数切片",L[-2:])print("倒数切片",L[-2:-1])# 记住倒数第一个元素的索引是-1。# 其他操作nums = list(range(100))print("取前10个：",nums[:10])print("取后10个：",nums[-10:])print("取前11-20个数：",nums[11:20])print("前10个数，每两个取一个：",nums[:10:2])print("所有数，每5个取一个：",nums[::5])# tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuplenums2 = (0, 1, 2, 3, 4, 5)[:3]print(nums2)# 字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串str = 'ABCDEFGHIJKMLN'[:4]print(str) 列表生成器1234567891011121314151617181920212223242526272829303132333435363738394041# 列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。# 生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]a = list(range(1, 11))print(a)# 生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？#方法一l = []for x in range(1,11): l.append(x*x)print("方法一",l)# 方法二L = [x*x for x in range(1,11)]print("方法二",L)# 写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来# for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：L2 = [x*x for x in range(1,11) if x % 2 ==0]print("筛选出仅偶数的平方",L2)# 还可以使用两层循环，可以生成全排列L3 = [m + n for m in "ABC" for n in "XYZ"]print("生成全排列",L3)# 列出当前目录下的所有文件和目录名# 运用列表生成式，可以写出非常简洁的代码。import osL4 = [d for d in os.listdir('.')]print("列出当前目录下的所有文件和目录名",L4)# 列表生成式也可以使用两个变量来生成listd = &#123;'x': 'A', 'y': 'B', 'z': 'C' &#125;L5 = [k+'='+ v for k,v in d.items()]print("使用两个变量来生成list",L5)# 把一个list中所有的字符串变成小写：L6 = ['Hello', 'World', 'IBM', 'Apple']L7 = [s.lower() for s in L6]print("所有的字符串变成小写",L7) 生成器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？# 这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。# generator保存的是算法# 第一种方法# 只要把一个列表生成式的[]改成()，就创建了一个generatorL = [x*x for x in range(1,11)]print(L)g = (x*x for x in range(1,11))# 创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。# 可以通过next()函数获得generator的下一个返回值print(next(g))# 这种不断调用next(g)实在是太变态了，正确的方法是使用for循环for n in g: print(n)# 斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：# 1, 1, 2, 3, 5, 8, 13, 21, 34, ...# 斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易def fib(max): n,a,b = 0,0,1 while n&lt;max: print(b) a,b=b,a+b n=n+1 return 'done'# fib函数实际上是定义了斐波拉契数列的推算规则# 要把fib函数变成generator，只需要把print(b)改为yield b就可以了def fib(max): n,a,b = 0,0,1 while n&lt;max: yield b a,b=b,a+b n=n+1 return 'done' # 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator # generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。 # 而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。# 举个简单的例子，定义一个generator，依次返回数字1，3，5def odd(): print('step 1') yield 1 print('step 2') yield(3) print('step 3') yield(5)# 调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：# o = odd()# next(o) 迭代器1234567891011121314151617181920212223242526# 可以直接作用于for循环的数据类型有以下几种：# 一类是集合数据类型，如list、tuple、dict、set、str等；# 一类是generator，包括生成器和带yield的generator function。# 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。# 可以使用isinstance()判断一个对象是否是Iterable对象# 而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。# 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。# 可以使用isinstance()判断一个对象是否是Iterator对象：# 如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。# 在Python中，迭代是通过for ... in来完成的# Python的for循环抽象程度要高于Java的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。# list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代d = &#123;'a': 1, 'b': 2, 'c': 3&#125;for key in d: print("迭代出key值",key) #默认情况下，dict迭代的是key。# 如果要迭代value，可以用for value in d.values()for value in d.values(): print("迭代出value值",value)# 如果要同时迭代key和value，可以用for k,v in d.items()for k,v in d.items(): print("迭代出key和value值",k,v) map/reduce123456789101112131415161718# map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。# 比如我们有一个函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下def f(x): return x * xr = map(f,[1,2,3,4,5,6,7,8,9])print(list(r))# 结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。# 一行代码print(list(map(f,[1,2,3,4,5,6,7,8,9])))# reduce把一个函数作用在一个序列[x1, x2, x3, ...]上# 这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：# reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)from functools import reducedef add(x,y): return x + yprint(reduce(add,[1,2,3,4,5,6,7,8,9])) filter1234567891011121314# filter()函数用于过滤序列# 和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。# 在一个list中，删掉偶数，只保留奇数，可以这么写：def is_odd(n): return n % 2 == 1print(list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])))# 把一个序列中的空字符串删掉def not_empty(s): return s and s.strip()print(list(filter(not_empty,['A','','B','',None,'c','d']))) sorted123456789101112131415# sorted排序算法# 排序算法# 排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。# 如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。# Python内置的sorted()函数就可以对list进行排序# 从小到大print("一般使用",sorted([112,3,4,54,23,67,85]))# sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：print("带参排序",sorted([12,53,-213,-65,2,-52],key = abs))# 要进行反向排序，不必改动key函数，可以传入第三个参数reverse=Trueprint("反向排序",sorted([112,3,4,54,23,67,85],reverse=True)) lambda 匿名函数123456789101112131415161718192021222324252627# 当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。# 在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：print(list(map(lambda x: x * x,[1,2,3,4,5,6,7,8,9])))# 通过对比可以看出，匿名函数lambda x: x * x实际上就是：# def f(x):# return x * x# 关键字lambda表示匿名函数，冒号前面的x表示函数参数。# 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。# 用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：f = lambda x: x * xprint("lambda使用",f(5))# 也可以把匿名函数作为返回值返回def build(x,y): return lambda: x*x + y*ybuild(2,3)# 小结# Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。 Decorator装饰器12345678910111213141516171819202122232425262728293031323334353637# 由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。def now(): print('2017-7-25')f = nowf()# 函数对象有一个__name__属性，可以拿到函数的名字：print(now.__name__)print(f.__name__)# # 假设我们要增强now()函数的功能，# 比如，在函数调用前后自动打印日志，# 但又不希望修改now()函数的定义，# 这种在代码运行期间动态增加功能的方式，# 称之为“装饰器”（Decorator）。# 本质上，decorator就是一个返回函数的高阶函数。# 要定义一个能打印日志的decorator，可以定义如下：def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper # 观察上面的log，因为它是一个decorator，# 所以接受一个函数作为参数，并返回一个函数。# 我们要借助Python的@语法，把decorator置于函数的定义处@logdef now(): print('2017-7-25')# 调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：now() 偏函数12345678910111213141516171819# 在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点# int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换print("默认十进制",int('123456'))# 但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：print("八进制",int('12345',base = 8))def int2(x, base=2): return int(x, base)print("二进制",int2('1000000'))# functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2import functoolsint2 = functools.partial(int, base = 2)# 简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。# 注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：int2('1000000', base=10) 字典dic和set12345678910111213141516171819202122232425262728# Python内置了字典：dict的支持，dict全称dictionary# 在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。# 这个通过key计算位置的算法称为哈希算法（Hash）。# []：list# ()：tuple# &#123;&#125;: dict# 学生成绩score = &#123;"Nicolo":100,"Tom":99,"Jerry":99&#125;print("打印Nicolo的成绩：",score["Nicolo"])# 把数据放入dict的方法，除了初始化时指定外，还可以通过key放入score["Nicolo"] = 101print("打印Nicolo的成绩：",score["Nicolo"])# 要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：print("Nicolo" in score)# 要删除一个key，用pop(key)方法，对应的value也会从dict中删除：score.pop("Jerry")print(score)# set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。s = set([1,2,3])# 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：s.add(4)print(s)# 通过remove(key)方法可以删除元素s.remove(4)print("移除后的",s) 模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里# 这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式# 在Python中，一个.py文件就称之为一个模块（Module）# 使用模块有什么好处？# 最大的好处是大大提高了代码的可维护性。# 其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。# 我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。# 引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。# 现在，abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了mycompany.xyz。# 每一个包目录下面都会有一个__init__.py的文件# 这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。# __init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。# 使用模块# 以内建的sys模块为例，编写一个hello的模块：#!/usr/bin/env python3# -*- coding: utf-8 -*-' a test module '__author__ = 'Nicolo'import sysdef test(): args = sys.argv if len(args)==1: print('Hello, world!') elif len(args)==2: print('Hello, %s!' % args[1]) else: print('Too many arguments!')if __name__=='__main__': test()# 第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；# 第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；# 第6行使用__author__变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；# 以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。# sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：# 运行python3 hello.py获得的sys.argv就是['hello.py']；# 运行python3 hello.py Nicolo获得的sys.argv就是['hello.py', 'Nicolo']。# 注意到这两行代码：# if __name__=='__main__':# test()# 在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__# 而如果在其他地方导入该hello模块时，if判断将失败# 因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。# 安装第三方模块pip install XXX 面向对象编程12345678910111213141516# 如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象# 然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来。class Student(object): def __init__(self,name,score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score))bart = Student('Bart Simpson', 59)lisa = Student('Lisa Simpson', 87)bart.print_score()lisa.print_score() 类和实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# ClassANDInstance# 类和实例# Python中，定义类是通过class关键字：class Student1(object): pass# class后面紧接着是类名，即Student，类名通常是大写开头的单词# 紧接着是(object)，表示该类是从哪个类继承下来# 继承的概念我们后面再讲，通常，如果没有合适的继承类# 就使用object类，这是所有类最终都会继承的类。# 定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的：bart1 = Student1()bart1.name = 'Bart Simpson'# 由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。# 通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：class Student2(object): def __init__(self,name,score): self.name = name self.score = score# 注意：特殊方法“init”前后有两个下划线！！！# 注意到__init__方法的第一个参数永远是self，表示创建的实例本身# 因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。# 有了__init__方法，在创建实例的时候，就不能传入空的参数了# 必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：bart2 = Student2('Bart Simpson', 59)print("姓名",bart2.name)print("成绩",bart2.score)# 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self# 并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别# 所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。# 数据封装# 面向对象编程的一个重要特点就是数据封装。# 在上面的Student类中，每个实例就拥有各自的name和score这些数据。# 我们可以通过函数来访问这些数据，比如打印一个学生的成绩：# 既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问# 可以直接在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。# 这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法：class Student3(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score))# 要定义一个方法，除了第一个参数是self外，其他和普通函数一样。# 要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入：bart3 = Student3('Nicolo', 99)bart3.print_score() private 访问限制12345678910111213141516171819202122232425262728293031323334# 果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，# 在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问# 所以，我们把Student类改一改：class Student(object): def __init__(self, name, score): self.__name = name #私有变量 self.__score = score #私有变量 def print_score(self): print('%s: %s' % (self.__name, self.__score))# 如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法：class Student(object): ... #get方法 def get_name(self): return self.__name def get_score(self): return self.__score# 允许外部代码修改score怎么办？可以再给Student类增加set_score方法：class Student(object): ... #set方法 def set_score(self, score): self.__score = score# 在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量# 特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 继承和多态123456789101112131415161718192021222324# 编写了一个名为Animal的class，有一个run()方法可以直接打印：class Animal(object): def run(self): print('Animal is running...') def eat(self): print('Eating meat...')# 当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：class Dog(Animal): def run(self): print('Dog is running...') class Cat(Animal): def run(self): print('Cat is running...')# 对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。# testdog = Dog()dog.run()dog.eat()cat = Cat()cat.run()# cat.eat()当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。 获取对象信息12345678910111213141516# 当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？# 使用type()# 首先，我们来判断对象类型，使用type()函数：# 基本类型都可以用type()判断：# type(123)# 使用isinstance()# 对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。# 使用dir()# 如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：print(x for x % 7 == 0 in range(101) ) 实例属性和类属性123456789101112131415# 由于Python是动态语言，根据类创建的实例可以任意绑定属性。# 给实例绑定属性的方法是通过实例变量，或者通过self变量：class Student(object): def __init__(self, name): self.name = names = Student('Bob')s.score = 90# 但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：class Student(object): name = 'Student'# 在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat启动问题（JDBC文件配置问题）]]></title>
    <url>%2F2017%2F08%2F31%2Ftomcat%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%EF%BC%88JDBC%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题：部署完tomcat，只显示首页，点击无反应。解决：是JDBC配置的问题。正确配置： jdbc.driverClassName=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/bridgedisaster?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;autoReconnect=true&amp;failOverReadOnly=false//本地端口，不是远程连接 jdbc.username=root//打开navicat,连接测试的用户名 jdbc.password=root//连接测试的密码]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>Mysql</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS、视频作品集合]]></title>
    <url>%2F2017%2F08%2F30%2FPS%E4%BD%9C%E5%93%81%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[这里是我的一些PS、视频作品。不想做好美工的程序员不是好程序员！ 【AE】全国研究生移动终端创新大赛比赛作品宣传视频快铃 【会声会影】西电华为俱乐部宣传片 &amp; 2016西电华为创新俱乐部六周年庆西电华俱六周年庆 西理工科协宣传 2017西电华为创新俱乐部纳新宣传海报及易拉宝【Photoshop】系列海报 【Photoshop】易拉宝]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>PS</tag>
        <tag>视频</tag>
        <tag>作品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫】模拟登录西电睿思领金币]]></title>
    <url>%2F2017%2F08%2F29%2F%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E8%A5%BF%E7%94%B5%E7%9D%BF%E6%80%9D%E9%A2%86%E9%87%91%E5%B8%81%2F</url>
    <content type="text"><![CDATA[爬虫入门之前对爬虫做了点杂乱的简单学习： 爬虫入门（一）：轻量级爬虫 爬虫入门（二）：单线程爬虫 爬虫入门（三）：BeautifulSoup 爬虫入门（四）：urllib2 西电教务处爬虫及数据处理对西电研究生教务处系统进行了相关数据的爬取： 【爬虫】（一）：爬网页、爬图片、自动登录 【爬虫】（二）爬取西电教务处成绩 【爬虫】（三）爬虫之处理简单验证码 【爬虫】（四）西电研究生教务系统技术文档 【爬虫】（五）数据存储之CSV 【爬虫】（六）Python数据存储之MySQL（上） 【爬虫】（七）Python数据存储之MySQL（下） 【爬虫】（八）Python之爬虫和数据小解析 Java调用Python的错误 【更正】Java调用Python 西电睿思爬虫西电睿思就是西电学子们的一个家。有个长久的打算，就是希望年底能对睿思做一个报告分析。了解西电er关心什么。 睿思爬虫领金币第一个就拿领取金币来说吧。OK！剩下待定，慢慢来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111# -*- coding: utf-8 -*-import urllib.request, urllib.error, urllib.parseimport urllib.request, urllib.parse, urllib.errorimport http.cookiejarimport reimport sysimport impimp.reload(sys) def get_hash(url, opener): c = opener.open(url).read() c=c.decode('utf-8') patt = re.compile(r'.*?name="formhash".*?value="(.*?)".*?') formhash = patt.search(c) if not formhash: raise Exception('GET formhash Fail!') formhash = formhash.group(1) return formhashclass Spider(): def __init__(self, username=None, password=None): self.front_page_url = 'http://rs.xidian.edu.cn/' self.loginurl = 'http://rs.xidian.edu.cn/member.php?mod=logging&amp;action=login&amp;loginsubmit=yes&amp;infloat=yes&amp;lssubmit=yes' self.shuiQu_url = 'http://rs.xidian.edu.cn/forum.php?mod=forumdisplay&amp;fid=72&amp;page=1' self.postdata = urllib.parse.urlencode(&#123; 'username': username, 'password': password, 'quickforward': 'yes', 'handlekey': 'ls', &#125; ).encode(encoding='UTF8') self.headers = &#123; 'User-Agent' : 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:29.0) Gecko/20100101 Firefox/29.0' &#125; self.cookieJar = http.cookiejar.CookieJar() self.opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(self.cookieJar)) def login(self): req = urllib.request.Request( url = self.loginurl, data= self.postdata, headers = self.headers ) try: response = self.opener.open(req) except Exception as e: print(e) else: print("登录成功！抓取金币开始！") def comment(self, tid): url = self.front_page_url + 'forum.php?mod=post&amp;action=reply&amp;fid=72&amp;tid=%s&amp;extra=&amp;replysubmit=yes&amp;infloat=yes&amp;handlekey=fastpost' % str(tid) formhash = get_hash('http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=%s'%tid, self.opener) data = urllib.parse.urlencode(&#123; 'formhash': formhash, 'message': '帮顶 ', 'usesig': '1', &#125;).encode(encoding='UTF8') req = urllib.request.Request( url = url, data= data, headers = self.headers ) try: response = self.opener.open(req) except Exception as e: print(e) else: if '成功' in response.read(500).decode('utf-8'): print('水了一贴') def guanShui(self): req = self.opener.open(self.shuiQu_url) decode_req = req.read().decode('utf') items = re.findall('.*?&lt;tbody id="no.*?&lt;tr.*?&lt;td.*?&lt;th.*?&lt;a.*?&lt;a href="(.*?)".*?&gt;(.*?)&lt;/a&gt;.*?&lt;/tbody&gt;',decode_req,re.S) if items: for item in items: if '金币' in item[1]: # topic title topic_url = item[0].replace('&amp;amp;', '&amp;') # topic url print(item[1]) tid = re.match(r'.*?tid=(\d+)', topic_url).groups()[0] self.comment(tid) else: print('没有散金币主题') if __name__ == '__main__': print("Hello!Rser! 正在登录！···") username = '' password = '' my_spider = Spider(username=username, password=password) my_spider.login() my_spider.guanShui()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL连接错误]]></title>
    <url>%2F2017%2F08%2F21%2FMySQL%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[ERROR 1045 (28000): Access denied for user’root’@’localhost’(using password:YES) 1.问题：命令提示符窗口，在MySQL安装bin目录下运行指令： X:Location\bin\mysql&gt; mysql -u root -p（每个人根据自己路劲选择不同目录。）出现： Enter password:输入或者不输入回车后出现错误： ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: YES)或 ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)这时去你的根目录配置你的mysql配置文件my.ini如果还美哦与搭建环境请参考：MySQL-5.6.13免安装版配置方法 记事本打开my.ini，在[mysqld]这个条目下加入 skip-grant-tables保存退出后重启mysql重启方法1：1.点击“开始”-&gt;“运行”(快捷键Win+R)。2.启动：输入 net stop mysql3.停止：输入 net start mysql重启方法2：如果1不行，到 计算机管理–&gt;服务和应用程序–&gt;服务–&gt;MYSQL–&gt;右键–&gt;启动. 这时候在cmd里面输入mysql -u root -p就可以不用密码登录了，出现password：的时候直接回车可以进入，不会出现ERROR 1045 (28000)，没有权限很多操作都会受限制。 下面这样（斜体为操作后命令提示的结果，不输入）：1.进入mysql数据库： mysql&gt; use mysql;Database changed2.给root用户设置新密码，新密码自己输： mysql&gt; update user set password=password(“新密码”) where user=”root”;警告：这个命令是5.7之前一些老版本的，如果你用的新的，这样输入会出现错误： ERROR 1054 (42S22): Unknown column ‘password’ in ‘fie这是因为5.7版本下的mysql数据库下已经没有password这个字段了，password字段改成了 authentication_string所以，应该输入如下命令： update mysql.user set authentication_string=password(‘root’) where user=’root’ ;Query OK, 1 rows affected (0.01 sec) Rows matched: 1 Changed: 1 Warnings: 03.刷新数据库 mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)4.退出mysql： mysql&gt; quitBye5.改好之后，再修改一下my.ini这个文件，把刚才加入my.ini文件的的”skip-grant-tables”这行删除，保存退出再重启mysql就可以了。重启方法见上文。 到这里以为就完事大吉了，但是，并没有。。 进入mysql后，有出现了如下错误： ERROR 1820 (HY000): You must SET PASSWORD before executing this statement坑了个爹的。。。 最后发现还需要重设密码！！！（难道刚刚的操作都是在研究如何吃屎么。。。） 解决方法如下： mysql&gt; SET PASSWORD = PASSWORD(‘123456’);对你没看错，就是在设置一边密码。。。当然你不用非弄成123456，这个随意了。。。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>MySQl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM简单介绍]]></title>
    <url>%2F2017%2F08%2F09%2FSSM%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[SSM：Struts、Spring、MybatisSSM三层集成框架系统总体设计：模块划分、数据库表，存储过程 背景J2EE框架是一种非常流行的Web开发框架。J2EE框架完整地定义了一套标准的应用开发体系结构和部署环境。基于SSH的轻量级组件模型的出现，为中小企业的应用开发提供了新的解决问题的方法。但SSH框架中持久层技术Hibernate是一种“全自动”式的ORM实现方案，该方案对数据库设计模式要求苛刻，且限制使用存储过程，给数据操作较多、表结构多变的系统的开发带来了很大的不便。SSM轻量级开发框架解决了这个问题，该框架中的数据持久层技术是MyBatis。MyBatis是一种“半自动”式的ORM实现方案，它在SQL开发的工作量和数据库移植性方面的让步，为系统设计提供了最大的自由空间。 相关技术J2EE简介基于J2EE的Web应用被划分为表示层、控制层、业务逻辑层和数据持久层，每一层在系统实现中起到不同的作用。这四层开发模式能够更好的实现“高内聚、低耦合”。将项目划分为不同的层次，有利于系统的开发、部署和维护。 J2EE的分层 表现层：JSP页面+JavaScript。表现层主要负责处理客户端界面。它是Web应用的末端，通过页面元素标签的布局和CSS样式，进行页面设计。表现层利用轻量级JavaScript脚本技术–jQuery进行页面数据处理。Ajax技术可以实现页面局部刷新，给用户提供良好的界面体验效果。 控制层：JavaBean(处理前后台参数传递)+Action（控制页面跳转+逻辑控制）。控制层是表现层和业务逻辑层之间的桥梁。控制层负责接收和响应用户的请求；封装用户数据；将用户请求提交给业务逻辑层进行处理并将处理结果通过EJB、页面标签或回调函数返回给客户端界面。 业务逻辑层：Service接口+具体实现（调用Dao组件，处理业务逻辑）。业务逻辑层主要负责业务逻辑，是整个应用的核心。业务逻辑层关联控制层和数据持久层。该层一方面接收控制层传入的请求数据，通过业务逻辑处理把处理结果数据作为响应返回给控制层；另一方面为数据持久层提供操作的数据，并接收数据持久层返回的数据。 数据持久层：Dao接口+SQL具体实现+数据库。数据持久层负责与数据库交互。数据持久层负责在数据对象和关系数据库之间建立一种映射关系，实现对数据的持久化访问。数据持久层提供了数据访问方法，能够使程序员避免手工编写程序访问数据持久层。数据持久层能够完成对各种数据进行持久化的编程工作，并为业务逻辑层提供服务。 表示层框架Struts 1.0/Struts 2.0是当前Web系统开发使用最广泛的表示层框架技术。Struts1.0是最早的MVC框架，包括模型、视图、控制器三部分。模型由实现业务逻辑的JavaBean构成；控制层由ActionServlet来实现；视图主要由一组JSP文件构成。 业务逻辑层框架Spring是开发人员首选的业务逻辑层轻量级解决方案。Spring被称为JavaEE应用的一站式解决方案。Spring本身提供了一个设计优良的MVC框架–SpringMVC，该框架一直被数据操作量少的小型项目广泛使用。Spring是J2EE框架的中间层容器，具有强大的整合框架能力。Spring可以向上与MVC框架无缝整合，向下可以与各种持久层框架无缝整合。Spring框架能够通过配置文件很好的将控制层框架和数据持久层框架整合到一起。强大的整合框架能力使之成业务逻辑层首选实现框架。 数据持久层框架数据持久层框架的作用是将数据库存储从服务层中分离出来，降低耦合度。持久层设计的关键问题就是如何在对象和关系型数据库之间建立一种映射关系。持久层框架现分为两大主流：自己编写JDBC实现SQL语句；使用O/RMapping技术实现的“全自动”式（如Hibernate）和“半自动”式（如iBatis,MyBatis）的ORM实现方案。 JDBC框架JDBC框架是一种能够解决性能障碍的持久层框架。该框架只有在请求的时候才能被调用，能够节省内存。可是JDBC的实现当时需要开发人员非常精通SQL和JDBC，需要写很多的DAO方法，而且每一次数据请求都要开启和关闭数据连接。 Hibernate框架JDBC框架适合小型简单项目。对于企业级项目，Hibernate是被广为推行的一个运行效率较高的持久层框架。它将Java对象（POJO）映射成持久化类，使应用程序能够以面向对象的方式来操作POJO，并将这些操作转换为底层的SQL语句来执行。企业级大型项目使用Hibernate，能够大大提高项目开发效率。 MyBatis框架介绍MyBatis是iBatis的升级版本。MyBatis为Java提供了更为强大的功能。 MyBatis实现了Dao接口绑定，使用更加方便。MyBatis使用简单的XML或注解用于配置和原始映射，将接口和JAVA的POJOs(Plan Old JAVA Objects，普通的JAVA对象)映射成数据库中的记录。 对象关系映射的改进，数据操作执行效率更高。在MyBatis中，除了兼容ibatis2.x中的“嵌套查询”方式外，还提供了直接“嵌套结果”的方式，其效果相当于直接通过一句SQL语句将查询出的数据传输对象(DTO)自动封装成所需要的对象。 MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。 基于J2EE的SSM框架开发技术SSM框架是由Struts，Spring和MyBatis三个框架集成的。SSM框架自上而下被分别分为表现层、控制层、业务逻辑层和数据持久层。 SSM框架的集成业务逻辑层利用Spring框架的依赖注入实现对业务逻辑接口和DAO接口的实例托管；在对象关系映射方面，利用Spring对数据库连接池的托管和对MyBatis框架的支持；开发人员需要完成Spring配置文件applicationContext.xml中对数据源以及不同模块所对应的bean进行配置，同时还要定义业务逻辑接口及其实现。数据持久层利用MyBatis来实现半自动化对象的关系映射。这种方式为系统设计提供了更大的自由空间，开发人员可以编写具体的SQL语句或存储过程。另外，开发人员需要完成对MyBatis的配置文件SqlMapConfig.xml的配置，来实现DAO接口及其实现的映射。 SSM框架的实现原理以“流程流转角色列表框的数据显示”功能的实现为例，来详细描述表示层、控制层、业务逻辑层和数据持久层的具体实现细节，以此介绍SSM框架的实现原理。表现层负责页面的设计以及处理用户请求，该层使用DIV分区和CSS样式表进行元素布局并使用jQuery提供的post方法来实现用户的请求与响应。控制层、业务逻辑层和数据持久层进行后台业务处理，通过层与层之间的相互交互来实现用户数据的处理和响应。 表现层代码实现包括新建列表元素、获取用户角色、通过AJAX函数进行前后台数据交互这三部分。 控制层Struts2框架需要进行web.xml文件、struts.xml文件和Spring的配置文件ApplicationContext.xml等文件的配置。web.xml文件需要配置请求过滤器；struts.xml文件和ApplicationContext.xml文件用来配置请求转发路径。 系统架构的设计C／S架构与B／S架构是常用的两种系统架构。C／S架构即客户机一服务器架构。C／S架构充分利用客户端和服务器端的硬件环境，将任务合理分配到客户端和服务器端来实现，降低了系统的通讯开销。B／S架构即浏览器一服务器结构。在这种架构下，用户工作界面通过浏览器来实现，事务逻辑在服务器端实现。下文将简要的介绍两种框架的优缺点。 C／S架构的优缺点优点服务器运行时的数据负荷轻。C／S架构的体系结构由客户端应用程序和数据库服务器程序组成。客户端应用程序运行于用户自己的电脑，当需要数据操作时，客户端程序自动寻找服务器程序并发送请求。服务器程序按照规则作出应答，返回结果。该过程简单，服务器的数据负荷低。 缺点系统维护量大。在系统运行时，需要在客户端和服务器端建立数据同步，因此，需要在两者之间建立实时的通讯连接，维持两地的数据库服务器在线运行。网络管理人员既要对服务器维护管理，又要对客户端维护管理，同时还需要较高的投资和技术支持，维护成本高。 B／S架构的优缺点优点系统维护量少，软件升级方便。B／S架构的软件系统只需管理服务器即可，客户端使用浏览器，一般不需要做维护。随着系统版本的不断升级，浏览器的升级和维护也越来越容易，使用起来越来越简单。 ##### 缺点服务器运行时的数据负荷重。B／S架构的系统软件安装在服务器端，事务逻辑在服务器端来实现，所有应用服务器运行数据负荷较重。一旦发生服务器“崩溃”，后果不堪设想，因此需要备有备份数据库的服务器。 通过以上两种架构的优缺点的比较，可以发现：1)B／S架构的系统维护工作量比C／S架构的少。2)B／S架构降低了客户端电脑负荷，降低了总成本。3)从数据一致性和实时性方面考虑，B／S架构优于C／S架构。 MVC模式MVC是一种架构型模式，它本身不引入新的功能，只是知道我们把Web应用结构做的更加合理，实现逻辑与页面相分离。在MVC模式中，应用程序被划分为了模型、视图和控制器三个部分。 模型部分包含了应用程序的业务逻辑和业务数据 视图部分封装了应用程序的输出形式，也就是通常所说的页面或者是界面 控制器部分负责协调模型和视图，根据用户请求来选择要调用哪个模型来处理业务，以及最终由哪个视图为用户做出应答。 MVC的组件关系图描述了模型、视图、控制器这三个部分的交互关系，下面按照交互顺序来详细描述一下它们的交互关系： 首先是展示视图给用户，用户在这个视图上进行操作，并填写一些业务数据 然后用户会点击提交按钮来发出请求 视图发出的用户请求会到达控制器，在请求中包含了想要完成什么样的业务功能以及相关的数据 控制器会来处理用户的请求，会把请求中的数据进行封装，然后选择并调用合适的模型，请求模型进行装状态更新，然后选择接下来要展示给用户的视图 模型会去处理用户请求的业务功能，同时进行模型状态的维护和更新 当模型状态发生改变的时候，模型会通知相应的视图，告诉视图它的状态发生了改变 视图接到模型的通知后，会向模型进行状态查询，获取需要展示的数据，然后按照视图本身的展示方式，把这些数据展示出来。接下来就是等待用户下一次操作，再次从头轮回了。 Ajax技术当浏览器向Web服务器发送一个请求时，服务器接收并处理传来的表单，然后返回一个新的页面。这个做法浪费了许多宽带，因为在前后两个页面中的大部分HTML代码是相同的。而出现的Ajax技术无需重新加载相同的页面，只是通过在后台与服务器进行少量数据交换，使得页面实现异步更新，不仅Web服务器的处理时间大大减少了，用户界面的响应时间也快多了。 Ajax技术在大多数现代浏览器中都能使用，而且不需要任何专门的软件和硬件。Ajax是一种客户端方法，它并不关心服务器是什么。Ajax是由HTML、JavaScript技术、DHTML和DOM组成。 Ajax应用程序的优势在于以下3方面。 通过异步模式，提升了用户体验。 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用 Ajax引擎在客户端运行，承担了一部分本来由服务器承担的工作，从而减少了大用户量下的服务器负载。 jQuery技术jQuery凭借简介的语法和跨平台的兼容性，极大的简化了JavaScript开发遍历HTML文档、操作DOM、处理事件、执行动画和开发Ajax的操作。而独特而又优雅的代码风格改变了JavaScript程序员的设计思路和编写程序的方式。 jQuery强调的理念是写的少，做的多。jQuery独特的选择器、链式的DOM操作、事件处理机制和封装完善的Ajax都是其他JavaScript库望尘莫及的。概况起来，jQuery有以下优势：开源、轻量级、强大的选择器、出色的DOM操作的封装、可靠的事件处理机制、完善的Ajax、不污染顶级变量、出色的浏览器兼容性、链式操作方式、丰富的插件支持和完善文档等。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM</tag>
        <tag>后台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nxet!]]></title>
    <url>%2F2017%2F08%2F08%2F%E8%AF%95%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Decrypt U2FsdGVkX1+tcFA9sm4Jlqpcd2nmzmjCKebnWWmyaopz9VZYoBGfI1LgEq7AJDUJK/fegjlk8wuVCfq1HQ56nQ==]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP]]></title>
    <url>%2F2017%2F07%2F31%2FJSP%2F</url>
    <content type="text"><![CDATA[window下Tomcat的下载安装及配置1、安装2、基本语法3、项目导出及部署4、JSP注释 1、安装绿色软件，下载解压即安装成功。 安装目录： bin:存放启动和关闭tomcat的脚本 conf：存放tomcat服务器的各种配置文件 lib：存放tomcat的依赖jar包 logs：存放tomcat执行时生成的日志文件 temp：存放一些临时文件 webapps：存放web应用 work：存放一些中间文件 LICENSE NOTTICE tomcat.ico Uninstall.exe配置环境变量安装目录 2、基本语法 用 JSP 向浏览器输出 hello world12345678910111213141516171819&lt;%@ page language="java" contentType="text/html; charset=ISO-8859-1" pageEncoding="ISO-8859-1"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;JSP表达式输出：&lt;%="hello world" %&gt;&lt;br/&gt;&lt;%String str = "hello world";out.print(str);%&gt;&lt;/body&gt;&lt;/html&gt; 3、项目导出及部署 export-warfile 将war文件放进.\Tomcat8\webapps目录下。 启动tomcat后war文件自动解压 浏览器浏览localhost:8080/JSPStyudy/01/hello.jsp 4、JSP注释HTML注释：12&lt;!-- this is body--&gt;&lt;!-- today is &lt;%=new java.util.Date().toString() %&gt; --&gt; JSP注释：123&lt;%--this is JSP comments.--%&gt; JSP程序段中的注释：1234&lt;%-- //String str = "hello world"; 单行注释 /*多行注释*/--%&gt;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017上半年书单]]></title>
    <url>%2F2017%2F06%2F11%2F2017%E4%B8%8A%E5%8D%8A%E5%B9%B4%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[千里万卷。 《硬派健身》 《人类简史》 《腾讯传》 《创京东》 《毛泽东传》 《人民的名义》 《我与地坛》 《鱼羊野史》 《小米口碑营销内部手册：参与感》 《人类群星闪耀时》 《嫌疑人X的献身》 《以色列：一个国家的诞生》 《以色列2：在危机中生存》 《半小时漫画中国史》 《近忧远虑》 《硬派健身》最早看到斌卡是在知乎上的答题。这本书的主题的减肥篇。从理论和实际出发为读者提供相对应的对策。印象最深的是我一直做的深蹲的方法都是错的。而且我也从这里明白了一个道理：管住嘴，迈开腿;七分吃，三分动。这才是减重的真理！消耗大于输出才是减重唯一的标准。而且吃真的很重要，不是少吃，而是会吃。两个月瘦了快二十斤，学习的也很多。这个要说起来感觉能说一篇新文章。嗯，坚持也很重要！我的flag也没倒！ 《人类简史》这是本好书，值得花时间再去细读，颠覆了许多以前的观点。高中物理老师说过的话，我们为什么要学物理？就是要用现有的东西去推测未来。学校学习都是潜移默化。现在受力分析估计已经不会了，但是老师的这话我就记住了，还觉得越来越有道理。 部分书摘 1.因为一旦人们发现历史能证明乐无常态而知足常乐，发现我们过去对快乐的历史认知可能都是错的，发现对快感的执着追求可能只会适得其反地导致痛苦，那么我们就有可能走向对自己的真正理解，也就可能知道自己想要的究竟是什么了。 2.所以，究竟智人是怎么跨过这个门槛值，最后创造出了有数万居民的城市、有上亿人口的帝国？这里的秘密很可能就在于虚构的故事。就算是大批互不相识的人，只要同样相信某个故事，就能共同合作。 3.人类和黑猩猩之间真正不同的地方就在于那些虚构的故事，它像胶水一样把千千万万的个人、家庭和群体结合在一起。这种胶水，让我们成了万物的主宰。 4.种种想让生活变得轻松的努力，反而给人带来无穷的麻烦；而且这可不是史上的最后一次。就算今天，仍然如此。有多少年轻的大学毕业生投身大企业、从事各种劳心劳力的工作，发誓要努力赚钱，好在35岁就退休，去从事他们真正有兴趣的事业？但等他们到了35岁，却发现自己背着巨额贷款，要付子女的学费，要养在高级住宅区的豪宅，每家得有两部车，而且觉得生活里不能没有高级红酒和国外的假期。他们该怎么做？他们会放下一切，回去野外采果子挖树根吗？当然不可能，而是加倍努力，继续把自己累得半死。 5.人际关系和政治对立都是长期的事，无论报恩或报仇，常常都要花上好几年的时间。然而，在狩猎和采集这种自给自足的经济里，要做这种长期规划就会受到客观条件的限制。但说来也有趣，这让采集者省下了许多不必要的忧虑。毕竟，如果是那些无法影响的事，就算担心也没用。 6.历史只告诉了我们极少数的人在做些什么，而其他绝大多数人的生活就是不停挑水耕田。 7.支持它们的社会规范既不是人类自然的天性本能，也不是人际的交流关系，而是他们都相信着共同的虚构神话故事。 8.伏尔泰就曾说：“世界上本来就没有神，但可别告诉我的仆人，免得他半夜偷偷把我宰了。” 9.一如古埃及精英分子，现在大多数人一生汲汲营营，也都是想盖起某种金字塔，只不过这些金字塔在不同文化里会有不同的名字、形体和规模罢了。 10.自从法国大革命之后，全球人民逐渐同意“自由”和“平等”都是基本的价值观。然而这两者根本就互相抵触！想要确保“平等”，就得限制住那些较突出的人；而要人人都能“自由”，也就必然影响所有人的平等。 11.自从法国大革命之后，全球人民逐渐同意“自由”和“平等”都是基本的价值观。然而这两者根本就互相抵触！想要确保“平等”，就得限制住那些较突出的人；而要人人都能“自由”，也就必然影响所有人的平等。 12.某些社会的解决方式，就是建立起集中的以物易物系统，分别从各个专业的农夫和制造商那里取得产品，再统一分配到最需要的人手上。这种社会规模最大、名声最著的就是苏联；不过最后可以说是凄惨收场。原本声称要让人人“各尽所能、各取所需”，但结果是“各尽所能的最小值，各抢所需的最大值” 13.金钱正是有史以来最普遍也最有效的互信系统。 14.所有人类创造的信念系统之中，只有金钱能够跨越几乎所有文化鸿沟，不会因为宗教、性别、种族、年龄或性取向而有所歧视。也多亏有了金钱制度，才让人就算互不相识、不清楚对方人品，也能携手合作。 15.现代西方认为所谓公义的世界应该是由各个独立的民族国家组成，但古代中国的概念却正好相反，认为政治分裂的时代不仅动荡不安，而且公义不行。这种看法对中国的历史产生深远的影响。每次一个帝国朝代崩溃，这种政治理论主流就让各方竞逐的势力不安于各自为政，而一心追求统一。而且事实证明，最后总能统一，只是时间早晚的问题。 16.我们看到有几百万虔诚的基督徒、穆斯林和犹太人居然能够相信既有全能的神，又有独立行事的魔鬼，倒也不用太过惊讶。更有甚者，无数的基督徒、穆斯林和犹太人居然还能想象善神需要人类的协助，好与魔鬼对抗，由此再推导引发了圣战和十字军东征。 17.释迦牟尼认为，人遇到事情通常就会产生欲念，而欲念总是会造成不满。遇到不喜欢的事，就想躲开；遇到喜欢的事，就想维持并增加这份愉快。但正因如此，人心就永远不满、永远不安。这点在碰上不悦的时候格外明显，像是感觉疼痛的时候，只要疼痛持续，我们就一直感到不满，用尽办法想要解决。然而，就算是遇上欢乐的事，我们也从不会真正满足，而是一直担心这种欢乐终将结束或是无法再持续或增强。有些人多年来一直在寻找爱情，但等到真的找着了爱情，却还是不满足。有的开始整天担心对方可能会离开；有的又觉得自己太过屈就，应该再找更好的人。 18.释迦牟尼找到一种方法可以跳出这种恶性循环。在事物带来快乐或痛苦的时候，重点是要看清事物的本质，而不是着重在它带来的感受，于是就能不再为此所困。虽然感受悲伤，但不要希望悲伤结束，于是虽然仍有悲伤，也能不再为此而困。即使仍然悲伤，也是一种丰硕的经验。虽然感受快乐，但不要希望快乐继续，于是虽然仍有快乐，也能不失去心中的平静。 19.释迦牟尼将冥想落实在各种道德规范上，好让信众更能专注在实际的感受，而不会落入各种欲求和幻想之中。他要求信众不杀生、不邪淫、不偷盗，因为这些作为一定会让欲望如野火燎原，而一心追求权力、感官享受或财富。等到这些火焰彻底扑灭，原本的欲求就换成了圆满和寂静，称为涅槃（梵文的原义就是“熄灭”）。达到涅槃，也就是解脱了所有苦痛，能够无比清晰地感受身边的现实，没有什么幻想和幻象。虽然人们很有可能还是会遇到苦痛，但苦痛已经不再能影响他们。毕竟，无欲则无苦。 20.我们之所以研究历史，不是为了要知道未来，而是要拓展视野，要了解现在的种种绝非“自然”，也并非无可避免。未来的可能性远超过我们的想象。 21.在公元1500年，人类还被局限在地面上。虽然可以盖起高塔、爬上高山，但天空仍然是专属于飞鸟、天使和神的领域。而到了1969年7月20日，人类登陆月球。这不只是一项历史成就，更是一项演化上甚至是宇宙间的壮举。在过去40亿年演化期间，没有任何生物能够离开地球大气层，更不用谈要在月球上留下手印或足迹。在地球上，微生物占了全部有机体大约99.99%，但人类要到非常晚近，才对微生物有所认识。这并不是因为微生物与我们无关，相反的是，我们每个人身上都有数十亿个单细胞生物，而且还不只是搭搭便车的关系。微生物可以说是我们最好的朋友，也是最致命的敌人。有些微生物可以帮助消化、健胃整肠，而有些则会导致疾病、造成感染。一直要到1674年，才有人第一次真正看见了微生物。当时安东·冯·列文虎克（Anton van Leeuwenhoek）自制了一台显微镜，用来观察一滴水，他看到里面有许多小生物动个不停，这让他大吃一惊。在随后的300年间，人类才开始认识了许许多多的微生物物种。时至今日，我们已经能够治疗大多数由微生物造成的致命传染病，也能够将微生物用于医疗和产业用途。像是我们可以用细菌来制造药物、生物燃料，或是杀死寄生虫。 22.你觉得这些帝国就是邪恶的怪物，在全球各地四处散播死亡、压迫和歧视吗？随便把他们的罪行列出来，就足以编成一部百科全书了。你觉得这些帝国其实为属民提供了新的医药、更佳的经济环境、更多的安全吗？随便把他们的成就列出来，也足以编成另一部百科全书。正因为帝国与科学密切合作，就让它们有了如此强大的力量，能让整个世界大为改观；也是因为如此，我们很难简单断言它们究竟是善是恶。正是帝国创造了我们所认识的世界，而且，其中还包含我们用以判断世界的意识形态。 23.对快乐与否的影响，家庭和社群要比金钱和健康来得重要。 《腾讯传》立志成为一位优秀码农的我当然对腾讯的发家史很感兴趣。没有一种成功的是不努力的。运气真的很重要很重要很重要。有很多话想说，但是还觉得应该做好自己现在的事情。踏实，坚韧，高瞻远瞩。实用的道理往往最简单。 部分书摘 1.“Pony喜欢开长会，每一个议题提出后，他都不会先表态，而是想要听到每一个人的态度和意见，所以会议往往开得很漫长。” 2.此时的马化腾，还没有学会如何在公众面前表现幽默感。在接受采访时，他除了描绘腾讯的“远大前程”之外，重点介绍了上个月25日推出的QQ新版本。在这个升级版本中，第一次出现了群聊功能。这个功能的灵感来自于腾讯内部的“饭友团”文化。那时候，腾讯内部存在很多“饭友团”，中午下班前大家通过邮件讨论并决定午餐如何解决，由于邮件存在延迟，且回复意见比较混乱，很难迅速达成一致意见，经常还会出现人员遗漏问题。针对这些问题，便有人提出这样一个设想：“能不能在QQ上面建立一个固定的人员列表，列表中人员可以同时参与即时讨论呢？” 3.中国社会历来是一个充满了压抑感的等级社会，它既表现在宗族的内部，也体现在公共社会层面，人们在现实生活中战战兢兢，情感生活十分苍白和乏味。而虚拟社区的出现，如同一个突然出现的新世界，让压抑日久的人们可以戴着面具，实现一次不需要节制的狂欢。中国人在现实中的含蓄与在虚拟中的狂放构成了一个十分鲜明和讽刺性的反差。 4.从此以后，产品经理制被确立了下来，“谁提出，谁执行”“一旦做大，独立成军”成为腾讯内部不成文的规定。这一新模式无形中造就了“赛马机制”，我们将看到，后来为腾讯带来众多“意外”的创新，如QQ空间、QQ游戏乃至微信，都不是顶层规划的结果，而是来自基层的业务单元的独立作业。工程师文化与产品经理制在内在的驱动力上有天然的冲突性，然而，却在腾讯实现了无缝融合。 5.在一次飞行旅途中，筋疲力尽的刘炽平闭目斜躺在座位上，邻座的陈一丹突然把他拍醒，提出一个邀请：“喂，你愿意加入腾讯吗？”在上市筹备过程中，刘炽平的聪明、坚毅和快速学习能力得到了腾讯创始人团队的一致认可，“土鳖+洋龟”结合产生的化学作用更是值得期待。 6.在2004年6月的那场记者见面会上，丁磊还带来一个爆炸性的武器，他宣称网易已研制成功一款类似于Skype的即时语音沟通工具，“我们真正的突破点是在任何环境下均可通信，语音质量达到了GSM的质量，下一版本我们的语音通信质量会超过电话的通信质量。网易在实验网中已完全通过测试，跟传统电话互通在技术上完全没问题。而且现在这个版本的泡泡已有这样的功能，软件已装在里面了，只要政策允许就可推出”。这是一个值得被记录下来的事实，它表明，中国的互联网企业早在2004年就完成了即时语音通信上的重大突破，若非遭到国有的电信运营商的蛮横阻挠，2011年的微信将早出生7年，而且这个机会应该属于丁磊的网易。 7.紧盯市场动态，以最快的方式复制成功者模式，利用QQ用户优势进行后发超越。 8.“后发是最稳妥的方式” 9.“高级别的文明体从来都是在异常困难而非异常优越的环境中降生的。挑战越大，刺激越强”。 10.“Don’t make me think！” 11.创新亦非来自于实验室，而是市场的不断变换的需求。 12.“成功的秘诀，在于把自己的脚放入他人的鞋子里，进而用他人的角度来考虑事物，服务就是这样的精神，站在客人的立场去看整个世界。” 13.任何产品都有核心功能，其宗旨就是能帮助到用户，解决用户某一方面的需求，如节省时间、解决问题、提升效率等。核心能力要做到极致。要多想如何通过技术实现差异化，让人家做不到，或通过一年半载才能追上。 14.我们希望的产品经理是非常资深的，最好是由做过前端、后端开发的技术研发人员晋升而来。 15.过去，我们总在思考什么是对的。但是现在，我们要更多地想一想什么是能被认同的。 16.“挑战者必须找到不同于领先者的新竞争方式以取得成功” 17.张小龙指尖夹着KENT牌香烟，在自己的腾讯微博上打下了一行烟雾缭绕的“心情”：我对iPhone 5的唯一期待是，像iPad（3G）一样，不支持电话功能。这样，我少了电话费，但你可以用kik跟我短信，用Google Voice跟我通话，用Facetime跟我视频。 18.“如果你说我是错的，你要证明你是对的。” 《创京东》如果说BAT都有种种光环，那么京东绝对算上是逆袭的了。志之所趋，无远弗届，穷山距海，不能限也。 部分书摘 1.过去京东的唯一推广方式就是给用户打折，那是赚今天的钱；打广告则是赚明天的钱。 2.京东的策略就是，我是老大，我有钱，你没钱，咱们就耗着，耗到市场不好的时候，你们没钱就得死。 3.在京东董事会，要么你说服我，要么我说服你，如果谁也不能说服谁，就投票。9个席位，刘强东代表5席。 4.身在历史潮流中，不允许犹豫，快速决策比决策正确与否更重要。 5.人的本性是向善的，总愿意往好的方向发展，就看企业给不给他这样的土壤。如果给他良好的平台，人会有积极、正向的行动；如果平台糟糕，做出来的绩效不被认可，就有劣币驱逐良币的风险。 6.电商要颠覆渠道格局，至少要占30％。最后一公里的配售解决了，局就破了。 7.中国教育让刘强东从小养成寻找唯一答案的思维方式：黑与白、好与坏、对与错。 8.他原来是要做一件事，先找合适的人来做，实在找不到就自己做；现在是先想找什么样的人，这些人会思考什么是对的事，如何把它做好。 9.腾讯从2004年开始做拍拍网，在时间上没有落后阿里巴巴多少，但两者的决心是天壤之别。那时候，淘宝是阿里巴巴的全部未来，阿里巴巴会调动最好最多的资源；而腾讯只是觉得是个机会，做好了很好，做不好也不影响大局。 10.总结电商未来三大趋势或者三大利润增长点，无非三个，生鲜、跨境电商、O2O。 《毛泽东传》一代伟人，有功有过。 对于毛主席我无法评价，但是伟大是必然的。虽然是一本由外国人写的传记。但是作者的思路和翻译的文笔都堪称经典。王侯将相宁有种乎？一个农民的儿子成为几亿人的神，最终又回到了人的本位。毛主席惊世骇俗却也无法超发脱俗。里面很多简单叙述仔细琢磨，都是经过了深刻的思考才能表达的人生哲学。 其实还是有一些疑问的，人真的只有断了七情六欲才能成大事吗？ 发现书中的一个细节。他的第一任妻子杨开慧带着孩子在老家，在没有离婚的情况下他在井冈山娶了贺子珍，后来贺子珍精神出问题被送去治疗，又在没有离婚的情况在延安下娶了江青。他的孩子们也没有得到童年应有的父爱。这究竟是怎么的一种性格。 部分书摘 1.“记下随时产生的想法，自由地表达我们想到的东西，这样可以帮助我们保持平衡。” 2.“世界上有两种人，”有一天毛泽东对萧三说，“一种人善于做具体事情，一种人善于做组织工作。前者要多于后者。但是，每个人都有他的长处。” 3.毛泽东在一次集会上发表演说，主题是“使用国货，抵制日货”，完全不顾中国产品不能满足人民需要这一事实。他组织了女生小队（从一开始他就把妇女纳入了湖南学生联合会的核心组织之中）去检查长沙的商店，声色俱厉地警告店主们毁掉日本的进口货。 4.他组织工会，发动了十多次重要罢工。他还不时地悄悄成立新的党小组。工作很有成效，两年之内在湖南成立了拥有5万工人的20个工会。经过仔细和谨慎挑选的湖南中共基层党员，从1921年年中的10名，猛增到一年后的123名。每当一个新工会建立起来，毛泽东就设法安插一个中共干部做它的书记。 5.在1946年，国民党占有中国南方的全部以及贫瘠的、人烟稀少的遥远西部。共产党在北方势力强大。毛泽东的部队在人力上是蒋介石的三分之一，在武器上是五分之一。注：这里想到高晓松讲到的一个历史规律：历史的大概率事件，都是某个政权从北方开始统一全国。 《人民的名义》被改编的电视剧大火，而书里写的却更加深刻。想到上一本书里毛主席晚年的思想：这不是一个物质的世界，唯物并不显得那么真理，而是一个人与人关系的世界。 部分书摘 1.人在倒霉时，才懂得友谊的可贵。 2.能力之外的一切资本都等于零！ 3.”油气集团是国家的，全民所有制，全民所有就是全民没有！” 4.世事开始变得多少有些陌生，也许是人与人的关系改变了。 5.这位省委书记难啊，领导着一个六千万人的大省，相当于欧洲一个大国，他要不疲惫而是活得轻松愉快，反倒让人奇怪了。 6.好在我们党已经醒了，现在收拾世道人心还来得及. 《我与地坛》我已不在地坛，地坛在我。 初始史铁生在初中。这次才算是全部读完。整本书的思辨能力真的是太强大了。描写他与母亲的种种画面，真的是刺痛我心了。被身残的悲痛笼罩而忽略母亲的“愧疚”。必须活下去的“无奈”，天地间孓然苍凉的“孤寂”。 部分书摘 1.要是有些事我没说，地坛，你别以为是我忘了，我什么也没忘，但是有些事只适合收藏。不能说，也不能想，却又不能忘。它们不能变成语言，它们无法变成语言，一旦变成语言就不再是它们了。它们是一片朦胧的温馨与寂寥，是一片成熟的希望与绝望，它们的领地只有两处：心与坟墓。比如说邮票，有些是用于寄信的，有些仅仅是为了收藏。 2.一个人，出生了，这就不再是一个可以辩论的问题，而只是上帝交给他的一个事实；上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。这样想过之后我安心多了，眼前的一切不再那么可怕。比如你起早熬夜准备考试的时候，忽然想起有一个长长的假期在前面等待你，你会不会觉得轻松一点儿？并且庆幸并且感激这样的安排？注：对未发生的事情毋需忧虑，因为还有可以努力的机会;对一定会发生的事情也毋需忧虑，因为它迟早要来。 ３.剩下的就是怎样活的问题了。这却不是在某一个瞬间就能完全想透的，不是能够一次性解决的事，怕是活多久就要想它多久了，就像是伴你终生的魔鬼或恋人。 4.那些年我们俩常一起在这园子里待到天黑，开怀痛骂，骂完沉默着回家，分手时再互相叮嘱：先别去死，再试着活一活看。 5.其实总共只有三个问题交替着来骚扰我，来陪伴我。第一个是要不要去死，第二个是为什么活，第三个，我干吗要写作。 《鱼羊野史》《鱼羊野史》这本书是我最近一段时间看的，作者高晓松，书大概有1400多页，类似于每天一个小故事，适合睡前读一读。从《晓说》到《晓松奇谈》再到优酷新开的《晓说》，以及这本书，都能展示出高晓松极高的造诣。关于他的家庭，折射出近代的一些变迁。从脱口秀到这本书，矮大紧总是能以一种新的角度去看一些事情，反而觉得很有趣。关于历史，关于人类以及这个世界上其他有趣的事情。印象最深的是《晓松奇谈》里的《胜利下的阴影》，另一个角度去看二战和战争，战争和胜利都很触目惊心。这本书历史和艺术涉猎都非常之广泛和有趣，但是某些方面确实也有偏差。总之，还是要接着和矮大紧老师学习的。 部分书摘 1.燕大的校训是“因自由，得真理，以服务”。大学不该是一个职业培训班，不是为了毕业找一工作，大学是让国家相信真理的最后阵地。 2.当时北京要拆城墙，由北京市副市长、原清华历史学教授吴晗先生来主持，谦谦君子梁先生听到这个消息默默哭泣，而林先生指着吴晗破口大骂：“你们拆去的是真古董！你们迟早会后悔的，到时候你们要盖的是假古董。而且你是历史学教授，你知道什么是历史，这么多年的历史毁于一旦！” 3.“老兵不死，只是慢慢消失。” 4.美国人是全世界最适应市场经济的人民，很少有这种壁垒观念，也没说IBM被中国并购就不买这个产品了。 5.其实学校就是这样，读书的时候，你并没有觉得这个学校有多么美好，但是你来到社会上，尤其到了四十岁，你才慢慢觉得学校带给你的东西真的很多 6.泰国在二战中也加入了轴心国，由于它既不骁勇也不善战，虽然加入了轴心国，但也没作什么恶，没犯下什么反人类的罪行，所以大家也没把它怎么样。二战之后它又恢复了“暹罗”这个名字，但是到了1949年的这一天，民族主义战争爆发了，又改名叫“泰国”。 7.历朝历代统一基本上都是北方统一南方，秦，晋，隋，元，清，当然还有我朝。明是唯一一个从南打到北，统一中原的王朝，不过有明一朝一直受到北元的骚扰，也可以说，并没有完成全国统一。所以，王师北定中原基本上是不太可能出现的。 8.小说的最后还描写雨连续下了四个月，住在树下的人身上都长了青苔。这种描述让你觉得整个人生、整个生活不但是孤独的，而且是远离人群的。 9.艺术和科学是人类最重要的两条平行线，一直是你追我赶地在向前发展。今天的这个时代是科技远远领先的时代，而艺术经常会在科学遇到阻碍的时候有较快发展，比如在战争等对人类造成重大伤害之后，科技的发展会暂时停下来，而艺术的发展就会追上去。 10.经常也突然就没掉了活着的意愿和意思。那些接近星空的人是会明了着选择结束生命，完成自己亲手处理的意愿吧。于他们自己来说，并非灰色。注：持续保持输出本身就是一种消耗。 11.在近代化的进程中，原本我们可以启动得更早，却都落在日本的后面，这就是酿成另一场更大的悲剧——甲午战争的惨败的一大原因。人生如大国决策，关键时刻，面临多项选择。或照本宣科，或行出自己的车辙。若骄奢，不尽早褪去青涩，便必落马于曲折。 12.当时红星签了一个叫许巍的歌手，之前谁都没听说过这个人，只知道他来自西安。我们那时对西安有一种特别美好的想象，因为大家知道西安来的张楚、西安来的郑钧，现在西安又来了一个人，所以都特别感兴趣，于是好多人就跑到“旅游棚”里去听他唱歌。 13.1976年是中国的多事之秋，我们的毛主席、周总理、朱总司令都是在那一年去世的，再加上唐山大地震，这应该是新中国历史上最惨痛的一年吧。 就这些吧。读书是闲暇时间的乐趣，是消耗时间的“毒品”。看到知乎上一个问题，”读书的意义是什么？”下面的高票回答，觉得很棒，分享引用。 杨绛先生的父亲有一次问杨绛：“阿季，三天不让你看书，你怎么样?”她说：“不好过。”“一星期不让你看书呢?”她说：“一星期都白活了。”父亲笑了，说：“我也这样。”很多人都爱追问读书的意义、读书的用处，其实真正手边不离书的人，很少这样问。因为读书对于真正爱书的人来讲，就如同吃饭睡觉，必须却也凡常，没什么特别需要追问的意义和用处。读书就读书，可以体验乐趣，但不必去强调意义。不读书就不读书，一点儿也不丢人，人各有追求、各有所爱，很正常，但是不必去强调你是为什么才不读书（累、没时间、没精力、家里地方小没地儿摆书…）也更不要去否定读书这件事本身。真正离不开书的人，书就是很平常的生活必需，没什么特别的意义，就像人处在什么境况下都会去吃饭睡觉，饭上餐桌，你落座，拿起筷子之前大概不会去特别地思考一下“我为什么吃饭？吃完了还要排泄，那么吃饭到底有用没用？吃饭的真正意义是什么？我吃了这一口我能得到什么，下一口又能收获什么？” 读书也是这样，如果必须问一个意义，那么于爱她的人来说，她最重要的意义或许就是“陪伴”以及“丰富”，手边有书，就永远不孤独、不乏味，书里有比眼睛里更生动的世界。世间许多事从来都如此，当我们执着追寻它的意义的时候，就已经失去了它所能带给我们的最珍贵的东西。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构笔记（一）]]></title>
    <url>%2F2017%2F06%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[第1章 数据结构绪论第2章 算法第3章 线性表 第1章 数据结构绪论 程序设计 = 数据结构 + 算法 逻辑结构与物理结构逻辑结构 集合结构 线性结构 树形结构 图形结构 物理结构 物理结构：是指数据的逻辑结构在计算机中的存储形式。 顺序存储结构：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 第2章 算法算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 算法的特性 输入输出：有零个或多个输入，至少有一个或多个输出。 有穷性 确定性 可行性 算法设计的要求 正确性 可读性 健壮性 时间效率高和存储量低 算法时间复杂度定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间度量，记作：T(n) = O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。这样用大写O()来体现算法时间复杂度的记法，称之为大O记法。 推导大O阶 用常数1取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是1，则去除与这个项相乘的常数。得到的结果就是大O阶。 常用的时间复杂度所消耗的时间从小到大依次是：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n(2)) &lt; O(n(3)) &lt; O(2(2)) &lt; O(n!) &lt; O(n(n)) 算法的空间复杂度算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。 第3章 线性表线性表(List)：零个或多个数据元素的有限序列。 a(i-1)是a(i)的直接前驱元素，a(i+1)是a(i)的直接后继元素。 线性表的抽象数据类型定义12345678910111213141516171819ADT 线性表（List）Data 线性表的数据对象集合为&#123;a1,a2,...,an&#125;,每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。Operation InitList(*L):初始化操作，建立一个空的线性表L。 ListEmpty(L):若线性表为空，返回true，否则返回false。 ClearList(*L):将线性表清空。 GetElem(L,i,*e):将线性表L中的第i个位置元素返回给e。 LocaEleme(L,i,*e):将线性表L中查找与定位值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。 ListInsert(*L,i,e):在线性表L中的第i个位置插入新元素e。 ListDelete(*L,i,e):在线性表L中的第i个位置元素，并用e返回其值。 ListLength(L):返回线性表L的元素个数。endADT 线性表的顺序存储结构 顺序存储定义：指的是用一段地址连续的存储单元依次存储线性表的数据元素。 顺序存储方式：一维数组来实现顺序存储结构。 线性表的顺序存储的结构代码:1234567#define MAXSIZE 20 /*存储空间初始分配量*/typedef int ElemType;/*ElemType类型根据实际情况而定，这里假设为int*/typedef struct&#123; ElemType data[MAXSIZE];/*数组存储数据元素，最大值为MAXSIZE*/ int length;/*线性表当前长度*/&#125;SQList; 顺序存储结构需要三个属性： 存储空间的起始位置：数组data,它的存储位置就是存储空间的存储位置。 线性表的最大存储容量:数组长度MaxSize。 线性表的当前长度：Length。 用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入好人删除操作，因此分配的数组空间要大于等于当前线性表的长度。 存储器中的每个存储元素都有自己的编号，这个编号成为地址。 顺序存储结构的插入与删除 获得元素操作实现GetElem操作，将线性表L中的第i个位置元素值返回。就程序而言，只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。12345678910111213141516#define ok 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;Status是函数的类型，其值是函数结果状态代码，如OK等初始条件：顺序线性表L已存在，1&lt;= i &lt;= ListLength(L)操作结果：用e返回L中第i个数据元素的值Status GetElem (SqList L, int i, ElemType *e)&#123;if(L.length==0 || i&gt;L.length) return ERROR; *e=L.data[i-1]; return OK;&#125; 插入操作插入算法的思路： 如果插入位置不合理，抛出异常； 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量； 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置； 将要插入元素填入位置i处； 表长加1；代码实现： 12345678910111213141516171819初始条件：顺序线性表Ｌ已存在，１&lt;= i &lt;= ListLength(L)操作结果：在L中第i个位置之前插入新的数据元素e,L的长度加1Status ListInsert(SqLsit *L, int i,ElemType e)&#123;int k; if (L-&gt;length == MAXSIZE)/*顺序线性表已经满*/ return ERROR; if(i&lt;1 || i&gt;L-&gt;length+1)/*当i不在范围内时*/ return ERROR; if(i&lt;=L-&gt;length)/*若插入数据位置不在表尾*/ &#123; for(k=L-&gt;length-1;k&gt;=i-1;k--)/*将要插入位置后数据元素向后移动一位*/ L-&gt;data[k+1] = L-&gt;data[k]; &#125; L-&gt;data[i-1] = e;/*将新元素插入*/ L-length++; return OK;&#125; 删除操作算法思路： 如果删除位置不合理，抛出异常; 取出删除元素; 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置; 表长减1. 线性表顺序存储结构的优缺点 优点 无须为表示表中元素之间的逻辑关系而增加额外的存储空间 可以快速的存取表中任一位置元素 缺点 插入和删除操作需要移动大量元素 当线性表长度变化较大时，难以确定存储空间的容量 造成存储空间的”碎片” 线性表的链式存储结构为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称为指针或链。数据域 + 指针域 = 结点 链表中第一个结点的存储位置叫做头指针，最后一个结点指针为“空”，用NULL或^表示。 头指针与头结点的异同头指针 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针 头指针具有标示作用，所以常用头指针冠以链表的名字 无论链表是否为空，头指针均不为空。头指针是链表的必要元素。 头结点 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度） 有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作系统就统一了 头结点不一定是链表必须要素 单链表的读取获取链表第i个数据的算法思路 声明一个结点p指向链表第一个结点，初始化j从1开始； 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1； 若到链表末尾p为空，则说明第i个元素不存在； 否则查找成功，返回结点p的数据。 单链表的插入与删除单链表第i个数据插入结点的算法思路 声明一节点p指向链表第一个结点，初始化j从1开始； 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1； 若到链表末尾p为空，则说明第i个元素不存在； 否则查找成功，在系统中生成一个空结点s； 将数据元素e赋值给s-&gt;data； 单链接的插入标准语句s -&gt; next = p -&gt; next; p -&gt;next = s; 返回成功。 单链表第i个数据删除结点的算法思路 声明一节点p指向链表第一个结点，初始化j从1开始； 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1； 若到链表末尾p为空，则说明第i个元素不存在； 否则查找成功，将欲删除的结点p-&gt;next赋值给q; 单链表的删除标准语句p-&gt;next = q-&gt;next； 将q结点中的数据赋值给e，作为返回； 释放q结点； 返回成功。 对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显 单链表的整表创建单链表整表创建的算法思路: 声明一结点p和计数器变量i； 初始化一空链表L; 让L的头结点的指针指向NULL，即建立一个带头结点的单链表； 循环 生成一新结点赋值给p； 随机生成一数字赋值给p的数据域p-&gt;datd; 将p插入到头结点与前一新结点之间。 ### 单链表的整表删除 单链表整表删除的算法思路如下： 声明一结点p和q； 将第一个结点赋值给p； 循环 将下一结点赋值给q； 释放p; 将q赋值给p。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【更正】Java调用Python]]></title>
    <url>%2F2017%2F06%2F05%2F%E3%80%90%E6%9B%B4%E6%AD%A3%E3%80%91Java%E8%B0%83%E7%94%A8Python%2F</url>
    <content type="text"><![CDATA[错误一错误二之前两篇博客都讨论过这个问题，现在才算是弄清楚了。 这个反转真的是。。。够了。。。 还需要学习啊。 JAVA to Python关于Java如何调用Python的问题方法一：Java自带函数gettime.runtime.exe()功能：模拟cmd命令行。例如：12String s = "python C:/Python27/py/studentInf/all.py" + " " + stuId + " " + stuPassword + " " + userId + " " + schoolId;Process process = Runtime.getRuntime().exec(s); Python接收参数:12import sysxs.login(sys.argv[1], sys.argv[2]) 方法二：利用jython.jar该方法可以解决传递形参的问题。也可以执行Python程序。遇到的问题：需要确定好jython的路径问题和其他设置的路径问题。 注意：该方法只适用Python2。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Python</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pip无法正常使用解决办法]]></title>
    <url>%2F2017%2F06%2F05%2Fpip%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E4%BD%BF%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[解决办法：python -m pip install xxx相当于import,叫做当做模块来启动]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse导入文件乱码问题]]></title>
    <url>%2F2017%2F06%2F05%2Feclipse%E5%AF%BC%E5%85%A5%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[首先导入的文件成为了乱码是因为workspace的编码方式不对linux下默认编码是UTF-8，windows的是GBK， 那么怎么修改workspace的编码方式呢很简单在window—-preference—workspace可以设置只要把编码改成utf-8就可以喽]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三季人]]></title>
    <url>%2F2017%2F06%2F03%2F%E4%B8%89%E5%AD%A3%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[夏虫不可以语冰，不做价值评断和道德审判。 早晨，子贡在大院门口打扫院子。有人来到，问子贡：“您是孔子吗？”子贡答道：“有什么事需要向我们老师请教？”“我想请教关于时间的问题？”“这个问题我知道，可以回答你”“那你说说一年有几季？”“四季。”子贡笑答。“不对，一年只有三季！”“四季！！” 、“三季！！”“四季！！！”子贡理直气壮。“三季！！！”来人毫不示弱。然后就争论不止，一直争论到中午也没消停。孔子听到声音，从院内出来，子贡上前讲明原委，让孔子评定。孔子先是不答，观察一阵后说：“一年的确只有三季。”来人听此，大笑而去。待来人走后，子贡忙问老师：“这与您所教有别啊，且一年的确有四季啊！”“这一年到底应是几季？”孔子答：“四季”子贡不解。孔子继而说道：“这时和刚才不同，方才那人一身绿衣。他分明是田间的蚱蜢。蚱蜢者，春天生，秋天亡，一生只经历过春、夏、秋三季，哪里见过冬天？所以在他的思维里，根本就没有‘冬季’这个概念。你跟这样的人那就是争上三天三夜也不会有结果的。你若不顺着他说，他能这么爽快就走吗？你虽然上了个小当，但却学到了莫大一个乖。”说完，子贡立刻明白了。 一大多数总是以社会大众心中对善恶的标准来看待周围的事物：“一件事情应该是什么样子”。实则是在道德审判上也盲目从众。知之为知之，是知也。但并不是知无不言言无不尽才是最好的。 二哪些人是强势，哪些人是弱势，哪些值得同情，哪些不是好人。从一开始对善恶都有一个预设，然后用各种的例子来说服自己和其他人。根本没有脱离了程序正义以外的所谓实质正义。站在不同的立场上，事情可能变得完全不同。 三道德本来就是一个见仁见智的东西。大部分的道德标准，不算是与生俱来带有合理性的。而是默认的一种规则，这种规则不一定是正确的。道德不一定是理性的产物。 四最近听到一个朋友诉说了一些事情。让我觉得生活真的好难，让自己快乐也许才是最重要的。人也需要有独立思考的能力，这一点很重要。并不是别人说风就是雨，要有自己的判断。 五快乐的前提是看待一切事物都能以积极的心态。平常心，不抱怨，不争吵。少做价值评断和道德审判。不想自己也成为别人眼中的三季人。 六试着努力去体会所谓的精神。好的生活习惯和积极的进取心态，知行合一。说到做到才是执行力的最大体现。嗯，我瘦了二十斤。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC编程]]></title>
    <url>%2F2017%2F05%2F31%2FJDBC%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[JDBC： Java Database Connectivity一、数据库基础知识二、MySQL入门三、JDBC编程 一、数据库基础知识1、关系数据模型：术语 关系：一张二维表 元祖：表中的一行 属性：表中的一列 属性域：属性的取值范围 主键：唯一的表示表中的元祖 外键：一个关系中包含另一个关系的主键 范式：范式：数据库设计需要满足的规范. 1NF：对属性的原子性约束，不可再分解。不能有嵌套表。 2NF: 对记录的唯一性约束，要求记录有唯一标示，实体必须是唯一的。所有的主键字段都要依赖与非主键字段。 3NF：对字段冗余性的约束，要求任何字段都不能派生于其他字段。也就是说非主键字段直接不能相互依赖。 二、MySQL入门1、MySQL数据类型简介整数 TINYINT：1个字节，8位 SMAILLINT：2个字节，16位 MEDIUMINT：3个字节，24位 INT：4个字节，32位 BIGINT：8个字节，64位 实数（带有小数部分的数字） FLOAT：4个字节，32位 DOUBLE：8个字节，64位 DECIMAL：存储精确的小数，指定小数点前后的位数。eg.DECIMAL（20，2），表示小数点后存储两个数字，小数点前存储18个数字。 字符串 VARCHAR:用于保存可变长度的字符串。 CHAR:固定长度的字符串。0~255任意值。 TEXT、BLOB：存储较长的字符串。 日期 DATETIME：保存大范围的值，从1001~9999年，精度为秒。8个字节。 TIMESTAMP：时间戳类型，1970.1.1~2038年，即格林威治时间到现在所经历的秒数。4个字节。 数据类型选择准则 最小原则 简单原则 避免索引列上的NULL 三、JDBC编程1、JDBC简介JDBC概述 ODBC(Open Database Connectivity) JDBC(Java Database Connectivity) JDBC的组成 JDBC API:面向开发人员 JDBC Driver API：面向底层驱动开发商 JDBC Driver API主要编程接口： DriverManager：装载驱动程序，并为创建数据库连接提供支持 Connection:连接某一指定的数据库 Statement：执行SQL语句，获取查询结果的方法。 JDBC驱动程序主要有四种类型： JDBC-ODBC bridge 部分Java技术的本地API驱动程序 全部基于Java技术的本地API驱动程序 全部基于Java技术的本地协议驱动程序 2、JDBC编程之数据准备建两张表：12345678910111213141516creat table tbl_user(id int(11) unsigned not null auto_increment,name varchar(50) not null default '',email varchar(50) nit null default '',primary key(id))engine = InnoDBdefault charset = utf8;creat table tbl_address(id int(11) unsigned not null auto_increment,city varchar(20) default null,country varchar(20) default null,primary key (id))engine = InnoDBdefault charset = utf8; 注：1234id:没有业务含义的逻辑主键auto_increment：自增长default '' ：默认值为空字符串engine = InnoDB：设置MySQL的存储引擎，InnoDB是存储引擎的一种，支持事物。 插入数据：12345678910insert into tbl_user(id, name, password, email)values(1, 'xiaosa', '123456', 'xiaosa.nicolo@qq.com'),(2, 'nicolo', '123456', '1241251168@qq.com');insert into tbl_address(city, country, user_id)values('xian', 'china', 1);insert into tbl_address(city, country, user_id)values('beijing', 'china', 2); 3、JDBC编程之数据查询安装驱动，下载mysql-connector-java。将mysql-connector-java-5.1.42-bin.jar包拷到WEB-INF目录下。 JDBC编程流程 加载驱动 打开连接 执行查询 处理结果 清理环境 实现程序：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;public class JDBCTest&#123; pubilc static void main(String[] args)&#123; String sql = "SELECT * FROM tbl_user"; Connection conn = null; Statement st = null; ResultSet rs = null; try&#123; //注册MySQL的JDBC驱动程序，class类是继承Object类 //forName方法用来初始化参数指定的类并创立一个对应的实例对象 Class.forName("com.mysql,jdbc.Driver"); //获取MySQL的数据库连接 //getConnection方法需要传入三个参数：MySQL数据库的URL、MySQL数据库的用户名、密码 ////locahost:主机，3306：MySQL的端口,jsp_db:将要使用的数据库 conn = DriverManager.getConnection("jdbc:mysql://locahost:3306/jsp_db","root",""); //创建st对象 st = conn.createStatement(); //使用executeQuery方法发生sql语句返回rs结果集 rs = st.executeQuery(sql); while(rs.next())&#123; System.out.print(rs.getInt("id") * " "); System.out.print(rs.getString("name") * " "); System.out.print(rs.getString("password") * " "); System.out.print(rs.getString("email") * " "); System.out.println(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally&#123; try&#123; //关闭rs结果集 rs.closee(); &#125;catch(Exception e2)&#123; &#125; try&#123; //关闭st对象 st close(); &#125;catch(Exception e3)&#123; &#125; try&#123; //关闭数据库连接 conn close(); &#125;catch(Exception e4)&#123; &#125; &#125; &#125;&#125;&#125; 4、JDBC编程之数据更新数据库连接方法12345678910public static Connection getConnection()&#123; Connection conn = null; try&#123; Class.forName("con.mysql.jdbc.Driver"); conn = DriverManager.getConnection("jdbc:mysql://locahost:3306/jsp_db","root"," "); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return conn; &#125; 插入数据方法1234567891011121314public static void insert()&#123; //获取数据库连接 Connection conn = getConnection(); try&#123; String sql = "INSERT INTO tbl_user(name, password, email)" + "VALUES('Tom', '123456', 'tom@qq.com')"; Statement st = conn.createStatement(); int count = St.executeUpdate(sql); System.out.println("向用户表中插入了" + count + " 条记录")； conn.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;&#125; 更新方法1234567891011121314public static void update()&#123;//获取数据库连接 Connection conn = getConnection(); try&#123; String sql = "UPDATE tbl_user SET email = 'tom@126.com' WHERE name = 'Tom'"; Statement st = conn.createStatement(); int count = St.executeUpdate(sql); System.out.println("向用户表中更新了" + count + " 条记录")； conn.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;&#125; 删除记录的方法1234567891011121314public static void dele()&#123;//获取数据库连接 Connection conn = getConnection(); try&#123; String sql = "DELETE FROM tbl_user WHERE name = 'Tom'"; Statement st = conn.createStatement(); int count = St.executeUpdate(sql); System.out.println("从用户表中删除了" + count + " 条记录")； conn.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;&#125; 5、JDBC编程之事务处理事务概述 事务：数据库维护数据一致性的单位，在每个事务结束时都能保持事务的一致性。 事务的四个基本特征 原子性：事务中的操作都被视为一个逻辑单元。这个事务中的逻辑单元要么全部成功，要么全部失败。事务中的元素是一个整体，是不可分割的。 一致性：事务开始之前和事务结束以后，数据库都处于一致性状态。数据库的完整性约束没有被破坏。 隔离性：对数据库的修改的多个事务是互相隔离的。说明事务必须是独立的。 持久性：事务完成之后，它对数据的影响是永久的， 事物的语句 开始事物：BEGIN TRANSACTION 提交事物：COMMIT TRANSACTION 回滚事物: ROLLBACK TRANSACTION 编程实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class TransactionTest&#123;public static Connection getConnection()&#123; //数据库连接 Connection conn = null; try&#123; Class.forName("com.mysql.jdbc.Driver"); conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/jsp_db, root, " "); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return conn;&#125;public static void insertUserData()&#123; //插入用户数据 Connection conn = getConnection; try&#123; String sql = "INSERT INTO tbl_user(id, name, password, email)" + "VALUES(10, 'Tom', '123456', 'tom@gmail.com')"; Statement st = conn.createStatement(); int count = st.executeUpdate(sql); System.out.println("向用户表插入了 " + count + " 条记录"); conn.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;&#125;public static void insertAddressData()&#123; Connection conn = getConnection(); try&#123; Sting sql = "INSERT INTO tbl_address(id, city, country, user_id)" + "VALUES(1, 'xian','Chian', '10')"; Statement st = conn.createStatement(); int count = st.executeUpdate(sql); System.out.println("向地址表中插入了 " + count +" 条记录");&#125;catch(Exception e)&#123; e.printStackTrace(); &#125;public static void main(String[] agrs)&#123; insertUserData(); insertAddressData();&#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】bat自动处理hexo命令]]></title>
    <url>%2F2017%2F05%2F27%2F%E3%80%90Hexo%E3%80%91bat%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86hexo%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[每次写新文章都得hexo new “xxx”，写完再hexo g -d，挺麻烦的。就不能写一个脚本来自动执行吗？ 一、创建hexo文章之前写文章都得打开cmd,输入hexo new “XXX”。然后再去目录下找生成的.md文件打开编辑。这样的机械动作不应该用程序就可以做到吗？ 创建hexo文章.bat123456@echo offset /p name=input pages name:echo name:%name%echo please waithexo new %name% &amp;&amp; call 3.bat %name%pause 3.bat123456start /min /w mshta vbscript:setTimeout("window.close()",1000)echo The InputValue is %1set name=%1echo %name%start /d "C:\asoft\Sublime Text 3" sublime_text.exe "D:\Hexo\source\_posts\%name%.md"pause 每次点击“创建hexo文章.bat”输入文章名，sublime Text就会自动打开编辑了。 二、发布文章到github编辑完markdown文章后再发到github上，博客才会显示。一般命令：123hexo cleanhexo ghexo d 写成脚本： 发布文章到github.bat123start 1.batstart /min /w mshta vbscript:setTimeout("window.close()",1200)start 4.bat 1.bat12345@echo offecho cleanecho Please waithexo cleanexit 4.bat12hexo g -dpause 写完文章后，点击“发布文章到github.bat”就可以将文章发到github上，就可以在博客上显示了。等有时间再研究下怎么写一个客户端。（这篇文章使用本文程序发布） 附件bat自动处理hexo命令.rar 点击下载]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java本地文件操作]]></title>
    <url>%2F2017%2F05%2F25%2FJava%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[学而不思则罔，思而不学则殆。 java本地文件操作一、File类简介二、文件的创建、删除、重命名三、文件夹的创建、重命名、删除四、文件属性的读取五、文件属性的设置六、遍历文件夹七、文件的简单读写 一、File类的简介1234567891011121314package file;import java.io.File;public class HelloFile &#123; public static void main(String[] args) &#123; //创建文件对象 File file = new File("hello.txt"); //判断文件 ，返回布尔 file.isFile(); System.out.println(file.isFile()); //路径（文件夹） file.isDirectory(); System.out.println(file.isDirectory()); &#125;&#125; 运行结果：12falsefalse 二、文件的创建、删除、重命名123456789101112131415161718192021222324252627282930313233343536public class HelloFile &#123; public static void main(String[] args) &#123; //创建文件对象 File file = new File("hello.txt"); //hello.txt会存在于当前目录 //相对路径格式：xxx//hello.txt //绝对路径格式：D://AAA//BBB//hello.txt //"../hello.txt" 表示上一级文件结构 //是否存在 if(file.exists())&#123; //文件 System.out.println(file.isFile()); //路径（文件夹） System.out.println(file.isDirectory()); //重命名 //文件结构必须处于同一个分区 //文件处于不同的分区，需要使用文件的拷贝，而不是重命名// File nameto = new File("src/new Hello.txt");// file.renameTo(nameto); //文件删除// file.delete();// System.out.println("文件删除成功"); &#125;else &#123; System.out.println("文件不存在"); //创建文件 try &#123; file.createNewFile(); System.out.println("文件已经成功创建"); &#125; catch (IOException e) &#123; System.out.println("文件无法创建"); &#125; &#125; &#125;&#125; 三、文件夹的创建、重命名、删除1234567891011121314151617181920212223242526272829303132333435363738394041//文件夹的创建、重命名、删除public class HelloFile &#123; public static void main(String[] args) &#123; //文件夹的创建 File folder = new File("my new folder"); folder.mkdir(); System.out.println("文件夹创建完成"); //关于folder.mkdir(),返回一个布尔类型 if(folder.mkdir())&#123; System.out.println("文件夹创建完成"); &#125;else&#123; if(folder.exists())&#123; System.out.println("文件夹已经存在不用创建了"); &#125;else&#123; System.out.println("文件夹创建失败"); &#125; &#125; //文件夹的重命名 File folder = new File("my new folder"); File newfolder = new File("my new folder-new"); if(folder.renameTo(newfolder))&#123;//返回值布尔类型 System.out.println("done"); &#125;else&#123; System.out.println("fail"); &#125; //文件夹的删除 File folder = new File("my new folder/two"); folder.delete();//返回值布尔类型 //被删除的文件夹必须为空才会删除成功 if(folder.delete())&#123; System.out.println("done"); &#125;else&#123; System.out.println("fail"); &#125; &#125;&#125; 四、文件属性的读取123456789101112131415161718192021222324252627public class HelloFile &#123; public static void main(String[] args) &#123; //文件属性的读取 File file = new File("text.txt"); //判断文件是否存在 System.out.println("判断文件是否存在"+file.exists()); //读取文件名称 System.out.println("读取文件名称"+file.getName()); //读取文件路径 System.out.println("读取文件路径"+file.getPath()); //读取文件绝对路径 System.out.println("读取文件绝对路径"+file.getAbsolutePath()); //获取文件父级路径 System.out.println("获取文件父级路径"+new File(file.getAbsolutePath()).getParent()); //读取文件大小 System.out.println("读取文件大小"+file.length()+"byte");//字节 System.out.println("读取文件大小"+(float)file.length()/1000+"KB"); //判断文件是否被隐藏 System.out.println("判断文件是否被隐藏"+file.isHidden()); //判断文件是否可读 System.out.println("判断文件是否可读"+file.canRead()); //判断文件是否可写 System.out.println("判断文件是否可写"+file.canWrite()); //判断文件是否为文件夹 System.out.println("判断文件是否为文件夹"+file.isDirectory()); &#125; 五、文件属性的设置123456789101112131415public class HelloFile &#123; public static void main(String[] args) &#123; //文件属性的设置 File file = new File("text.txt"); if (file.exists())&#123; //将文件设定为可写 file.setWritable(true); file.setWritable(false); //将文件设定为可读 file.setReadable(false); file.setReadable(true); //将文件设定为只读 file.setReadOnly(); &#125; 六、遍历文件夹12345678910111213//遍历文件夹public static void printFiles(File dir)&#123; printFiles(new File("绝对路径")); if (dir.isDirectory()) &#123; File next[] = dir.listFiles();//listFiles()返回一个数组 for(int i= 0;i&lt;next.length;i++)&#123; System.out.println(next[i].getName()); if(next[i].isDirectory())&#123; printFiles(next[i]); &#125; &#125; &#125;&#125; 七、文件的简单读写123456789101112131415161718192021222324252627282930package file;import java.io.File;import java.io.IOException;public class HelloFile &#123; public static void main(String[] args) &#123; File file = new File("test.txt"); if(file.exists())&#123; System.err.println("exist"); try&#123; FileInputStream fis = new FileInputStream(file); InputStreamReader isr = new InputStreamReader(fis,"UTF-8"); BufferedReader br = new InputStreamReader(isr); String line; while(line = br.readLine() != NUll)&#123; System.out.println(line); &#125; br.close(); isr.close(); fis.close(); &#125;catch (FileNotFoundException e) &#123; &#125;catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125;catch (Exception e) &#123; &#125; &#125; &#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的JSON操作]]></title>
    <url>%2F2017%2F05%2F23%2FJSON%2F</url>
    <content type="text"><![CDATA[JSON简介JSON：JavaScript 对象表示法（JavaScript Object Notation）JSON是存储和交换文本信息的语法。 JSON的特点：1、JSON是轻量级的文本数据交换格式2、JSON独立于语言和平台3、JSON具有自我描述性，更易理解 JSON与XML类似XML，比XML更小、更快，更易解析。1、没有结束标签2、更短3、读写的速度更快4、使用数组5、不使用保留字 JSON的语法JSON语法是JavaScript对象表示法的子集。1、数据在名称/值对中（键值对）2、数据由逗号分隔3、花括号保存对象4、方括号保存数组JSON值可以是：1、数字（整数或浮点数）2、字符串（在双引号中）3、逻辑值（true或false）4、数组（在方括号中）5、对象（在花括号中）6、null JSON对象JSON对象在花括号中书写，对象可以包含多个名称/值对。1&#123;"firstName":"Jphn","lasrName":"Doe"&#125; JSON数组JSON数组在方括号中书写，数组可包含多个对象：1234567&#123;"employees":[&#123;"firstName":"John","lastName":"Doe"&#125;,&#123;"firstName":"Anna","lastName":"Smith"&#125;,&#123;"firstName":"Peter","lastName":"Jones"&#125;,]&#125; 使用Java读取JSON数据下载google-gson-2.2.4包使用gson-2.2.4.jar 123456789//待读取的JSON文件&#123;"cat":"it",//string类型"languages":[&#123;"id":1,"ide":"Eclipse","name":"Java"&#125;,&#123;"id":2,"ide":"XCode","name":"Swift"&#125;,&#123;"id":3,"ide":"Visual Studio","name":"C#"&#125;],//整型"pop":ture//布尔类型&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041import com.google.gson.JsonObject;public class ReadJSON&#123; public class void main(String[] args)&#123; try&#123; //建立一个JSON的解析器 //可用解析器解析字符串或者输入流 JsonParser parser = new JosnParser(); //建立一个JSON对象 JsonObject object = parser.parse(new FileReader("test.json")) //读取对象值 //由键索引键值，并依据键值数据类型，转换其格式 System.out.println("cat=" + object.get("cat").getAsString()); System.out.println("pop=" + object.get("pop").getAsBoolean()); //读取数组 JsonArray array = object.get("languages").getAsJsonArray; for (int i =0;i &lt; array.size();i++)&#123; System.out.println("-----------"); JsonObject subObject = array.get(i).getAsJsonObject(); System.out.println("id=" + subobject.get("id").getAsInt()); System.out.println("name=" + subobject.get("name").getAsString()); System.out.println("ide=" + subobject.get("ide").getAsString()); &#125;&#125;catch (JsonIOException e)&#123; e.printStackTrace();&#125;catch (JsonSyntaxException e)&#123; e.printStackTrace();&#125;catch (FileNotFoundException e)&#123; e.printStackTrace();&#125;&#125;&#125; 使用Java创建JSON数据123456789101112131415161718192021222324252627282930313233343536373839import com.google.gson.JsonObject;public class CreatJSON&#123; public class void main(String[] args)&#123; //创立JSON对象 JsonObject object = new JsonObject(); //添加键值对 object.addProperty("cat","it"); //添加数组 JsonArray array = new JsonArray(); JsonObject lan1 = new JsonObject(); lan1.addProperty("id",1); lan1.addProperty("name","Java"); lan1.addProperty("ide","Eclipse"); array.add(lan1); JsonObject lan2 = new JsonObject(); lan2.addProperty("id",2); lan2.addProperty("name","Swift"); lan2.addProperty("ide","XCode"); array.add(lan2); JsonObject lan3 = new JsonObject(); lan3.addProperty("id",3); lan3.addProperty("name","C#"); lan3.addProperty("ide","Visual Studio"); array.add(lan3); //将这个数组添加进去 object.add("languages",array); //添加布尔 object.addProperty("pop",ture); //输出 System.out.println(object.toString());&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五月中旬]]></title>
    <url>%2F2017%2F05%2F21%2F%E4%BA%94%E6%9C%88%E4%B8%AD%E6%97%AC%2F</url>
    <content type="text"><![CDATA[相对论表明：忙碌的时候就显得时间过得特别快。 五月中旬过得特别快特别快快到抓不住时间，母亲节回不了家 周末剪了两天自然辩证法的视频配音，字幕一个都不少想要把事情做到更好就一定是要去花时间的 周一的英美文化，我的演讲Prezi展示，早都做好了各种事情一直拖了快一个月才到我讲这大概是我学习英语生涯的最后一次演讲了吧扇贝单词打卡到800天就卸载了以后学英语的时间只能是越来越少 接下来准备周四的比赛答辩我们Holi的快铃全国研究生移动终端校内赛我一直都以为我是一个话少的码农然而我却成了那个能说的产品经理 PPT也是件麻烦的事情突然感觉乔布斯的工作也不好做把产品说的天花乱坠确实和敲代码把它实现是一样难 周四早上比赛演示答辩最大的收获是看到了其他队的作品说实话，感觉都挺不错的！ 就是感觉周围还有一群这样的人挺好的从一个简单的出发点开始，踏实做事好的想法和作品还是值得学习的结果也是好的，也算是研究生阶段的第一个奖 还是相信能和其他人把这个东西做好毕竟他是我们一点一点搭起来的要学习的东西还很多 慢慢的有这样的一个感觉有时间去学习，也是件幸福的事情获得新鲜感，获得心安理得 嗯，都挺好的我还需要接着努力啊，学习啊]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】【一键关闭445端口】关于防范勒索软件病毒攻击的紧急通知]]></title>
    <url>%2F2017%2F05%2F14%2F%E5%85%B3%E4%BA%8E%E9%98%B2%E8%8C%83%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%B4%A7%E6%80%A5%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[病毒袭来，转自信息化建设处。一键关闭445端口，并提供Windows各版本补丁下载。 校园网用户： 近期，国内多所院校出现勒索软件感染情况，磁盘文件会被病毒加密，并显示类似下图所示的勒索界面，只有支付高额赎金才能解密恢复文件，对学习资料和个人数据造成严重损失。 根据网络安全机构通报，这是不法分子利用NSA黑客武器库泄漏的“永恒之蓝”发起的病毒攻击事件。“永恒之蓝”会扫描开放445文件共享端口的Windows机器，无需用户任何操作，只要开机上网，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。 针对这一情况，我校校园网出口已经封掉漏洞端口并在网内启用了其他预防的安全策略，但是用户主机还是可能成为受攻击的对象，在此提醒广大校园网用户，为了您和周围师生的信息安全，请用户尽量做到如下几点： 1、为计算机安装最新的安全补丁，微软已发布补丁MS17-010修复了“永恒之蓝”攻击的系统漏洞，请尽快安装此安全补丁，网址为https://technet.microsoft.com/zh-cn/library/security/MS17-010； 2、强化网络安全意识：不明链接不要点击，不明文件不要下载，不明邮件不要打开； 3、尽快（今后定期）备份自己电脑中的重要文件资料到移动硬盘、U盘，备份完后脱机保存该磁盘； 4、建议仍在使用Windows XP，Windows 2003操作系统的用户尽快升级到 Window 7/Windows 10，或 Windows 2008/2012/2016操作系统。 5、由于本次Wannacry蠕虫事件的巨大影响，微软总部决定发布已停服的XP和部分服务器版特别补丁https://blogs.technet.microsoft.com/msrc/2017/05/12/customer-guidance-for-wannacrypt-attacks 6、校园网用户如有感染勒索病毒的，为避免影响其他用户，请及时拨打88201710 进行上报，我处将安排工作人员配合处理。 在此特别提醒各单位的系统管理员，除了上述几点外，请对本单位的业务系统主机进行检查，并关闭445、135、137、138、139端口，关闭网络共享（操作方法见附件），个人用户也可参考操作。 信息化建设处 2017年5月13日 附件一键关闭端口点击下载 其他：NSA武器库免疫补丁下载 解决Windows永恒之蓝 ONION勒索病毒攻击补丁下载地址（官方补丁根据自己系统下载 32位 64位）win7 : 点击下载win8 : 点击下载win10 : 点击下载全部官方版本补丁:点击下载XP win2003 以下 :点击下载 （360的）]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【会声会影】半小时学会基本简单操作]]></title>
    <url>%2F2017%2F05%2F09%2F%E4%BC%9A%E5%A3%B0%E4%BC%9A%E5%BD%B1-%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[第一次使用会声会影，是在2014年5月份左右。 为科协纳新做的一个宣传片，现在看起来好浮夸。 第二次使用会声会影，是在2016年。 为西电华为创新俱乐部六周年庆做的宣传片，这个还是比较满意的。 第三次使用会声会影，是帮同学的弟弟拍、剪了一个高考的鼓励视频，很短，也很用心去做。 第四次使用会声会影，是现在，2017年，自然辩证法课的团队视频展示。 据此，大概可以体会到一个设计师，一个UI师和程序员会有一样的急躁心情。 重要的事情放在前面说 巧妇难为无米之炊 制作视频的前提是有合适合理合情的视频材料。当然这里说的是会声会影的基本简单操作，大神自然可以忽略素材的问题。只有图片素材的，最后不套用模板做出来的就是像电子相册一样。套用模板的也像电子相册。浓浓的乡土气息就会扑面而来。 艺术细胞还真是爸妈给的 我们一直在说人与人直接的差别其实没有多大。但是事实是人与人直接的差别其实还是很大的。天赋上会有一小段差别，人性的差别有时比人与狗直接的差别还大。所以说了这么多，就是想说审美还是很重要的，人与人之间的审美差异也很重要。 大道至简 我们做任何事情都不应该忘记我们的初衷。视频重要的是内容！内容！！内容！！!那些看起来花里胡哨的反而会落入俗套。 我个人特别喜欢锤子科技每次新机发布会前期的大字报宣传。海报突出主题，让人第一眼就了解到你想让他知道的东西。 而不是让人去在一大堆五颜六色的东西里面去找你想传达给别人的东西。除非你是某知名大公司大人物，万众瞩目，别人总想从其中挖出一些东西。 然后就算是鼎鼎大名的Apple，它在户外的广告牌也是十分霸气！整整一片广告牌买下，一个新款机子的照片，加一句动人心扉的广告词，这就是它想表达的。 编程的思想，做视频的思想，生活的思想，万物归一—大道至简。 会声会影安装、注册、汉化我做了四次视频，装了三次会声会影。每次抓急做完视频，就删掉它，立flag不再做了。整个过程是在是太伤脑子了。不会的话比敲代码还费脑子。 安装 我用的是会声会影x8。网上都可以下载到。 VideoStudioUltimateX8_64bit_Setup.exe 注册 注册期间会要序列号。注册机网上也可找到。 COREL Products Keygen v3.9.exe 打开注册机就是那个魔性的配音，讲道理我能听一下午。在注册机里面找x8的版本，复制产生的序列码，复制粘贴到安装需要的地方。单机版就这样就行了。有其他需要的或者版也可以用这个注册机进行注册激活。 汉化 英文版的总是用起来比较别扭。汉化以后就显得这个傻瓜软件更傻瓜了，马上就可以上手。 会声会影X8_64位_简体中文包_免费版_顶渲Ma5老师汉化.exe 用的一个比较好的汉化版，网络上也可找到。 界面介绍 这是一个视频剪辑的操作画面。上面的白色框就是预览的，可以用来预览素材，和编辑后的效果。 一 这几个图标分别是媒体： 存放素材。模板：提供一些开始结尾或者自定义的一些模板。转场：提供素材直接的切换方式，有点像PPT切换的那种效果。也可以应用到视频和视频的转场，或者视频和图片的转场。这里需要提醒下：不要过度的使用这类技能，你以为很炫酷的东西其实很俗套。要合理使用合适的转场。标题：为视频添加文字、字幕。图形：给素材加上一些图形特效。滤镜：这个不用多说了，这里滤镜的效果可以预览下再使用。路径：可以选择这个素材怎么进入，在停留期间如何运动，怎么出镜。好的模板里都是自定义路径的。 二 轨道管理器：依据时间线来混合所有素材。 视频轨：这个是作为主轨。这个轨道必须是从视频一开始就有内容，不能有内容中断，内容不能空缺。它就和时间轴一样，从这个视频的创建到结束，它每时每刻里面都得有内容。当然，会声会影已经把这个限制了。编辑者必须这样来。这个轨道里可以添加视频素材，图片素材。这两种素材可以互相间隔着放。直接可以加转场，素材本身可以添加滤镜，转场等等。覆盖轨道：这个轨道主要是对视频轨道的辅助。不需要每时每刻轨道里都得有内容，只需要在你想放的时间点上放素材即可。后面的几个轨道除了声音轨，其他轨道和覆盖轨一样。 如何把一张图片放到一个视频里呢？就是把图片放在这个轨道里！在同一时间点他就会和上面的视频同时出现！这里的话能玩的多了！也可以把视频放在这个覆盖轨里，这样同一时间就会出现两个视频框：视频轨和覆盖轨道。画中画这里也可以实现。覆盖轨是视频编辑的重要利器。有时候一个覆盖轨还不够，就可以在轨道管理器里增加轨道。后续的轨道也是。不够可以加。只有视频轨和声音轨不能加。有创意都可以在覆盖轨里实现，可以去看看好的模板里是怎么玩覆盖轨的。 标题轨： 此轨道用来写文字，视频里的文字都在这个轨道里完成。可以用会声会影自带的文字特效来生成文字，也自己来自定义文字效果。 想在同一个时间点上在视频两处或多出添加文字，就可增加标题轨数目了。 声音轨：用来放配音。音乐轨：用来放背景音乐。一般情况下找来的视频素材会有声音，可以右键选择静音功能，之后自己再添加声音和音乐。 基本操作对视频的操作： 视频素材就像是一个有弹性的皮筋。你拿到手的素材就是一个已经拉到最长长度的皮筋，它的长度在其他条件不变下是不能再长了。我为什么要这么说？因为是快镜头、慢镜头的操作下，视频的长度是可以增加的。 但是，这样就可以对视频进行缩减操作，比如说一个视频里你只想要中间部分，而不想要开头和末尾该肿么办？橡皮筋是可以伸缩的，把两头都给缩一下就行了。视频也和橡皮筋一样，把两头缩一下就行。在轨道里拖动视频的两头左右移动来控制视频播放的内容。这里需要注意一点：视频和皮筋一样，它虽然两头被缩了，只能播放中间的那一段，但是它仍然是一个完整的视频！等你把它从两端再往回拉的时候，它的原来长度就又出来了。 这样剪视频的时候，就可以把一个素材多次使用。 音乐和对视频的操作是一样的。 对图片的操作： 图片和视频有点不太一样，视频像皮筋的话，图片就像如意金箍棒。图片存在在轨道里的时间是没有限制的。想让它停留的时间久一点，就在覆盖轨里把它拉的长一点。标题（文字）的操作和对图片的操作是一样的。根据需要调整它出现是时间和时间长度。 这样一个基本的操作就可以了。对视频的剪辑，做电子相册等等这些功能以上的简单操作都快完成。 三视频输出：介绍三种输出格式： AVI：输出的视频清晰度和质量都比较高，但是占用空间也很大。 MPEG-4：就是生成后缀为MP4格式的视频，推荐使用。清晰度和质量不错，占用内存也不算很大。对播放器的要求也不挑剔。 WMV:流媒体文件，生成的视频质量不错，占用的内存也不是很大。但是播放器对该类型的支持没MP4格式广泛。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>视频</tag>
        <tag>会声会影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念多说]]></title>
    <url>%2F2017%2F05%2F04%2F%E7%BA%AA%E5%BF%B5%E5%A4%9A%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[早些时间里在一些论坛里的评论框不是多说，就是disqus。 在知识都能变现的日子里被顶起来的第二个帖子说的很对，不能变现的项目做了这么久，真的是挺辛苦的。前段时间读完了《腾讯传》 ，对多说的这个遭遇腾讯起步也遇到过。在明知道这个项目是大众需要的东西，但是看不到盈利点。腾讯早年也是把OICQ的用户一点点做起来到QICQ，到QQ。不能变现，也是拆东墙补西墙。后来接的小广告，会员制，移动梦网，到QQ秀等虚拟物品才缓过神来，对变现的套路是越玩越深，发展成今天的腾讯帝国。 多说就显得没这么幸运了。一个评论框怎么变现？各大论坛里都再用，盈利点在哪里? 投资人估计也是没信心了。 之前博客用的也是多说评论。听到这个消息就去更新了下主题，有可选的几种。最好看的就是畅言了，可是它要备案。然后就选择了现在用的网易云，看起来也不错。我为什么要纠结的这个问题，难道是因为会有人给我评论吗？ 在现在的这个互联网时代，教育居然都能产业化，连知识都想着变现，你觉得还有什么不能变现。]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>多说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages自定义域名]]></title>
    <url>%2F2017%2F05%2F04%2FGitHub-Pages-%E6%94%B9%E5%8F%98%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E4%B8%BAyourname-github-io%2F</url>
    <content type="text"><![CDATA[为了不备案也不被和谐。 将自定义的Github Pages域名改为原来的yourname.github.io其实很简单： 删除本目录下的CANME文件，或者改写CANME文件里的内容为空。 运行： 12345hexo cleanhexo ghexo d 清除浏览器缓存，打开OK！ 那么我之前又是怎么自定义域名的呢？ 为Github Pages博客绑定一个免费顶级域名最早用GitHub Pages做个人博客，初始的二级域名就是https://x-nicolo.github.io/，之后用了一个免费顶级域名，在Freenom 申请，最长可以申请一年的免费域名使用权。申请了一个.cf 的域名。 申请流程： 注册用户 查询选择一个可用的域名 checkout,continue,填写相关用户信息，提交订单 拥有自己的顶级域名了，可以在 MyDomains 查看。 添加CNAME文件在github pages项目根目录上新建一个CNAME文件，在CNAME文件上编辑刚才申请到的域名。比如：xiaosablog.cf 在DNSPod添加A记录 注册DNSPod，进入管理中心，选择添加域名。 为域名添加记录，这里的NS记录是自动生成。 个人博客可以通过 xiaosablog.cf 和 www.xiaosablog.cf 都能访问，所以需要添加两组A记录。其记录值设置为：192.30.252.153 和 192.30.252.154。这是github pages给出的。根据CNAME文件，这里指定了其所对应的域名，github会自动处理，将x-nicolo.github.io 和xiaosablog.cf 对应起来。 修改域名DNS地址 到Freenom修改DNS地址，把域名解析交给DNSPod。 MyDomains -&gt; Manage Domain -&gt; Management Tools -&gt; NameServers把DNSPod中的两个NS记录写入。 点击保存，然后等待全球递归DNS服务器刷新（最多72小时).我当时好像就等了72小时。。。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间有点快]]></title>
    <url>%2F2017%2F04%2F26%2F%E6%97%B6%E9%97%B4%E6%9C%89%E7%82%B9%E5%BF%AB%2F</url>
    <content type="text"><![CDATA[晚上坐在电脑前，感觉这段时间过得有点快。 周末的定义以前只是想尽快把属于自己的工作在最短的时间里做好。还没有周末的概念。 读研后发现，周末是个好发明。 不管什么事情，只要周五下午的最后一班结束，所有的事情都瞬时静止下来。不是说自己变懒了，不去完成工作。而是要和人打交道的工作没法进行了。大家都去过周末了。所以周末还是好好休息吧，好好挥霍吧。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>旧事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java+freemaker+xml生成word模板]]></title>
    <url>%2F2017%2F04%2F15%2FJava-freemaker-xml%E7%94%9F%E6%88%90word%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[Java利用freemaker包来操作生成word模板。 一个头疼的问题，了解了下xml。Java也是在学习的路上。 需求自动化生成word报告，需要现有的word模板，选择后自动填入所需参数和计算后的结果。可以减少人必要的输入，提高效率，提高准确率。 R1：静态文字word模板Step1该方法需要先手动创建一个doc模板，并保存为xml文件。通过动态替换特定标签${}中的内容生成。word形式： Step2通过word制作好模板，另存为xml文件。里面的${}会被分开，需要删除多余的东西。只需要留下${}及{}里面的标识符。例如这样： Step3处理好xml文件后就可以写Java程序，需要注意是的标识符一致。Java程序结构： Java程序：DocUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package creatreport;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStreamWriter;import java.io.Writer;import java.util.Map;import freemarker.template.Configuration;import freemarker.template.Template;import freemarker.template.TemplateException;import freemarker.template.TemplateExceptionHandler;import sun.misc.BASE64Encoder;public class DocUtil &#123; public Configuration configure=null; public DocUtil()&#123;// configure=new Configuration(Configuration.VERSION_2_3_22); configure=new Configuration(); configure.setDefaultEncoding("utf-8"); &#125; /** * 根据Doc模板生成word文件 * @param dataMap 需要填入模板的数据 * @param downloadType 文件名称 * @param savePath 保存路径 */ public void createDoc(Map&lt;String,Object&gt; dataMap,String downloadType,String savePath)&#123; try &#123; //加载需要装填的模板 Template template=null; //设置模板装置方法和路径，FreeMarker支持多种模板装载方法。可以从servlet，classpath,数据库装载。 //加载模板文件，放在testDoc下 configure.setClassForTemplateLoading(this.getClass(), "/testDoc"); //设置对象包装器 //configure.setObjectWrapper(new DefaultObjectWrapper()); //设置异常处理器 configure.setTemplateExceptionHandler(TemplateExceptionHandler.IGNORE_HANDLER); //定义Template对象，注意模板类型名字与downloadType要一致 template=configure.getTemplate(downloadType + ".xml"); File outFile=new File(savePath); Writer out=null; //指定编码表需使用转换流，转换流对象要接收一个字节输出流 out=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outFile), "utf-8")); template.process(dataMap, out); out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TemplateException e) &#123; e.printStackTrace(); &#125; &#125; public String getImageStr(String imgFile)&#123; InputStream in=null; byte[] data=null; try &#123; in=new FileInputStream(imgFile); data=new byte[in.available()]; in.read(data); in.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; BASE64Encoder encoder=new BASE64Encoder(); return encoder.encode(data); &#125;&#125; TestDoc.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package creatreport;import java.util.*;public class TestDoc &#123; public static void main(String[] args)&#123; DocUtil docUtil=new DocUtil(); Map&lt;String, Object&gt; dataMap=new HashMap&lt;String, Object&gt;(); /**表4-1-1*/ //weights dataMap.put("w1", "0.7"); dataMap.put("w2", "0.18"); dataMap.put("w3", "0.12"); dataMap.put("w4", "0.02"); dataMap.put("w5", "0.01"); dataMap.put("w6", "0.3"); dataMap.put("w7", "0.3"); dataMap.put("w8", "0.28"); dataMap.put("w9", "0.7"); dataMap.put("w10", "0.02"); dataMap.put("w11", "0.4"); dataMap.put("w12", "0.25"); dataMap.put("w13", "0.1"); dataMap.put("w14", "0.1"); dataMap.put("w15", "0.1"); dataMap.put("w16", "0.05"); //PS dataMap.put("ps1", "/"); dataMap.put("ps2", "/"); dataMap.put("ps3", "/"); dataMap.put("ps4", "/"); dataMap.put("ps5", "/"); dataMap.put("ps6", "/"); dataMap.put("ps7", "/"); dataMap.put("ps8", "/"); dataMap.put("ps9", "/"); dataMap.put("ps10", "/"); dataMap.put("ps11", "/"); dataMap.put("ps12", "/"); dataMap.put("ps13", "/"); dataMap.put("ps14", "/"); dataMap.put("ps15", "/"); dataMap.put("ps16", "/"); docUtil.createDoc(dataMap,"4_1_1","D:\\eclipseWorkspace\\bridgereport\\4_1_1.doc"); System.out.println("Word文件已生成完毕！目录地址：D:\\eclipseWorkspace\\bridgereport\\4_1_1.doc"); &#125;&#125; 需要注意的问题： 加入jar包后需要 build path。 xml模板放在testDoc下。 Step4效果： R2：静态图文模板在模板里插入图片的情况。建立word模板的时候，需要在之后插入图片的地方先任意插入一张图片占位。word另存为xml时候，${}该删除的和以前一样。但是在插入图片的地方会有一大堆编码。处理的方法是删除这堆编码，在图片的标志位下换成自己定义的标识符：该留下的东西如上。插入图片的代码：1234567891011121314151617//将图片转换成BASE64字符串public String getImageStr(String imgFile)&#123; InputStream in=null; byte[] data=null; try &#123; in=new FileInputStream(imgFile); data=new byte[in.available()]; in.read(data); in.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; BASE64Encoder encoder=new BASE64Encoder(); return encoder.encode(data);&#125; TestDoc中的使用代码：1234dataMap.put("leftPic1", docUtil.getImageStr("D:\\eclipseWorkspace\\bridge_report_v2_0\\pic1.png"));dataMap.put("leftPic2", docUtil.getImageStr("D:\\eclipseWorkspace\\bridge_report_v2_0\\pic2.png"));dataMap.put("rightPic1", docUtil.getImageStr("D:\\eclipseWorkspace\\bridge_report_v2_0\\pic3.png"));dataMap.put("rightPic2", docUtil.getImageStr("D:\\eclipseWorkspace\\bridge_report_v2_0\\pic4.png")); 需要主要的问题： 图片的那堆编码删除后的形式如上图。 BASE64Decoder类不属于JDK标准库范畴，需要这样做，不然会报错： 图文静态效果： R3：模板中有循环列表需求: 本意是需要构件编号-备注是可以动态增加的，而原桥左幅和原桥右幅都只是一个单元格。但是现在只能实现每行所有的列的动态增加。 xml修改的核心代码：12345678&lt;#list rightBanList as rightBan&gt; $&#123;rightBan.idR&#125; $&#123;rightBan.sortR&#125; $&#123;rightBan.detailR&#125;&lt;/#list&gt; java循环类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package liangban_report;public class LeftBan &#123; private String idL; private String sortL; private String detailL; private String rankL; private double scoreL; private String psL; public String getIdL() &#123; return idL; &#125; public void setIdL(String idL) &#123; this.idL = idL; &#125; public String getSortL() &#123; return sortL; &#125; public void setSortL(String sortL) &#123; this.sortL = sortL; &#125; public String getDetailL() &#123; return detailL; &#125; public void setDetailL(String detailL) &#123; this.detailL = detailL; &#125; public String getRankL() &#123; return rankL; &#125; public void setRankL(String rankL) &#123; this.rankL = rankL; &#125; public double getScoreL() &#123; return scoreL; &#125; public void setScoreL(double scoreL) &#123; this.scoreL = scoreL; &#125; public String getPsL() &#123; return psL; &#125; public void setPsL(String psL) &#123; this.psL = psL; &#125;&#125; TestDoc: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package liangban_report;import java.util.*;public class TestDoc &#123; public static void main(String[] args)&#123; //左幅右幅 DocUtil docUtil=new DocUtil(); Map&lt;String, Object&gt; dataMap=new HashMap&lt;String, Object&gt;(); List&lt;LeftBan&gt; leftBanList = new ArrayList&lt;LeftBan&gt;(); List&lt;RightBan&gt; rightBanList = new ArrayList&lt;RightBan&gt;(); LeftBan leftBan1 = new LeftBan(); leftBan1.setIdL("原左-1-1#板"); leftBan1.setSortL("裂缝"); leftBan1.setDetailL("板底出现9条横向裂缝，长度/宽度为30~50cm/0.05~0.1mm"); leftBan1.setRankL("2"); leftBan1.setScoreL(65.0); leftBan1.setPsL("/"); leftBanList.add(leftBan1); LeftBan leftBan2 = new LeftBan(); leftBan2.setIdL("原左-2-6#板"); leftBan2.setSortL("渗水"); leftBan2.setDetailL("板底出现渗水泛白，S=120X200cm2"); leftBan2.setRankL("2"); leftBan2.setScoreL(75.0); leftBan2.setPsL("/"); leftBanList.add(leftBan2); dataMap.put("leftBanList", leftBanList); RightBan rightBan1 = new RightBan(); rightBan1.setIdR("原右-1-8#板"); rightBan1.setSortR("裂缝"+" "+"露筋"); rightBan1.setDetailR("板底出现6条横向裂缝，长度/宽度为80~100cm/0.05mm，4处单根露筋L=40cm，1处区域露筋，S=20X20cm2"); rightBan1.setRankR("2"+" "+"2"); rightBan1.setScoreR(62.4); rightBan1.setPsR("/"); rightBanList.add(rightBan1); RightBan rightBan2 = new RightBan(); rightBan2.setIdR("原右-3-7#板"); rightBan2.setSortR("破损"); rightBan2.setDetailR("板底出现1处破损，S=120X150cm2"); rightBan2.setRankR("3"); rightBan2.setScoreR(60.0); rightBan2.setPsR("/"); rightBanList.add(rightBan2); dataMap.put("rightBanList", rightBanList); dataMap.put("leftPic1", docUtil.getImageStr("D:\\eclipseWorkspace\\bridge_report_v2_0\\pic1.png")); dataMap.put("leftPic2", docUtil.getImageStr("D:\\eclipseWorkspace\\bridge_report_v2_0\\pic2.png")); dataMap.put("rightPic1", docUtil.getImageStr("D:\\eclipseWorkspace\\bridge_report_v2_0\\pic3.png")); dataMap.put("rightPic2", docUtil.getImageStr("D:\\eclipseWorkspace\\bridge_report_v2_0\\pic4.png")); docUtil.createDoc(dataMap,"liangban","D:\\eclipseWorkspace\\bridge_report_v2_0\\bridge_report_v2_0.doc"); System.out.println("Doc文件已生成成功！"); &#125;&#125; 效果： 问题：需要的效果没能做出来。 R4：以换行的形式来显示动态的word模板在处理显示多行的xml中，并加换行符： 123&lt;#list firstDeductItem as firstItem&gt; &lt;w:t&gt;$&#123;firstItem&#125;&lt;/w:t&gt;&lt;w:br/&gt;&lt;/#list&gt; TestDoc.java中改为：123456/*显示构件数量,如需增加数据，使用Str.add("")即可*/List&lt;String&gt; Strs=new ArrayList&lt;String&gt;();Strs.add("100");Strs.add("200");Strs.add("300");dataMap.put("brulcNum", Strs); DocUtil.java中改为：12//定义Template对象，注意模板类型名字与downloadType要一致template=configure.getTemplate(downloadType+".ftl"); 此时xml文件会报错，当然也不能编译运行项目，需要将.xml文件改为.ftl文件保存。再编译运行，效果图： 以换行的形式来表示增加的单元格。优化的方法再想想吧。这个周末累死了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[风吹麦浪]]></title>
    <url>%2F2017%2F04%2F09%2F%E9%A3%8E%E5%90%B9%E9%BA%A6%E6%B5%AA%2F</url>
    <content type="text"><![CDATA[不更博的原因有两种： 忙 闲 歌手：李健 所属专辑：想念你 远处蔚蓝天空下涌动着金色的麦浪就在那里曾是你和我爱过的地方当微风带着收获的味道吹向我脸庞想起你轻柔的话语曾打湿我眼眶嗯…啦…嗯…啦… 我们曾在田野里歌唱在冬季盼望却没能等到阳光下这秋天的景象就让失散的誓言飞舞吧随西风飘荡就像你柔软的长发曾芬芳我梦乡嗯…啦…嗯…啦… 远处蔚蓝天空下涌动着金色的麦浪就在那里曾是你和我爱过的地方当微风带着收获的味道吹向我脸庞想起你轻柔的话语曾打湿我眼眶嗯…啦…嗯…啦… 我们曾在田野里歌唱在冬季盼望却没能等到阳光下这秋天的景象就让失散的誓言飞舞吧随西风飘荡就像你柔软的长发曾芬芳我梦乡嗯…嗯… 不知怎么滴，觉得李健这首歌超级好听 忙最近其实有许多事情要忙的 但是人吧，疲了就会有拖延症 感觉自己就想一个多进程运行的机器 多个事件并发 哪一个很急就会先放下比较急的事情 火烧眉毛，弄得自己很被动 1.Holi的事情也快完成了，最近本科生教务处的爬虫及数据处理快收尾 2.2017华为软件精英比赛 今年划水过，实力不足，时间安排出问题但是经验还是多少存了点，来年再战 闲为什么说闲呢 事多了不闲烦 闲下来就看看书 最近看了好几本 闲了就打几把小游戏 还是打的那么烂 闲了就翻翻以前的东西 发现我还是瘦过的 突然就想瘦下来了 特别想 除了高考、考研下过这么大决心外 好像还没下过决心做什么 那就瘦下来 嗯 立个flag！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>旧事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java调用Python的错误]]></title>
    <url>%2F2017%2F03%2F14%2FJava%E8%B0%83%E7%94%A8Python%E7%9A%84%E9%94%99%E8%AF%AF-1%2F</url>
    <content type="text"><![CDATA[因为这篇Java调用Python 之前试过用Java调用Python，到真正用的时候才发现是一个乌龙。 error错误就是我的程序太多了，程序命名混乱，导致执行了不该执行的程序，而我以为它跑通了。 这个方法： Runtime.getRuntime().exec(&quot;python D:\\studentdb.py id password&quot;); 并不能传递形参！！！只可以这样使用： Runtime.getRuntime().exec(“python D:\studentdb.py 12345678 666666”);这样是可以把学号和密码传入Python文件，并且执行。而前者的形参方法，是会直接把形参当成字符串直接传进Python…这也就是说，这个方法只可以传递字符串。前几天调到半夜发现的真理。 那么还有解决办法吗？肯定有，要么是我不知道，要么是我不会。 新方法Jython查找资料发现这个第三方包是可以用来传递Python参数并且执行代码。之前也有注意到这个方法，但是由于考虑到它的复杂性，和Runtime.getRuntime().exec()方法的简单性，就没有往这里想，毕竟程序员是最懒的。 首先得下载Jython这个第三方包。 调试记录1、console: Failed to install ‘’: java.nio.charset.UnsupportedCharsetException: cp0.Run As&gt;Run Configurations,选择第二个页签Arguments,在VM arguments中添加-Dpython.console.encoding=UTF-8即可，然后Apply&gt;Run就行了2、java用jython.jar调用python脚本，脚本中import了第三方库时，报错：import xxx: no module named xxx.两种解决方法：（1）下载或pip install需要的第三方库，将jython.jar改成jython.zip，并解压缩，将下载的第三方库（以库名定义的文件夹）放到jython文件夹下的/Lib或/Lib/site-packages下，最后将jython文件夹重新打包（注意：打包时不要直接对jython文件夹打包，只打包jython根目录下的所有文件），并改后缀为.jar，配置到java的工程目录中（构建路径）。（2）配置python的系统路径，java解析脚本时会到sys.path中找import的第三方库，只要sys.path中能找到第三方库的文件夹即可。注：在java端通过语句：PySystemState sys = Py.getSystemState();System.out.println(sys.path.toString());打印路径信息。 最后的bug与悔悟一步步的将各个遇到的bug击破，遇到最大的障碍：识别不了requests包。和队友们思前想后，觉得这可能是和Python的版本有关系。我们统一用的是Python35，从这个第三包的名字就可以的看出Jython2.7就能看得出它是支持Python27的。又又又想起来《笨办法学Python》里的一段话。不要用Python3！不要用Python3！！不要用Python3！！！因为Python3要适配Python2的所有第三方包会花费很长的时间！ 但是事物的发展不就是要走在最前沿的吗！这个问题肯定有它的解决办法。只是我不知道和不会。现在最蠢的解决办法有两种： 重写Python3程序为Python2 后台将获得的学号密码生成为CSV文件保存到本地，再直接执行Python程序。Python程序里读取本地CSV文件，获取学号密码，进行爬虫活动，存数据到MySQL，再删除CSV。 第一种方法需要花时间。第二种方法太笨，在处理多并发的活动时可能会崩塌。而且效率低。 思前想后，为了以后工作的顺利进行，还是选择第一种吧，重新写Python程序为2。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Python</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫】（八）Python之爬虫和数据小解析]]></title>
    <url>%2F2017%2F03%2F14%2FPython%E4%B9%8B%E7%88%AC%E8%99%AB%E5%92%8C%E6%95%B0%E6%8D%AE%E5%B0%8F%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Holi需要。之前爬的课表，现在需要将那些个一连串的字符串分割成想要的单独的数据，做个性化推送。程序的前面和之前一样，模拟登录。在处理选课/改课这个网页的时候，还是蛮复杂的。遇神杀神，见鬼杀鬼。 爬虫1234567891011121314151617181920212223242526272829303132333435def Store(self): # 改课选课 grade_page = self.session.get( "http://yjsxt.xidian.edu.cn/electiveForwardAction.do") bsObj = BeautifulSoup(grade_page.text, "html.parser") table = bsObj.findAll("table", &#123;"class": "list_2title"&#125;)[0] rows = table.findAll("tr") # 删除特定的标签和其标签下的内容 # 方法： # 去除标签：[s.extract() for s in soup('script')] [s.extract() for s in bsObj.findAll( 'td', attrs=&#123;'class': "special_background textLeft"&#125;)] csvFile = open('./xuankegaike.csv', 'w', newline='', encoding='utf-8') writer = csv.writer(csvFile) writer.writerow(('课程编号', '课程名称', '学分', '学位课', '上课学期', '任课教师', '校区', '上课地点/星期/节次/周次', '分班号')) csvRow = [] try: for row in rows: csvRow = [] # for cell in row.findAll('td')[:-1]: for cell in row.findAll('td', attrs=&#123;'valign': "middle"&#125;)[:-1]: csvRow.append(cell.get_text().strip().replace(' ', '')) writer.writerow(csvRow) finally: csvFile.close() csvFile1 = open('./xuankegaike.csv', 'r', encoding='utf-8') reader = csv.DictReader(csvFile1) 正个页面有一张大table，但是里面分布的真不整齐。 新方法s.extract()： 删除特定的标签和其标签下的内容方法：去除标签：[s.extract() for s in soup(&#39;script&#39;)]s.extract()方法可以删除标签或指定标签下的内容。 获取指定td下的内容：row.findAll(&apos;td&apos;, attrs={&apos;valign&apos;: &quot;middle&quot;})[:-1]: 这几次爬虫对于切片还是用的很好的。 爬回待处理table：123456789101112131415161718192021课程编号,课程名称,学分,学位课,上课学期,任课教师,校区,上课地点/星期/节次/周次,分班号G00FL1020,综合英语,2,是,2016秋,培养办,北校区,,免修班G00HA1012,科学道德与学风,0,是,2016秋,梁昌洪,南校区,,不分班G00HA1010,中国特色社会主义理论与实践,2,是,2016秋,肖群,北校区,"J-201/星期一/(9-11)2,3,4,5,7,8,9,10,11,12,13",02G00HA1011,自然辩证法概论,1,是,2017春,朱丹琼,北校区,"J-205/星期一/(3-4)2,3,4,5,7,8,9,11,12",07G00FL1023,英语听说,1,是,2016秋,姜宁,北校区,"西-508/星期二/(7-8)2,3,4,5,7,8,9,10,11,12,13,14,15,16,17,18",07G00FL1026,英美文化,1,是,2017春,邹甜甜,北校区,"西-514/星期一/(1-2)2,3,4,5,7,8,9,11,12,13,15,16,17,18",01Z00MS1031,工程优化方法及应用,3,是,2016秋,寇晓丽,北校区,"J-205/星期四/(9-11)2,4,5,7,8,9,10,11,13,14,15,16,17,18,19",01Z08EE1011,算法设计技术与方法,3,是,2016秋,公茂果,北校区,"J-304/星期三/(9-11)18J-304/星期五/(9-11)2,5,7,8,9,10,11,12,13,14,15,16,17,18,20",不分班Z08TE1107,宽带无线通信,3,是,2016秋,盛敏,北校区,"J-204/星期一/(3-4)2,3,4,5,7,8,9,10,11,12,13,14,15,16,17,18J-204/星期四/(1-2)2,4,8,10,12,14,16,18",不分班Z08TE1140,信号检测与估值理论,3,是,2017春,李颖,北校区,"J-208/星期三/(3-4)2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17J-208/星期五/(1-2)2,4,6,8,10,12,14,16",不分班G00HA0040,体育,0.5,否,2016秋,白光斌,北校区,"体育馆/星期三/(3-4)3,4,5,7,8,9,10,11,12,13",01G00HA0041,体育,0.5,否,2017春,白光斌,北校区,"体育馆/星期三/(5-6)2,3,4,5,6,7,8,9,10,11",02Z08TE1222,扩频通信系统,2,否,2016秋,刘乃安,北校区,"J-205/星期二/(9-11)4,5,7,8,9,10,11,12,13,14,15",不分班G00HA1016,知识产权与专利申请,1,否,2016秋,王喜媛,北校区,"J-101/星期二/(1-2)3,4,5,7,8,9,10,11,12",01G00GS1001,企业实习报告,2,否,2016秋,培养办,北校区,,不分班G00GS1002,开题报告,2,否,2016秋,培养办,北校区,,不分班G00GS1003,中期检查,2,否,2016秋,培养办,北校区,,不分班Z08TE1212,MIMO系统与OFDM传输技术,2,否,2016秋,赵力强,北校区,"J-204/星期二/(5-6)3,4,5,7,8,9,10,11,12J-204/星期四/(5-6)4,5,7,8,9,10,11",不分班Z08TE1216,图像工程,3,否,2016秋,卢朝阳，李静,北校区,"J-208/星期五/(5-8)2,4,5,7,8,9,10,11,12,13,14,15",不分班Z08EE1238,科学精神与方法专题讲座,2,否,2017春,梁昌洪,北校区,"图书馆报告厅（3楼）/星期四/(9-11)3,4,5,6,7,8,9,10,11,12,13",不分班 前几项都是可以直接存到MySQL，现在要做的就是把 上课地点/星期/节次/周次 这一栏切割后存进MySQL。 方法：split()首先分析爬回的table。里面的上课地点/星期/节次/周次可以分为三类： 空。比如综合英语，科学道德与学分。 一周只有一节课的课。 一周有两节课的课。 讲道理是要按照三种方法来对字符型切割。但是该怎么来分类。我的第一个思路是用：try，except。但是这几个并不是用来处理选择结构的吧。但是try，except，else，finally还是很好用的。选择结构？难道不应该是if，else吗？对！就是它！对这几种不同类型的上课地点/星期/节次/周次字符串的长度进行分析，三类的长度大概如下：第一类：长度为0；第二类：长度为50~60；第三类：长度60~90.这样一来就按照上课地点/星期/节次/周次的长度来判断分割方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# # 使用 execute() 方法执行 SQL 查询try: if len(e['上课地点/星期/节次/周次']) &gt; 60: cursor.execute(sql, ( e['课程编号'].strip(), e['课程名称'].strip(), e['学分'].strip(), e['学位课'].strip(), e['上课学期'].strip(), e['任课教师'].strip(), e['校区'].strip(), e['上课地点/星期/节次/周次'].split("/")[0], e['上课地点/星期/节次/周次'].split("/")[1], e['上课地点/星期/节次/周次'].split( "(")[1].split(")")[0][0], e['上课地点/星期/节次/周次'].split("/")[2][5:- 5].lstrip(')'), e['分班号'].strip())) # 存两次 cursor.execute(sql, ( e['课程编号'].strip(), e['课程名称'].strip(), e['学分'].strip(), e['学位课'].strip(), e['上课学期'].strip(), e['任课教师'].strip(), e['校区'].strip(), e['上课地点/星期/节次/周次'].split("/")[2][-5:], e['上课地点/星期/节次/周次'].split("/")[3], e['上课地点/星期/节次/周次'].split("/")[4][1], e['上课地点/星期/节次/周次'].split( "/")[4][5:].lstrip(')'), e['分班号'].strip())) else: cursor.execute(sql, ( e['课程编号'].strip(), e['课程名称'].strip(), e['学分'].strip(), e['学位课'].strip(), e['上课学期'].strip(), e['任课教师'].strip(), e['校区'].strip(), e['上课地点/星期/节次/周次'].split("/")[0], e['上课地点/星期/节次/周次'].split("/")[1], e['上课地点/星期/节次/周次'].split( "(")[1].split(")")[0][0], e['上课地点/星期/节次/周次'].split( "/")[2][5:].lstrip(')'), e['分班号'].strip()))except: # else len(e['上课地点/星期/节次/周次']) == 0: cursor.execute(sql, ( e['课程编号'].strip(), e['课程名称'].strip(), e['学分'].strip(), e['学位课'].strip(), e['上课学期'].strip(), e['任课教师'].strip(), e['校区'].strip(), e['上课地点/星期/节次/周次'], e['上课地点/星期/节次/周次'], e['上课地点/星期/节次/周次'], e['上课地点/星期/节次/周次'], e['分班号'].strip())) if下面包含两部分： 字符串长度大于60的，即一周有两节课的情况。 一周有两节课的情况，将该课程在数据库存两次，但是两次的上课时间、地点、周次是不一样的。 else处理长度小于60的，即一周只要一节课的课。 except当前两项都出现异常时，其必然是第一类情况，字符串为空，直接存进就可以。 splitsplit的几种用法：split(&quot;/&quot;)[0]：按照“/”分割，取第一个切片。 split(&quot;(&quot;)[1].split(&quot;)&quot;)[0][0] 取“（）”内的字符串的第一个。 最后将里面的简单字符串都处理为数字。 for e in reader: # 是否是学位课 if e[&apos;学位课&apos;] == &apos;是&apos;: e[&apos;学位课&apos;] = &apos;1&apos; else: e[&apos;学位课&apos;] = &apos;0&apos; # 学期 if e[&apos;上课学期&apos;] == &apos;2016秋&apos;: e[&apos;上课学期&apos;] = &apos;0&apos; else: e[&apos;上课学期&apos;] = &apos;1&apos; 存进数据库了。这次还是发现了很多的问题。归根结底，还是基础不太好，是得花时间在研习下Python基础。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梁桥评分系统]]></title>
    <url>%2F2017%2F03%2F12%2F%E6%A2%81%E6%A1%A5%E8%AF%84%E5%88%86%E7%B3%BB%E7%BB%9F-1%2F</url>
    <content type="text"><![CDATA[从理清思路到最后完成，对MATLAB又有了新的认识。虽然算法很简单，就是一个计算器。但是，其本身逻辑思维很复杂。就是一个桥它自己的学问，让我们这些门外汉实在是汗颜啊。所以到最后就是完成了一个很臃肿的exe.快6000行代码了… 最后生成了exe文件。在MATLAB里有运行库的前提下。mbuild -setupmcc -m test.m #梁桥技术评分系统使用须知 ##梁式桥基本结构 ###一、上部结构1、上部承重2、上部一般构件3、支座（三选一）（1）橡胶（2）钢支座（3）混凝土摆式支座 ###二、下部结构1、桥墩（1）墩身（2）盖梁和系梁2、桥台（1）台身（2）台帽3、基础（包括水下基础）4、翼墙、耳墙5、锥坡、护坡6、河床7、调治 ###三、桥面系1、桥面铺装（1）沥青混凝土（2）水泥混凝土2、伸缩缝装置3、人行道4、栏杆、护栏5、防排水系统6、照明标志 ##使用方法1、依次选择 桥梁部位、大部件、小部件。2、输入需要输入的 构件数量，并点击 确定 按钮。3、依次选择 构件编号，并在 灾害标度值 里按照 灾害类型 输入合法的数值。（1）灾害类型 由所选部位、部件给出。（2）灾害标度值默认为1，需要修改为所需的数值。合法数值为[1,5]的整数。（3）每录入一个编号的构件灾害标度值需点击 确定输入 按钮。（4） 上部结构 的 支座 选项中和 桥面系 的 桥面铺装 ，只需选择一项即可计算部件得分。 支座 和 桥面铺装 下的选项不可同时存在，只需选择一项。（5）下部结构 中的 桥墩 、桥台 需要依次输入下属的两个选项的标度值才能计算部件得分。其下属选项是同时存在的，必须全部选择并输入灾害值。4、计算得分（1） 计算部件得分 需要在输入完一个小部件的所有编号的灾害值才能进行计算。（2） 计算部位得分 需要在输入完一组部件的所有编号的灾害值才能进行计算。（3） 计算总体得分需要在输入所有部位的所有部件的所有编号的灾害值才能进行计算。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java调用Python]]></title>
    <url>%2F2017%2F02%2F28%2FJava%E8%B0%83%E7%94%A8Python%2F</url>
    <content type="text"><![CDATA[在Holi，两方面的感受最深刻： 一款APP的开发，从前到后的流程原来是这样啊。 每门语言都有它的强大之处，不是它能不能实现，而是你想不想实现。 联调方案爬虫这边已经把数据存进MySQL了。但是和后台那边还没有想好怎么联调。 想法一：安卓组直接提供爬虫组需要的用户信息。怎么给？http协议？反正我不知道… 想法二：安卓就相当于是前端，它的后台就是后台（这话听起来怪怪的）。直接让后台把用户信息存成一张表。读取每一条用户信息，调用爬虫组的Python程序，参数传入。爬虫组直接将数据又存进后台数据库里。 这个想法应该是可以的，毕竟Java和Python都很强大。 Java调用Python总体思想： 在有新用户加入或者有新的数据需要更新的时候，Java直接调用爬虫并传入参数。结果就是数据存入到了数据库。 了解到Java有Runtime.getRuntime().exec()这样就好办多了。这个方法其实就好像是cmd命令行一样的执行python 程序：1Runtime.getRuntime().exec("python D:\\studentdb.py id password"); id和password就是传入的参数。把原爬虫程序改为：12345678if __name__ == '__main__': # 初始化爬虫对象 xs = XDspiderStudent() # 登录(在此处传入正确的个人学号与密码信息) #从Java里传入参数 xs.login((sys.argv[1]), (sys.argv[2])) xs.Store() xs.saveMysql() 这样即可。 这样需要一个服务器也就可以了。就是不知到怎么部署，还需要学习。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫】（七）Python数据存储之MySQL（下）]]></title>
    <url>%2F2017%2F02%2F28%2FPython%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8BMySQL%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一篇关于Python和MySQL的简单联调做了学习。这次主要是将这个过程再优化扩大点。对教务处需要的数据都进行了处理存进数据库了。也是对bug问题的总结。 我的编程哲学其实这里面一直有一个问题的。之前是Holi的后台一直想要我们把数据存成CSV格式的他再读取存进数据库。可是这件事情在Python这边就可以完成啊。 后面就还是用着这样的想法去做： 从CSV文件里读取存进MySQL。最直接的方法应该是：一步到位直接存进MySQL。 但是我还是认为，先把这个功能实现了才是最重要的。其他的后面可以慢慢改。 这大概也就是Python的编程思想，着重于解决问题，而不是拘泥于语言语法。 图形化MySQL有同学给我推荐了两款Navicat和SQLyog。有另外一个队友也在用SQLyog，我就选它了。确实是比命令行好用多了。也不容易出问题。 在一个数据库里建了学生信息表，成绩表，课表，公告通知表，我的消息表。剩下的问题就是从CSV文件里读取并存进MySQL。 CSV To MySQL与上一篇一样，整体思路是先把爬下来的数据给写入col列，然后把爬下来的数据依行插入。 writer.writerow((&apos;上课学期&apos;,&apos;课程编号&apos;,&apos;课程名称&apos;,&apos;课程学分&apos;,&apos;学位课&apos; ,&apos;成绩&apos;,&apos;获得学分&apos;,&apos;备注&apos;)) insert的数据就和在SQLyog建好表匹配。 sql = &quot;insert into `score`(`term`,`course_id`,`name`,`credit`,`degree_course`,`score`,`gain_credit`,`remarks`)values(%s,%s,%s,%s,%s,%s,%s,%s)&quot; 之前存进的CSV文件有空格的问题也解决了。有函数strip()、rstrip()、lstrip()可以解决这个问题。12cursor.execute(sql, ( e['上课学期'].strip(), e['课程编号'].strip(),e['课程名称'].strip(), e['课程学分'].strip(), e['学位课'].strip(), e['成绩'].strip(),e['获得学分'].strip(), e['备注'].strip(),)) 其实，规则的网页还是比较好处理的。而不规则的网页处理起来还得多想想。tr、td、th、li标签分配的很奇怪。比如我的消息这一页面是这样处理的： try: for row in rows: csvRow = [] for td in row.findAll(&apos;td&apos;)[1:]: for li in td.findAll(&apos;li&apos;)[0::2]: csvRow.append(li.get_text().strip().replace(&apos; &apos;, &apos;&apos;)) writer.writerow(csvRow) finally: csvFile.close() 它的网页源码第一个td里面都是没用的，到后面的li标签甚至要取奇数，因为它只有三个，而第二个是空的。总之，花了点时间完美的存进去了。也算是体会到正则的强大和我还不会。 最后的几张表还是很规则的。 学生信息： 课表： 成绩： 培养计划： 公告通知： bug总结KeyError： 这是在把CSV文件存进MySQL里出现的错误。研究了好久把col列写对着啊，字典怎么会出错。事实证明人变懒就会出错。 模拟登录用的是同一个程序，在同一个程序的基础上改。打开的CSV文件却没有改过来，字典必然不会对。。。低级错误。 blank error: 之前的Python前辈们都会把Python缩进当成一个梗来玩。可是当程序多了起来，这就真的很容易犯错。 除了这个问题，在for循环里也很容易出错。它也没有明显的标示，全凭感觉。就是我觉得它应该是缩进了吧，其实还差好多。我觉得我需要一把游标卡尺来解决这个bug.]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>Python</tag>
        <tag>Holi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客迁移问题]]></title>
    <url>%2F2017%2F02%2F28%2F%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[就在昨天，系统又崩了。 起因调了一会数据库，localhost一直连不上，换成127.0.0.1也连不上。就想着重启试试，结果打开就是 硬件和软件出现问题，无法启动。 修复首先想着就是用winPe修复下引导，可是还是不行。只能安全模式下，把C盘里的数据备份到其他盘里。装系统不怕，半个小时搞定。就怕装软件，各种配置，真是浪费时间。 花了好久把必须要的软件装上了。发现一个问题，平时多收集些软件安装教程和破解教程，在这种事情上很省时间。 博客迁移问题今天就把因重新装系统或者在一台新机上怎么迁移自己的博客写一下。 这个博客是基于hexo的。 安装Node.js 安装github for windows 生成Github和Git Shell两个快捷方式，虽然之前学过git，把代码存到github用git也很方便。但是感觉就个人使用来说，Github for windows或许更方便。不能因为人家傻瓜就说它不好吧。把新改动或者新建的代码扔到文件夹里，它立马就能检测出来，直接提交同步就好了。 登录Github for Windows 配置SSH 用github for windows自带的git shell输入命令：ssh -T git@github.com 安装hexo cd到指定路径下：npm install hexo-cli -g安装完成后，copy之前的Hexo文件进去直接hexo g，hexo d即可完成和之前一样的操作。 重生了就要好好更博，留给自己看。 人脑子还是不能记住太多东西，哪天需要的话还是会回来看看的。]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫】（六）Python数据存储之MySQL（上）]]></title>
    <url>%2F2017%2F02%2F21%2FPython%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8BMySQL%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。 PyMySQL 安装在使用 PyMySQL 之前，我们需要确保 PyMySQL 已安装。PyMySQL 下载地址：https://github.com/PyMySQL/PyMySQL。如果还未安装，我们可以使用以下命令安装最新版的 PyMySQL： pip install PyMySQL 强烈建议使用pip，实在是神器。虽说Python安装第三方库全是看运气，但是自从上手Python3，一直pip从未出错。 之前讲的是讲教务处的数据爬下来存储CSV格式的，现将CSV文件导入MySQL。 用MySQL创建数据库和数据库表不会就去学，才是最实用的学习方法。 本科阶段学过一门数据库的课，SQL，但是早都忘完了。但是概念还是，上手还是很容易的， 1、使用SHOW语句找出在服务器上当前存在什么数据库：SHOW DATABASES;1234567891011mysql&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys|+--------------------+4 rows in set (0.03 sec) 2、创建一个数据库abccs： CREATE DATABASE test12; mysql&gt; CREATE DATABASE test12; 注意不同操作系统对大小写的敏感。 3、选择你所创建的数据库：USE test12 mysql&gt; USE test12 Database changed 此时你已经进入你刚才所建立的数据库test12. 4、 创建一个数据库表：CREATE TABLE student ();首先看现在你的数据库中存在什么表： mysql&gt; SHOW TABLES; Empty set (0.00 sec) 说明刚才建立的数据库中还没有数据库表。下面来创建一个数据库表student: 我们要建立一个学生信息的便，表的内容包含学生：学号、姓名、培养单位、入学年月、专业、导师。 mysql&gt; CREATE TABLE student (id INT,name VARCHAR(20),academy VARCHAR(20),enrollm entdate DATE,major VARCHAR(20),advisor VARCHAR(20)); 由于name等列值是变化的，因此选择VARCHAR，其长度不一定是20。可以选择从1到255的任何长度，如果以后需要改变它的字长，可以使用ALTER TABLE语句。入学日期列则使用DATE数据类型。创建了一个表后，我们可以看看刚才做的结果，用SHOW TABLES显示数据库中有哪些表： mysql&gt; SHOW TABLES; +------------------+ | Tables_in_test12 | +------------------+ | student | +------------------+ 1 row in set (0.00 sec) 5、显示表的结构： DESCRIBE mytable; mysql&gt; DESCRIBE student; +----------------+-------------+------+-----+---------+-------+ | Field | Type| Null | Key | Default | Extra | +----------------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL| | | name | varchar(20) | YES | | NULL| | | academy| varchar(20) | YES | | NULL| | | enrollmentdate | date| YES | | NULL| | | major | varchar(20) | YES | | NULL| | | advisor| varchar(20) | YES | | NULL| | +----------------+-------------+------+-----+---------+-------+ 6 rows in set (0.02 sec) 6、 往表中加入记录 我们先用SELECT命令来查看表中的数据： mysql&gt; select * from student; Empty set (0.00 sec)这说明刚才创建的表还没有记录。 一般情况下加入一条新记录： mysql&gt; insert into mytable -&gt; values (′aabb′,′cc′,′xxxx-xx-xx′,′dddd′); Query OK, 1 row affected (0.05 sec) 再用上面的SELECT命令看看发生了什么变化。我们可以按此方法一条一条地将的记录加入到表中。 再使用如下命令看看是否已将数据输入到数据库表中： mysql&gt; select * from mytable; CSVToMySQL我们要用Python把CSV文件存入MySQL。 对爬取下来的CSV文件做处理：12345678910111213141516csvFile = open('./student.csv', 'w',encoding = 'utf-8')writer = csv.writer(csvFile)writer.writerow(('姓名','学号','培养单位','入学年月','录取方式' ,'专业','研究方向','导师','已完成总学分','学位课加权平均分'))csvRow = []try: for row in rows: for cell in row.findAll('td'): csvRow.append(cell.get_text().strip()) writer.writerow(csvRow)finally:csvFile.close() CSV存为MySQL123456789101112131415161718192021def saveMysql(self): csvFile1 = open('./student.csv', 'r', encoding='utf-8') reader = csv.DictReader(csvFile1) for e in reader: #连接到数据库 connection = pymysql.connect(host='127.0.0.1', user='root', password='root', db='test12', charset='utf8', cursorclass=pymysql.cursors.DictCursor) # 执行sql语句 try: with connection.cursor() as cursor: sql = "insert into `student`(`id`,`name`,`academy`,`enrollmentdate`,`major`,`advisor`)values(%s,%s,%s,%s,%s,%s)" # 使用 execute() 方法执行 SQL 查询 cursor.execute(sql, ( e['学号'].strip(), e['姓名'].strip(),e['培养单位'].strip(), e['入学年月'].strip(), e['专业'].strip(), e['导师'].strip(), )) connection.commit() finally: connection.close() 结果： mysql&gt; select * from student; +------------+--------+--------------------+----------------+------------------- ----+---------------------------------------+ | id | name | academy| enrollmentdate | major | advisor | +------------+--------+--------------------+----------------+------------------- ----+---------------------------------------+ | 1601120338 | 肖洒 | 通信工程学院 | 2016-08-30 | 电子与通信工程]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>Python</tag>
        <tag>Holi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫】（五）数据存储之CSV]]></title>
    <url>%2F2017%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8BCSV%2F</url>
    <content type="text"><![CDATA[一个完整的（大）数据处理可以分为这几个阶段： 数据收集 数据存储 数据建模 数据分析 数据变现。 Holi的项目进度，已经从入门到处理了。 第一步的数据收集基本已经完成。 现在是第二步的数据存储。 讲道理，不懂点前端知识还真不好下手。 看到一堆标签也是很烦的，还好这些东西就想剥洋葱一样，一层一层剥开。 配合上《爱丽丝梦游仙境》的BeautifulSoup，就方便多了。 CSV（ Comma-Separated Values，逗号分隔值）是存储表格数据的常用文件格式。 Microsoft Excel 和很多应用都支持 CSV 格式，因为它很简洁。 Python 的 csv 库可以非常简单地修改 CSV 文件，甚至从零开始创建一个 CSV 文件: 123456789101112131415161718192021import csv csvFile = open("../files/test.csv", 'w+')try: writer = csv.writer(csvFile) writer.writerow(('number', 'number plus 2', 'number times 2')) for i in range(10): writer.writerow( (i, i+2, i*2))finally: csvFile.close()``` 这种方案来处理教务处的数据，就很方便。 这里拿处理课表的来说。 解析课表的网页源码会看到有一个table的标签，这个很重要。 &lt;table id="tableObj" width="99%" border="0" cellspacing="0" cellpadding="0" class="arranging_arrange"&gt;确定了table和class，就看开始剥洋葱了。 import csvfrom urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen(“课表url”)bsObj = BeautifulSoup(html) 看网页源码的classtable = bsObj.findAll(“table”,{“class”:”arranging_arrange”})[0] #剥第一层洋葱rows = table.findAll(“tr”) #存储CSVcsvFile = open(“../files/editors.csv”, ‘wt’, newline=’’, encoding=’utf-8’)writer = csv.writer(csvFile) try: for row in rows: csvRow = [] #继续一层层剥洋葱 for cell in row.findAll([&apos;td&apos;, &apos;th&apos;]): csvRow.append(cell.get_text()) writer.writerow(csvRow) finally: csvFile.close()``` 这样就可以得到存储在当前目录的CSV文件了。 用Notepad++打开可以看，用excel打开会乱码。 虐狗节，撸代码，还有谁。 哈哈哈哈。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Holi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【迟来的年终总结】2016，这一年]]></title>
    <url>%2F2017%2F02%2F10%2F2016-%E8%BF%99%E4%B8%80%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[回顾这一年，年龄在生长，心智在丰富，体型在膨胀。 学了点技术，但是还差得远。 一直在想该怎么总结这个发生了很多事情的2016。 是有成长的，是有变化的。 2016就按照各种社交上的状态来总结吧。 记录下我的流水账，朋友圈也只有从2016开始的。 我保证以后不删朋友圈了。 朋友圈2016.3.26 Bingo~Thx 附图：西安电子科技大学主楼 定位：西安*西安电子科技大学 这是留下的最靠前的一个状态。 我希望这是一个新的开始。 2015~2016这一年经历了考研，痛并快乐着。 简单的道理只有自己去经历才会体会深刻。 考研的这段时间实在是痛苦，但是问自己有收获吗？有！ 一路上也是一波三折，有时候命运就是向上抛的那枚硬币，而我真的不知道结果。 如果真有幸福这种情感一定是在最绝望的时候看到希望。 相信命运，也相信努力。 感谢考研，感谢一路上的支持和关心。 2016.5.21 我也秀一波 骑车打破个人记录 附图:138公里的轨迹图，马嵬驿 定位：西安 这是和舍友一起去骑车玩的。 这也是迄今为止骑车最远的一次吧。 想到他们，好像还是发生在昨天的事情。 可是他们都已经工作半年了。 最远的已经在地球的另一边，两个在北京，还有一个在西安。 总的来讲，我们宿舍还是很棒的，都是优秀的工程师! 想念那些日子。 2016.5.28 打完牌睡觉！明天强攻秦岭主峰 附图：科协天团合照 定位：宝鸡 2016.5.30 老干爹登山代表队成功登顶！海拔3770m 无敌是多么多么寂寞 无敌是多么多么空虚 独自在顶峰中冷风不断的吹过～ 附图：科协天团+太白山美景 定位：宝鸡 科协我家啊！ 之前不知道写了多少关于科协的事情。 总之，感谢科协，感谢所有在科协遇到的人。 大学四年的丰富多彩的，有一大半都来自科协吧。 还是就是主席团的我们几个。 聚是一把火，散是满天星。 2016.5.31 附图：九张青海的美景，草原，雪山，兄弟姐妹们 定位：海北藏族自治州*日磨荣 2016.6.1 潇洒！上天啦！海拔4120。 附图：4120米的海拔，大雪，我和小宏脱掉上衣的合照。 2016.6.2 1、运气就和天气一样好。 2、一场告别旅行，重要的是和谁一起。至于去哪都有意义。 附图：草原，雪山，牛羊，青海湖日出，茶卡盐湖，我们我们我们！ 定位：西宁 我的毕业之旅，刚才太白山上日刷三万步，海拔3770下来，又和舍友同学走上了青海。 毕业旅行是要有的，要好好的告别，要好好的珍惜在一起的时间。 要给你们我们他们留下一张合照。 时间和地点会证明我们以前也是很开心的。 不舍，回忆，涌上心头。 想问自己，真的相信时间吗？ 现在大概还信吧。 2016.6.20 其实可以把曲江校区卖掉 就有钱了 附图：西安理工大学曲江校区操场上过夜的学生上了新浪新闻 我总觉得理工大就像一个默默耕耘的中游学生。 没有那么优秀，也没有那么差劲。 没什么大新闻，就是默默的付出。 理工大是什么样，我就是什么样。 以前抱怨过许多，现在想想每一个选择都会选择到你遇到的人和事。 那四年，我相信我的选择是对的。 2016.6.27 四年前我还坐在下面听，突然这就是在科协的最后一次。 s 附图：科协经验交流会 还是科协。 突然想到默哥。 在科协的日子总是很开心，很值得回忆。 通宵比赛，地下室，办活动，理奥杯，新星杯，工训。 45路,48路，教六。 2016.6.29 最晚毕业照，终于到我们刷毕业照！ 附图：通信122 毕业照 2016.6.30 两位影帝走马上任 兄弟保重 附图：贺亮，李峥，西安火车站 炎热的夏天，也挡不住大家照毕业照的热情。 送走了第一波去工作的。 五味杂陈。 2016.7.03 科协老干部 附图：我们八个 2016.7.04 附图：毕业礼物 一方印章，与君同行。 祖国，荣誉，责任。 2016.7.08 和小宏把宿舍打扫的干干净净。 去图书馆捐了几本书。 2016.7.09 再见，金花路5号 离开宿舍和科协，关上这门就再也打不开。 附图：微电影 金花路5号 豆瓣影评，毕业证，离校通知单，四年的证书，打印的照片 我可真的算是最后一个走的。 把所有东西都准备好了。 送了所有能送走的人。 好像还下了几场大暴雨。 我最后一个人在科协地下室通宵又看了一遍金花路5号。 默默的走了，别了，我的理工大。 2016.8.27 fresh. 附图，西电主楼渲染图 研究生开学的第一天。 我考研期间，心心念念的地方。 是我下一段生活承上启下的一个点。 2016.9.02 开学典礼&amp;给科协留下的我的书 新人与旧事。 现在与过去。 每开始一段新的生活，我们总要适应。 发现新鲜，回顾过去。 都是美好的感觉。 2016.9.13 好久不跑 身体果然跟不上灵魂 附图：五公里 大学毕业前的那段闲时间还是跑了许多的。 我好像从上高中以来都是一直在胖。 然后下决心要瘦下来。 疯狂的在西电的操场上跑。 把脚跑废了，足底筋膜炎。 康复后休息到现在，也就只敢多做点keep。 瘦下来的任务，任重而道远啊。 2016.10.1 在朋友圈发了我博客的链接。 一个月的时间，从什么都不懂到还是什么都不懂得状态下，完成我的个人博客。 还算是在坚持更新把。 虽然是些有的没的。 学习的点点滴滴。 反正是给自己看的。 2016.10.2 厉害了我的国 附小视频：壶口瀑布 定位：延安*黄河壶口瀑布 和家人在一起的日子总是怕短。 怕以后时间会少，就总是珍惜每时每刻。 五一的时候应该是去的汉中。 之前去了安康，商洛。 想把陕西的东南西北都能先看看，以后再去其他地方。 2016.10.29 研会的趣味运动会，我们秘书部承办。 2016.11.2 通远的迎新晚会。 我做了微信墙和抽奖环节的设定。 那段时间真累，因为和俱乐部的事情还重叠了。 2016.11.07 这段忙碌的时间终于完了 网媒组里最近也玩得很开心 我们的温情小话剧也算是一股清流 第一次做视频给了科协 第二次给了华为俱乐部 和最美队友日日夜夜的结果 和以前办活动 做比赛的感觉一样一样的 最后微信墙这种东西为啥我一直都没中过奖 嘻嘻，第一次演话剧，第二次做视频，自己感觉还是做得不错的。 认识新鲜事物的感觉就是很微妙。 2016.11.24 西电华为创新俱乐部，就业分享会学姐专场。 办活动，写策划，PS海报，想文案，选字体，抠细节。 认真总会有收获。 2016.12.10 就是爱爬山 小伙伴们都很给力 开心 附图：安康东梁山美景&amp;网媒组的帅哥美女们 解宇学长组织了一周的技术分析，主要学习了大数据。 对我来说就是入门吧。 身边基本上都是计算机院的同学。 感觉压力好大。想做一个码农也不是那么容易的。 期末的活动就是去爬山啦，当然是我的提议~ 2016.12.19 426！带个口罩还能防一点 那吃进去的食物在此之前有没有戴口罩 记录西安二十三年来最严重的一次雾霾！！！ 真的是可怕。 让我有种以后还要不要再待在西安的想法。 2016.12.25 谢谢有爱的大家 节日快乐 期末全过 附图：送我的两个苹果 感谢新的环境 新的人儿们 2016.1.28 鸡年最早的祝福，大家新年快乐！ 上个本命年还是卖拐和千手观音，时间嗖嗖的～ 没啥想说的了 集个赞吧，谢谢大家 农历新年，我的第二个本命年。 集赞，为的是想要朋友圈朋友们头像来做壁纸。 新的一年，爱家人，爱生活，爱朋友。 博客就是想换一个没人认识的地方继续发牢骚 微博是当新闻看到 也会发牢骚 但是慢慢的不知道怎么的认识的人就又关注我的 说不定那天就注销了 需要一个小众的来记录 证明我曾经活过 over,over 新的学期，新的野蛮生长。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>旧事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫】（四）西电研究生教务系统技术文档]]></title>
    <url>%2F2017%2F02%2F03%2F%E7%88%AC%E8%99%AB-%E8%A5%BF%E7%94%B5%E7%A0%94%E7%A9%B6%E7%94%9F%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F-%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[教务系统爬虫工作初步完成关于教务系统的一系列爬取工作已经初步完成，Holi爬虫组的工作也算正式进入优化阶段。我们需要根据后台组的需要，转换成CVS或数据库形式。需要和后台组进行商量。 实现的功能模拟登陆 此为爬取数据的第一步，之前试过很多方法，遇到的问题也各种各样。 问题的解决： 模拟登陆需要很多东西，一定要根据抓包来进行数据分析，分析报头的组成形式，再模拟报头所需的东西进行模拟post。 模拟登陆作为爬取教务系统的第一步，花的时间也比较久。在学习模拟登陆上也花了很多时间。 通过此次模拟登录的实现，了解到了从发送其请求，到浏览器解析出的网页的整个过程。 鲁棒性问题： 之前缺少所需的报头消息而意外的触发了教务系统的验证码机制。现在报头已经完整，只要学号密码正确是不会触发验证码机制的。但是，如果学号或密码输入错误，是会触发验证码机制的。简单的验证码可以使用Python来进行OCR识别，但是教务处的验证码比较复杂。此问题的解决方案暂定为讲验证码图片呈现给用户，让其进行手动输入。 课表的爬取 课表的行列组合比较复杂，这里只是简单的把课表消息从HTML中解析出来。 后期的工作重点仍在HTML解析和数据处理方面。需要和后台组沟通。 课表的技术文档在上一次文档中简单讲过，现在为了整体阅读性，将其搬移过来： 1、init():两个URL分别为用抓包软件获取的实际登录网址和实际提交账号密码的网址。2、login():用抓包软件获取的用Chrome浏览器登录教务处的head报文，login（）为模拟登录教务处的所需信息。3、Print（）：将登录进去的课程表HTML网页打印出来。4、使用前请确认安装BeautifulSoup模块。请修改里面的学号id和password再进行运行。5、后续将从HTML网页中提取出有用的信息。6、运行login（）后便可以登录进教务处系统，修改Print（）中的URL即可完成不同信息的获取，比如换成成绩网页的URL、教务通知的URL等等。 成绩查询 在 Print 函数中将 get 的网址换成课表的网址即可进行爬取。 对返回的HTML进行了简单的解析，提取了简单的标签，获取的数据可读性不是很强。 与课表的问题一样，后期的重点仍在数据处理。 通知公告的爬取 在西电，最令人烦恼就是你今天去上课了，可是老师翘课了！！！ 一般情况下学生是不会经常去刷教务处网页的，但是教务系统有一个滚动的通知公告。 只要有老师在上面发布调课通知或考试通知，上面就显示。 这上面的公告是全校性的。 同理，这个网页的解析提取比较简单，数据看起来也很和谐。 我的消息 只要用户的老师翘课或者出成绩，个人就会收到该通知。 这个功能的实现，也可以解决后台组一直提倡的个性化推送，教务处已经帮咱们实现了，哈哈哈！ 后期我们只需要隔断时间判断是否有新的通知产生即可得到最新的消息，弹窗通知给用户即可。 待解决的问题数据处理！！这个的工作量和爬取来比还是比较大的。 但是已经迈出了第一步，后面的路会好走许多。 come on ！ 附代码，作备份。 1、课表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#Python35 爬虫 西电 研究生教务处 课表#注：请修改login()学号密码进行爬取#肖洒 2017/1/19 V1.0# -*-encoding:utf-8-*-# coding=utf-8__author__ = 'ysc'import requestsimport csvfrom bs4 import BeautifulSoupclass ScrapeGrade: def __init__(self, auth_url=None, log_url=None): if not auth_url: self.auth_url = "http://ids.xidian.edu.cn/authserver/login?service=http%3A%2F%2Fjwxt.xidian.edu.cn%2Fcaslogin.jsp" self.log_url = "http://jwxt.xidian.edu.cn/caslogin.jsp" else: self.auth_url = auth_url self.log_url = log_url self.session = requests.Session() def login(self, id='学号', password='密码'): r = self.session.get(self.auth_url) data = r.text bsObj = BeautifulSoup(data, "html.parser") lt_value = bsObj.find(attrs=&#123;"name": "lt"&#125;)['value'] exe_value = bsObj.find(attrs=&#123;"name": "execution"&#125;)['value'] params = &#123;'username': id, 'password': password, "submit": "", "lt": lt_value, "execution": exe_value, "_eventId": "submit", "rmShown": '1'&#125; headers = &#123;'User-Agent': "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0", 'Accept': "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Language": "zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3", "Accept-Encoding": "gzip, deflate", "Referer": "http://ids.xidian.edu.cn/authserver/login?service=http%3A%2F%2Fjwxt.xidian.edu.cn%2Fcaslogin.jsp", "Content-Type": "application/x-www-form-urlencoded"&#125; s = self.session.post(self.auth_url, data=params, headers=headers) s = self.session.get(self.log_url) def Print(self): grade_page = self.session.get("http://yjsxt.xidian.edu.cn/eduadmin/findCaresultByStudentAction.do") bsObj2 = BeautifulSoup(grade_page.text, "html.parser") nameList = bsObj2.findAll("td", &#123;"class":"textCenter"&#125;) for name in nameList: print(name.get_text())if __name__ == '__main__': # 初始化爬虫对象 sg = ScrapeGrade() # 登录(在此处传入正确的个人学号与密码信息) sg.login(id='学号', password='密码') sg.Print() 2、通知公告1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#Python35 爬虫 西电研究生教务处 通知公告#注：请修改 login()学号密码进行爬取#肖洒 2017/1/25 V1.0# -*-encoding:utf-8-*-# coding=utf-8__author__ = 'ysc'import requestsimport csvfrom bs4 import BeautifulSoupclass ScrapeGrade: def __init__(self, auth_url=None, log_url=None): if not auth_url: self.auth_url = "http://ids.xidian.edu.cn/authserver/login?service=http%3A%2F%2Fjwxt.xidian.edu.cn%2Fcaslogin.jsp" self.log_url = "http://jwxt.xidian.edu.cn/caslogin.jsp" else: self.auth_url = auth_url self.log_url = log_url self.session = requests.Session() def login(self, id='学号', password='密码'): r = self.session.get(self.auth_url) data = r.text bsObj = BeautifulSoup(data, "html.parser") lt_value = bsObj.find(attrs=&#123;"name": "lt"&#125;)['value'] exe_value = bsObj.find(attrs=&#123;"name": "execution"&#125;)['value'] params = &#123;'username': id, 'password': password, "submit": "", "lt": lt_value, "execution": exe_value, "_eventId": "submit", "rmShown": '1'&#125; headers = &#123;'User-Agent': "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0", 'Accept': "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Language": "zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3", "Accept-Encoding": "gzip, deflate", "Referer": "http://ids.xidian.edu.cn/authserver/login?service=http%3A%2F%2Fjwxt.xidian.edu.cn%2Fcaslogin.jsp", "Content-Type": "application/x-www-form-urlencoded"&#125; s = self.session.post(self.auth_url, data=params, headers=headers) s = self.session.get(self.log_url) def Print(self): grade_page = self.session.get("http://yjsxt.xidian.edu.cn/info/findAllBroadcastMessageAction.do?flag=findAll") bsObj2 = BeautifulSoup(grade_page.text, "html.parser") nameList = bsObj2.findAll("td", &#123;"class":"textTop"&#125;) for name in nameList: print(name.get_text())if __name__ == '__main__': # 初始化爬虫对象 sg = ScrapeGrade() # 登录(在此处传入正确的个人学号与密码信息) sg.login(id='学号', password='密码') sg.Print() 3、成绩查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#Python35 爬虫 西电研究生教务处 成绩查询#注：请修改login()学号密码进行爬取#肖洒 2017/02/01 V1.0# -*-encoding:utf-8-*-# coding=utf-8__author__ = 'ysc'import requestsimport csvfrom bs4 import BeautifulSoupclass ScrapeGrade: def __init__(self, auth_url=None, log_url=None): if not auth_url: self.auth_url = "http://ids.xidian.edu.cn/authserver/login?service=http%3A%2F%2Fjwxt.xidian.edu.cn%2Fcaslogin.jsp" self.log_url = "http://jwxt.xidian.edu.cn/caslogin.jsp" else: self.auth_url = auth_url self.log_url = log_url self.session = requests.Session() def login(self, id='学号', password='密码'): r = self.session.get(self.auth_url) data = r.text bsObj = BeautifulSoup(data, "html.parser") lt_value = bsObj.find(attrs=&#123;"name": "lt"&#125;)['value'] exe_value = bsObj.find(attrs=&#123;"name": "execution"&#125;)['value'] params = &#123;'username': id, 'password': password, "submit": "", "lt": lt_value, "execution": exe_value, "_eventId": "submit", "rmShown": '1'&#125; headers = &#123;'User-Agent': "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0", 'Accept': "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Language": "zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3", "Accept-Encoding": "gzip, deflate", "Referer": "http://ids.xidian.edu.cn/authserver/login?service=http%3A%2F%2Fjwxt.xidian.edu.cn%2Fcaslogin.jsp", "Content-Type": "application/x-www-form-urlencoded"&#125; s = self.session.post(self.auth_url, data=params, headers=headers) s = self.session.get(self.log_url) def Print(self): grade_page = self.session.get("http://yjsxt.xidian.edu.cn/queryScoreByStuAction.do") bsObj2 = BeautifulSoup(grade_page.text, "html.parser") nameList = bsObj2.findAll("td") for name in nameList: print(name.get_text())if __name__ == '__main__': # 初始化爬虫对象 sg = ScrapeGrade() # 登录(在此处传入正确的个人学号与密码信息) sg.login(id='学号', password='密码') sg.Print() 4、我的消息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#Python35 爬虫 西电研究生教务处 我的消息（系统消息、成绩提示等）#注：请修改login()学号密码进行爬取#肖洒 2017/02/01 V1.0# -*-encoding:utf-8-*-# coding=utf-8__author__ = 'ysc'import requestsimport csvfrom bs4 import BeautifulSoupclass ScrapeGrade: def __init__(self, auth_url=None, log_url=None): if not auth_url: self.auth_url = "http://ids.xidian.edu.cn/authserver/login?service=http%3A%2F%2Fjwxt.xidian.edu.cn%2Fcaslogin.jsp" self.log_url = "http://jwxt.xidian.edu.cn/caslogin.jsp" else: self.auth_url = auth_url self.log_url = log_url self.session = requests.Session() def login(self, id='学号', password='密码'): r = self.session.get(self.auth_url) data = r.text bsObj = BeautifulSoup(data, "html.parser") lt_value = bsObj.find(attrs=&#123;"name": "lt"&#125;)['value'] exe_value = bsObj.find(attrs=&#123;"name": "execution"&#125;)['value'] params = &#123;'username': id, 'password': password, "submit": "", "lt": lt_value, "execution": exe_value, "_eventId": "submit", "rmShown": '1'&#125; headers = &#123;'User-Agent': "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0", 'Accept': "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Language": "zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3", "Accept-Encoding": "gzip, deflate", "Referer": "http://ids.xidian.edu.cn/authserver/login?service=http%3A%2F%2Fjwxt.xidian.edu.cn%2Fcaslogin.jsp", "Content-Type": "application/x-www-form-urlencoded"&#125; s = self.session.post(self.auth_url, data=params, headers=headers) s = self.session.get(self.log_url) def Print(self): grade_page = self.session.get("http://yjsxt.xidian.edu.cn/info/findAllMessageAction.do") bsObj2 = BeautifulSoup(grade_page.text, "html.parser") nameList = bsObj2.findAll("li") for name in nameList: print(name.get_text())if __name__ == '__main__': # 初始化爬虫对象 sg = ScrapeGrade() # 登录(在此处传入正确的个人学号与密码信息) sg.login(id='学号', password='密码') sg.Print()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Holi</tag>
        <tag>技术文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟登陆我终于还是进了]]></title>
    <url>%2F2017%2F01%2F21%2F%E7%BB%88%E4%BA%8E%E8%BF%98%E6%98%AF%E8%BF%9B%E4%BA%86%2F</url>
    <content type="text"><![CDATA[爬了这么久的教务处，终于还是绕过了千山万水登进来了。这段时间准备期末考，忙，好久不更博。年终总结也没有写。是时候开更啦！ XDJiao_Wu_Chu.py说明文档1、init():两个URL分别为用抓包软件获取的实际登录网址和实际提交账号密码的网址。2、login():用抓包软件获取的用Chrome浏览器登录教务处的head报文，login（）为模拟登录教务处的所需信息。3、Print（）：将登录进去的课程表HTML网页打印出来。4、使用前请确认安装BeautifulSoup模块。请修改里面的学号id和password再进行运行。5、后续将从HTML网页中提取出有用的信息。6、运行login（）后便可以登录进教务处系统，修改Print（）中的URL即可完成不同信息的获取，比如换成成绩网页的URL、教务通知的URL等等。 #Python35 爬虫 西电 研究生教务处 课表 #肖洒 2017/1/19 V1.0 #请替换id和password再进行使用 # -*-encoding:utf-8-*- # coding=utf-8 __author__ = 'ysc' import requests import csv from bs4 import BeautifulSoup class ScrapeXd: def __init__(self, auth_url=None, log_url=None): if not auth_url: self.auth_url = "http://ids.xidian.edu.cn/authserver/login?service=http%3A%2F%2Fjwxt.xidian.edu.cn%2Fcaslogin.jsp" self.log_url = "http://jwxt.xidian.edu.cn/caslogin.jsp" else: self.auth_url = auth_url self.log_url = log_url self.session = requests.Session() def login(self, id='XXXXXXXXXX', password='XXXXXX'): r = self.session.get(self.auth_url) data = r.text bsObj = BeautifulSoup(data, "html.parser") lt_value = bsObj.find(attrs={"name": "lt"})['value'] exe_value = bsObj.find(attrs={"name": "execution"})['value'] params = {'username': id, 'password': password, "submit": "", "lt": lt_value, "execution": exe_value, "_eventId": "submit", "rmShown": '1'} headers = {'User-Agent': "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0", 'Accept': "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Language": "zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3", "Accept-Encoding": "gzip, deflate", "Referer": "http://ids.xidian.edu.cn/authserver/login?service=http%3A%2F%2Fjwxt.xidian.edu.cn%2Fcaslogin.jsp", "Content-Type": "application/x-www-form-urlencoded"} s = self.session.post(self.auth_url, data=params, headers=headers) s = self.session.get(self.log_url) def Print(self): grade_page = self.session.get("http://yjsxt.xidian.edu.cn/eduadmin/findCaresultByStudentAction.do") bsObj2 = BeautifulSoup(grade_page.text, "html.parser") print(bsObj2) if __name__ == '__main__': # 初始化爬虫对象 sx = ScrapeXd() # 登录(在此处传入正确的个人学号与密码信息) sx.login(id='XXXXXXXXXX', password='XXXXXX') sx.Print()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青春还在，梦想要快]]></title>
    <url>%2F2016%2F12%2F17%2F%E9%9D%92%E6%98%A5%E8%BF%98%E5%9C%A8%EF%BC%8C%E6%A2%A6%E6%83%B3%E8%A6%81%E5%BF%AB%2F</url>
    <content type="text"><![CDATA[青春还在，梦想要快 最近，很忙，很开心最近两周，组内组织开展了学习分享会。关于网络技术和大数据。 我自己准备是git，用了两天大概学习完git的所有知识。又用了两天做了近六十张PPT。 做PPT真的费时费力费脑的事情。基础知识很重要。学习做PPT也是必不可少的. 每晚9点到11点多，大家在分别讲。周末两天也在马不停蹄的讲。还是有收获的。三人行必有我师。 12.9号，周六。忙完了所有的学习分享。周六组内去爬山，东梁。一路上山路很崎岖，但是我内心里是喜欢爬山的. 感觉爬山是在磨砺我的性子，纵使再累，我也一点要坚持下去。山顶的风景一定不会辜负我。 这个山还没有被开发，一切都很原始，路也不太好走。我们是报的团，一行人都是西工大、西电的学生。 大约一百五十人。浩浩荡荡的挺近深山。山里雾气缭绕，树木花草在冬季里也显得十分活波。白雪皑皑，简直就是天然氧吧。和外边的雾霾比起来，不由得让人多吸两口。 山上的风景很美，看到了冰川遗迹，蓝天白云。和小伙伴们在山上吃完了带来的各种零食。拍照聊天，抛掉一切事情。下山的路更难走，一路都是冰雪，时不时一人摔倒，但是越摔大家越开心。 new_project 学长带着做一个app，我主要负责爬去教务处的信息。 考试周要来了，要抓紧时间复习。 “跨出自己的舒服圈，接触外围的’未知区域’，无论是知识还是思维，不断的学习和改进，是对自己最好的投资。”]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫】（三）爬虫之处理简单验证码]]></title>
    <url>%2F2016%2F12%2F16%2F%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%84%E7%90%86%E7%AE%80%E5%8D%95%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[可处理简单的数字验证码。例如：12345import pytesseractfrom PIL import Imageimage = Image.open('vcode.gif')vcode = pytesseract.image_to_string(image)print(vcode) 结果：对于复杂的字母等不可识别。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫】（二）爬取西电教务处成绩]]></title>
    <url>%2F2016%2F12%2F15%2F%E7%88%AC%E5%8F%96%E8%A5%BF%E7%94%B5%E6%95%99%E5%8A%A1%E5%A4%84%E6%88%90%E7%BB%A9%2F</url>
    <content type="text"><![CDATA[爬虫之西电教务处成绩测试代码，遇到验证码，已挂。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280 # -*-encoding:utf-8-*- # coding=utf-8__author__ = 'ysc'import requestsfrom bs4 import BeautifulSoupimport xlrdimport xlwtclass ScrapeGrade: def __init__(self, auth_url=None, log_url=None): if not auth_url: self.auth_url = "http://ids.xidian.edu.cn/authserver/login?service=http%3A%2F%2Fjwxt.xidian.edu.cn%2Fcaslogin.jsp" self.log_url = "http://jwxt.xidian.edu.cn/caslogin.jsp" else: self.auth_url = auth_url self.log_url = log_url self.session = requests.Session() def login(self, id='1601XXXXXX', password='XXXXX'): r = self.session.get(self.auth_url) data = r.text bsObj = BeautifulSoup(data, "html.parser") lt_value = bsObj.find(attrs=&#123;"name": "lt"&#125;)['value'] exe_value = bsObj.find(attrs=&#123;"name": "execution"&#125;)['value'] params = &#123;'username': id, 'password': password, "submit": "", "lt": lt_value, "execution": exe_value, "_eventId": "submit", "rmShown": '1'&#125; headers = &#123;'User-Agent': "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0", 'Accept': "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", # "Host": "ids.xidian.edu.cn", "Accept-Language": "zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3", "Accept-Encoding": "gzip, deflate", "Referer": "http://ids.xidian.edu.cn/authserver/login?service=http%3A%2F%2Fjwxt.xidian.edu.cn%2Fcaslogin.jsp", # 'X-Requested-With': "XMLHttpRequest", "Content-Type": "application/x-www-form-urlencoded"&#125; s = self.session.post(self.auth_url, data=params, headers=headers) s = self.session.get(self.log_url) def store_into_db_by_term(self): # 按学期进行分类 import sqlite3 conn = sqlite3.connect('grades_term.db') # conn.text_factory = str ##!!! c = conn.cursor() try: # init the counter of the sheet row = 0 # 打开成绩页面 grade_page = self.session.get("http://jwxt.xidian.edu.cn/gradeLnAllAction.do?type=ln&amp;oper=qbinfo&amp;lnxndm=2015-2016%D1%A7%C4%EA%B5%DA%D2%BB%D1%A7%C6%DA(%C1%BD%D1%A7%C6%DA)") bsObj2 = BeautifulSoup(grade_page.text, "html.parser") # datas 包含了所有学期的成绩, table datas = bsObj2.find_all("table", attrs=&#123;"class": "titleTop2"&#125;) # seme 指每学期的成绩. table for i, seme in enumerate(datas): #写入一行标题th ths = seme.find_all('th') titles = [] for col, th in enumerate(ths): print(th.string.strip(), end=' ') th = th.string.strip() if th != '学分' and th != "成绩": titles.append(th + r' text') else: titles.append(th + r' real') # table.write(row, col, th.string.strip(), self.set_style('Times New Roman', 220, True)) # Create table sent = '''CREATE TABLE &#123;0&#125; ( '''.format('table' + str(i+1)) for ith, title in enumerate(titles): sent += title if ith &lt; len(titles) - 1: sent += ", " sent += ")" try: c.execute(sent) conn.commit() except sqlite3.OperationalError: pass print('\n') row += 1 # 各科成绩 subs = seme.findAll('td', attrs=&#123;"align": "center"&#125;) col_iter = 0 len_ths = len(ths) grade_subs = [] # sub为具体的某科成绩 for sub in subs: if sub.string: if sub.string.strip() != '': print(sub.string.strip(), end=' ') grade_subs.append("'" + sub.string.strip()+"'") else: print("' '", end=' ') grade_subs.append("' '") else: print(sub.find('p').string.strip(), end=' ') grade_subs.append("'" + sub.find('p').string.strip() + "'") col_iter += 1 if col_iter == len_ths: # 此时一科的成绩以及visited, 该访问下一科 print('\n') # Insert a row of data sent = '''INSERT INTO &#123;0&#125; VALUES( '''.format('table' + str(i+1)) for ith, grade_sub in enumerate(grade_subs): sent += grade_sub if ith &lt; len(grade_subs) - 1: sent += ", " sent += ")" try: c.execute(sent) conn.commit() except sqlite3.OperationalError as e: print(e) print(sent) exit(-2) row += 1 col_iter = 0 grade_subs = [] print("\n") # 保存到xls中 finally: conn.close() def store_into_db_by_prop(self): # 按科目属性(必修\选修)进行分类 import sqlite3 conn = sqlite3.connect('grades_prop.db') c = conn.cursor() try: # init the counter of the sheet row = 0 # 打开成绩页面 grade_page = self.session.get("http://jwxt.xidian.edu.cn/gradeLnAllAction.do?type=ln&amp;oper=sxinfo&amp;lnsxdm=001") bsObj2 = BeautifulSoup(grade_page.text, "html.parser") # datas 包含了所有学期的成绩, table datas = bsObj2.find_all("table", attrs=&#123;"class": "titleTop2"&#125;) # seme 指每学期的成绩. table for i, seme in enumerate(datas): #写入一行标题th ths = seme.find_all('th') titles = [] for col, th in enumerate(ths): print(th.string.strip(), end=' ') th = th.string.strip() if th != '学分' and th != "成绩": titles.append(th + r' text') else: titles.append(th + r' real') # table.write(row, col, th.string.strip(), self.set_style('Times New Roman', 220, True)) # Create table sent = '''CREATE TABLE &#123;0&#125; ( '''.format('table' + str(i+1)) for ith, title in enumerate(titles): sent += title if ith &lt; len(titles) - 1: sent += ", " sent += ")" try: c.execute(sent) conn.commit() except sqlite3.OperationalError: pass print('\n') row += 1 # 各科成绩 subs = seme.findAll('tr', attrs=&#123;'class': "odd"&#125;) col_iter = 0 len_ths = len(ths) grade_subs = [] # sub为具体的某科信息 for sub in subs: infors = sub.findAll('td') #, attrs=&#123;"align": "center"&#125;) for infor in infors: if infor.string: if infor.string.strip() != '': print(infor.string.strip(), end=' ') grade_subs.append("'" + infor.string.strip()+"'") else: print("' '", end=' ') grade_subs.append("' '") else: infor = infor.find('p').string.strip() if infor != '': print(infor, end=' ') grade_subs.append("'" + infor + "'") else: print("' '", end=' ') grade_subs.append("' '") # 此时一科的成绩已经visited, 该访问下一科 print('\n') # Insert a row of data sent = '''INSERT INTO &#123;0&#125; VALUES( '''.format('table' + str(i+1)) for ith, grade_sub in enumerate(grade_subs): sent += grade_sub if ith &lt; len(grade_subs) - 1: sent += ", " sent += ")" try: c.execute(sent) conn.commit() except sqlite3.OperationalError as e: print(e) print(sent) exit(-2) row += 1 col_iter = 0 grade_subs = [] print("\n") # 保存到xls中 finally: conn.close() def set_style(self, name, height, bold=False): style = xlwt.XFStyle() font = xlwt.Font() font.name = name # 'Times New Roman' font.bold = bold font.color_index = 4 font.height = height ''' borders= xlwt.Borders() borders.left= 6 borders.right= 6 borders.top= 6 borders.bottom= 6 ''' style.font = font # style.borders = borders return style def store_into_xls(self): file = xlwt.Workbook() table = file.add_sheet('grades', cell_overwrite_ok=True) # init the counter of the sheet row = 0 # 打开成绩页面 grade_page = self.session.get("http://jwxt.xidian.edu.cn/gradeLnAllAction.do?type=ln&amp;oper=qbinfo&amp;lnxndm=2015-2016%D1%A7%C4%EA%B5%DA%D2%BB%D1%A7%C6%DA(%C1%BD%D1%A7%C6%DA)") bsObj2 = BeautifulSoup(grade_page.text, "html.parser") # datas 包含了所有学期的成绩, table datas = bsObj2.find_all("table", attrs=&#123;"class": "titleTop2"&#125;) # seme 指每学期的成绩. table for seme in datas: #写入一行标题th ths = seme.find_all('th') for col, th in enumerate(ths): print(th.string.strip(), end=' ') table.write(row, col, th.string.strip(), self.set_style('Times New Roman', 220, True)) print('\n') row += 1 # 各科成绩 subs = seme.findAll('td', attrs=&#123;"align": "center"&#125;) col_iter = 0 len_ths = len(ths) # sub为具体的某科成绩 for sub in subs: if sub.string: print(sub.string.strip(), end=' ') table.write(row, col_iter, sub.string.strip()) else: print(sub.find('p').string.strip(), end=' ') table.write(row, col_iter, sub.find('p').string.strip()) col_iter += 1 if col_iter == len_ths: print('\n') row += 1 col_iter = 0 print("\n") # 保存到xls中 file.save('chengji.xls')if __name__ == '__main__': # 初始化爬虫对象 sg = ScrapeGrade() # 登录(在此处传入正确的个人学号与密码信息) sg.login(id='1601XXXXXX', password='XXXXXX') # 保存成绩为excel]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【爬虫】（一）：爬网页、爬图片、自动登录]]></title>
    <url>%2F2016%2F12%2F12%2F%E7%88%AC%E7%BD%91%E9%A1%B5%E3%80%81%E7%88%AC%E5%9B%BE%E7%89%87%E3%80%81%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[一、HTTP协议HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。用于从WWW服务器传输超文本到本地浏览器的传送协议。 HTTP的请求响应模型 客户端发起请求，服务器回送响应。 这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。 工作流程一次HTTP操作称为一个事务，其工作过程可分为四步： 客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。 建立连接后，客户机发送一个请求给服务器。 服务器接到请求后，给予相应的响应信息。 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 请求报头请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。 响应报头响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 二、Python3.X爬虫编程1、简单的爬虫python3.X一个简单的示例爬虫 12345678910import urllib.request url = "http://www.douban.com/" webPage=urllib.request.urlopen(url) data = webPage.read() data = data.decode('UTF-8') print(data) print(type(webPage)) print(webPage.geturl()) print(webPage.info()) print(webPage.getcode()) ###2、伪装成浏览器来爬网页有些网页，比如登录的。如果你不是从浏览器发起的起求，这就不会给你响应，这时我们就需要自己来写报头。然后再发给网页的服务器，这时它就以为你就是一个正常的浏览器。从而就可以爬了！1234567891011121314python3.4 一个简单的示例爬虫 import urllib.request weburl = "http://www.douban.com/" webheader = &#123;'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:23.0) Gecko/20100101 Firefox/23.0'&#125; req = urllib.request.Request(url=weburl, headers=webheader) webPage=urllib.request.urlopen(req) data = webPage.read() data = data.decode('UTF-8') print(data) print(type(webPage)) print(webPage.geturl()) print(webPage.info()) print(webPage.getcode()) 来看看请求报头，就是和我们设置的一个样。返回的HTML是一样的。 3、爬取网站上的图片前面我们可以爬网页了，下一步我们就可以批量的自动下载该网页上的各种数据了，比如，下载该网页上的所有图片。 1234567891011121314151617181920212223242526python3.x 爬虫教程 爬取网站上的图片 import urllib.request import socket import re import sys import os targetDir = r"E:\PythonWorkPlace\load" #文件保存路径 def destFile(path): if not os.path.isdir(targetDir): os.mkdir(targetDir) pos = path.rindex('/') t = os.path.join(targetDir, path[pos+1:]) return t if __name__ == "__main__": #程序运行入口 weburl = "https://www.douban.com/" webheaders = &#123;'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:23.0) Gecko/20100101 Firefox/23.0'&#125; req = urllib.request.Request(url=weburl, headers=webheaders) #构造请求报头 webpage = urllib.request.urlopen(req) #发送请求报头 contentBytes = webpage.read() for link, t in set(re.findall(r'(https:[^\s]*?(jpg|png|gif))', str(contentBytes))): #正则表达式查找所有的图片 print(link) try: urllib.request.urlretrieve(link, destFile(link)) #下载图片 except: print('失败') #异常抛出 4、模拟登陆西电研究生教务处12345678910111213141516171819202122232425262728 #!/usr/bin/env python3 # -*- coding: utf-8 -*-import requestsurl = 'http://jwxt.xidian.edu.cn/caslogin.jsp' #login网址id = '学号'password = '密码'lt_value = 'LT-31860-Nr4DeRHVPUcMaNqcVrB5XxzLecI0ev1481623540759-wHmD-cas'exe_value = 'e1s1'datas = &#123;'username': id, 'password': password, "submit": "", "lt": lt_value, "execution": exe_value, "_eventId": "submit", "rmShown": '1' &#125;headers = &#123;'User-Agent': "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0", 'Accept': "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", # "Host": "ids.xidian.edu.cn", "Accept-Language": "zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3", "Accept-Encoding": "gzip, deflate", "Referer": "http://ids.xidian.edu.cn/authserver/login?service=http%3A%2F%2Fjwxt.xidian.edu.cn%2Fcaslogin.jsp", # 'X-Requested-With': "XMLHttpRequest", "Content-Type": "application/x-www-form-urlencoded" &#125;sessions = requests.session()response = sessions.post(url, headers=headers, data=datas)print(response.status_code) 返回的状态码为200.这里用到了Requests模块，还不会使用的可以查看中文文档 ，它给自己的定义是：HTTP for Humans，因为简单易用易上手，我们只需要传入Url地址，构造请求头，传入post方法需要的数据，就可以模拟浏览器登陆了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小波变换]]></title>
    <url>%2F2016%2F11%2F26%2F%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[在知乎上看到一篇讲解小波变换的文章，感觉十分有趣。做成了PPT准备在图像工程的presentation。原文地址：https://zhuanlan.zhihu.com/p/22450818]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>homework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Double Eleven】风越大，我越浪]]></title>
    <url>%2F2016%2F11%2F14%2FDouble-Eleven%2F</url>
    <content type="text"><![CDATA[你不逼自己一把就不知道自己原来在短时间内可以完成好多事情 一俱乐部排练节目 每天回到宿舍前都能看到零点的西电 二研会的趣味运动会 三做了微信墙做了抽奖功能 迎新晚会那天坐在前排VIP位置旁边的门关不上大礼堂的风呼呼的钻进我的衣服做了一个安静的送财童子 四 与此同时还在夜以继日的做俱乐部周年庆的视频拿起了2014年卸载的会声会影 发了条累累的微博： 这周最大的感受生活不要凑合想做的事情一定要做到最好不要因为难而止步问题总会解决只是时间的问题做有效而有趣的事情少点功利性多干些实事不要想未来它来的太快 五俱乐部五周年庆 六认识了一些牛逼的人儿们还是很高兴来到这里的要把生活过得和我一样潇洒]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直方图规定化]]></title>
    <url>%2F2016%2F11%2F11%2F%E7%9B%B4%E6%96%B9%E5%9B%BE%E8%A7%84%E5%AE%9A%E5%8C%96-1%2F</url>
    <content type="text"><![CDATA[直方图 直方图的观看规则就是“左黑右白”，左边代表暗部，右边代表亮部，而中间则代表中间调。纵向上的高度代表像素密集程度，越高，代表的就是分布在这个亮度上的像素很多。对于一张“正常”的照片来说，直方图应该是中间高两边低。这张照片就是如此。这张照片的直方图显示的信息可以这样分析：照片的最左侧有高度，但是很少。这说明这张照片有阴影，但不多。最右边也有高度，说明有高光，同样很少。这就是一张最正常不过的照片了，它的直方图就是这样的，可以称之为“对比度正常的中间调”。 直方图规定化直方图均衡化能够自动增强整个图像的对比度，但它的具体增强效果不容易控制，处理的结果总是得到全局均匀化的直方图。实际上有时需要变换直方图，使之成为某个特定的形状，从而有选择地增强某个灰度值范围内的对比度。这时可以采用比较灵活的直方图规定化。一般来说正确地选择规定化的函数可以获得比直方图均衡化更好的效果.所谓直方图规定化，就是通过一个灰度映像函数，将原灰度直方图改造成所希望的直方图。所以，直方图修正的关键就是灰度映像函数。 例如：Pr (r)为原图像的灰度密度函数, Pz (z)为希望得到的增强图像的灰度密度函数,二者的直方图如下: 直方图规定化增强处理的步骤如下： 其增强原理是先对原始的直方图均衡化：S = T(r) 同时对规定的直方图均衡化：v = G(z) 由于都是均衡化，故令 S = v，则：z = G-1(v) = G-1[T(r)] 原理： 在Matlab中没有直接实现灰度规定化的函数。但是我们可以通过imhist和histeq两个函数的结合使用来实现。直方图规定化首先也得求灰度图像的灰度级数的概率密度和累计分布函数，得到原始图像和模板图像的灰度累计分布函数直方图后（这里的模板的灰度级数N和原始图像的灰度级数M我们只讨论M&gt;=N的情况），有两种方式将模板灰度分布特征映射到原始图像中。一是单映射规则（SML），二是组映射规则（GML）。 单映射规则（SML） 单映射规则具体操作步骤如下：对一原始图像的每个灰度级数i的灰度累计分布函数（nor_I_hist（i））与模板图像灰度级数灰度累计分布函数值（nor_M_hist（i））作差值后取绝对值运算，比较运算得到的结果，差值绝对值的最小值对应的最小位置便是原始图像映射到模板图像的灰度值。 2.组映射规则（GML） 组映射也是先求出原始图像和模板图像的累计分布函数直方图。在此基础上，与单映射相反，组映射是用模板图像中每个灰度级的累计分布函数（灰度直方图概率密度为0的灰度级除外）依次与原始图像的所有累计分布函数值作差，在所有差值中找出绝对值最小值所对应的原始图像灰度级，将该灰度级与上一次映射灰度级之间的原始图像灰度级都映射为模板图像中与之差值绝对值最小的灰度级。 阐述完上述原理后，我们通过基于Matlab的编程来进一步验证我们方法的正确性。SML结果： GML结果：]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>homework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我从不想未来，它来的太快]]></title>
    <url>%2F2016%2F10%2F30%2F%E6%88%91%E4%BB%8E%E4%B8%8D%E6%83%B3%E6%9C%AA%E6%9D%A5%EF%BC%8C%E5%AE%83%E6%9D%A5%E7%9A%84%E5%A4%AA%E5%BF%AB%2F</url>
    <content type="text"><![CDATA[最近忙的太累每天回到宿舍都快十二点俱乐部的事情和研会的事情 认识了许多有趣的人听说了许多牛逼的故事做了许多开心的事情 有天晚上去听一个关于区块链的讲座主讲人是一个女负责人关于这种技术她说爱伊斯坦说过我从不想未来，它来的太快 这真的是我最近一直思考的未来太快来不及计划 想要尽快肆意的燃烧未来未来未知未知 去做喜欢的事情细心和勤奋能带来好运再忙一周好好休息]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彩色图像中的人脸检测]]></title>
    <url>%2F2016%2F10%2F26%2F%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F%E4%B8%AD%E7%9A%84%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[YCbCr色彩空间 色彩模型vs色彩空间要解开YCbCr色彩空间这个结，色彩模型（color model)和色彩空间(color space)的区别必须要理解。简单来说两者的关系就像设计与实现之间的关系，针对同一种色彩模型可以有多种不同的实现。比如最常见的RGB色彩模型是根据人的眼睛是通过识别红绿蓝三元色来识别所有颜色的原理进行设计的，可是实际应用的时候我们需要把这个设计予以实现，于是就出现了Adobe RGB、sRGB、ProPhoto RGB等不同版本针对RGB色彩模型实现的色彩空间。 回到YCbCr色彩空间，既然说它是色彩空间那它肯定有一个对应的色彩模型，是什么呢？我想说RGB色彩模型。不要着急，可能这里有点儿颠覆你的三观，但是我这么说是有原因的。YCbCr其实是YUV的一个特例，Y表示的是亮度，U表示的蓝色分量的色差（color difference），V表示的是绿色分量的色差（听着有点儿像RGB不是吗）。YUV与RGB的关系其实就是一个线性转换的关系，所以说YUV其实是对RGB的一种再编码，也就是没有RGB就没有YUV，那显示（输出）的时候自然也需要对YUV进行解码生成RGB。 也许关于YUV是色彩模型的说法来源于习惯或者根本就是不理解，但色彩模型和色彩空间的混淆会对YUV和YCbCr的理解产生连带效应，以致于感觉无法理解透彻，对于一个工程师来说一个关键问题理解的模糊是致命的，还嫌坑不够多吗？ YUV vs YCbCr YUV是基于RGB色彩模型的一种色彩空间，设计初衷是因为人对色彩的感知没有对亮度感知灵敏，所以在工业上为了减少图片的体积节省信息输送成本，有必要把亮度这一分量分离出来，再分离出两个颜色色差分量（蓝绿），进而形成了YUV色彩空间。另外YUV的一个好处是彩色电视信号对黑白电视的兼容，因为当两个色差分量值为0的时候（代表没有色差）输出的图像是黑白的。大家可以针对同一张图片调整手机屏幕亮度，你会发现亮度对你色彩的感知影响是相当大的，这是人眼的工作原理。所以我们可以减小两个色差分量的取样进而减少整个图片的体积。 既然YUV是基于RGB的编码，那二者之间必然需要转换公式或者说映射（mapping），而YCbCr只是众多映射中的一种，如下： 可以看到Y值其实就是对RGB三个分量不同权重的取值构成的，可以说整个转换公式最关键的部分就是第一个等式的系数值，这也决定了整个转换公式的其他系数值。所以说系数值代表了这个转换公式，也就代表了YCbCr与RGB的映射关系，而且这一映射关系其实来源于标准ITU-R BT.601的定义，进一步阅读请看YCbCr–Wikipedia。 小结YCbCr色彩空间是YUV色彩空间的特例，而YUV色彩空间是基于RGB色彩模型的一种实现，是对RGB的一种线性编码，并不是另外一种色彩空间。YUV的主要目的是在保证图像显示质量的前提下尽量缩小图像的体积，而且通过把亮度分量从RGB颜色分量中分离出来也能够使黑白显示设备能够兼容彩色信号。YCbCr是YUV家族中在工业领域使用最广泛的一种标准，这也是为什么JPEG内部编码采用YCbCr的原因。 文章来源于http://qtstack.com/colorspace-ycbcr/ 研读上文，才理解了YCbCr。Face detection in color images 文章里系统的讲解了人脸检测的相关算法。 调试通过的matlab程序： %基于Ycbcr色彩空间肤色检测 close all; clear; clc; %将RGB色彩空间转换为Ycbcr色彩空间 Image_RGB = imread('test.jpg'); Image_YCbCr = rgb2ycbcr(Image_RGB);%YCbCr変换 %得到图片的行数与列数 [row column dim] = size(Image_RGB); for i = 1 : row for j = 1 : column Y = double(Image_YCbCr(i, j, 1));%Y成分 表示的是亮度 CbY = double(Image_YCbCr(i, j, 2));%Cb成分 指蓝色色度 CrY = double(Image_YCbCr(i, j, 3));%Cr成分 红色色度 %double去掉显示的就是灰度图像 if (Y < 125 || Y > 188) if (Y < 125) %获得Cb，Cr的均值 CbY_Average = 108 + (125 - Y) * (118 - 108) / (125 - 16);%公式（7） CrY_Average = 154 - (125 - Y) * (154 - 144) / (125 - 16);%公式（8） WCbY = 23 + (Y - 16) * (46.97 - 23) / (125 - 16);%公式（6） 为公式（5）做计算 WCrY = 20 + (Y - 16) * (38.76 - 20) / (125 - 16); elseif (Y > 188) CbY_Average = 108 + (Y - 188) * (118 - 108) / (235 - 188); CrY_Average = 154 + (Y - 188) * (154 - 132) / (235 - 188); WCbY = 14 + (235 - Y) * (46.97 - 14) / (235 - 188); WCrY = 10 + (235 - Y) * (38.76 - 10) / (235 - 188); end %求Cb(Kh), Cr(Kh)的均值 CbKh_Anerage = 108 + (188 - 188) * (118 - 108) / (235 - 188); CrKh_Average = 154 + (188 - 188) * (154 - 132) / (235 - 188); Cb = (CbY - CbY_Average) * 46.97 / WCbY + CbKh_Anerage;%公式（5） Cr = (CrY - CrY_Average) * 38.76 / WCbY + CrKh_Average; elseif (Y >= 125 && Y]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>homework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[满身匪气，野蛮生长--写在1024]]></title>
    <url>%2F2016%2F10%2F24%2F%E5%86%99%E5%9C%A81024%2F</url>
    <content type="text"><![CDATA[早上打开微信看到李Lydia老师突然更新了文章，遂读。 “愿你满身匪气，野蛮生长。” 什么叫做伟大的情操？为推动人类的发展进程而努力的人儿们现在我还体会不到可能还需要赚到更多的钱才能理解吧。不过对一件事情的热爱与兴趣倒真的不需要理由。 以前看到过一位交大老师的话： 你越嫌弃麻烦越懒得学就越可能错过让你动心的人和事错过新的风景 生活真的是变化无穷早已经不想再去想太多对整个人生的不确定性貌似看穿一样珍惜当前 活在当下 做好自己想去做的事情纵使，很忙，没时间做一切想做的事情都在我的timeline 要做就要做好好好学做人，好好学技术身边事，存在即合理不做价值判断，不做道德审判做好自己就已经很不容易 戒躁戒傲戒自大满身匪气，野蛮生长]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Python开发微信公众号（一）]]></title>
    <url>%2F2016%2F10%2F18%2F%E7%94%A8Python%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[以前的想法终于提上日程，总觉得只有在比赛或者项目中才能提高开发效率。想法由来：每天在学习生活中总要去关注一些消息，要登这个网站，要去哪个网站，一次次的输密码，有时候还会输好几次。能不能集成一个平台就能Get到所有的消息？及时！有效！轻便！不错过任何精彩！这将又是我的一个系列，我会花闲碎的时间来一步步完成这个微信公众号的开发。毕竟十月份实在是太忙了。争取一天抽取一小时的时间来学习开发。 1 申请微信公众号略2 SAE如第一张图所示，我选用新浪的SAE，里面创建python2.7的应用。因为这个项目的代码也不会太多，选用SVN进行代码托管，这样的好处就是可以在线编辑代码。git功能强大，感觉在这里有点大材小用。新建应用后我们需要编写编写config.yaml和index.wsgi文件。config.yaml name: pifuhandashu version: 1 libraries: - name: webpy version: "0.36" - name: lxml version: "2.3.4" ... 再引入了web.py框架以及lxml模块。注意缩进，接着我们编写index.wsgi文件。 # coding: utf-8 import os import sae import web from weixinInterface import WeixinInterface urls = ('/weixin','WeixinInterface') app_root = os.path.dirname(__file__) templates_root = os.path.join(app_root, 'templates') render = web.template.render(templates_root) app = web.application(urls, globals()).wsgifunc() application = sae.create_wsgi_app(app) 为了使页面显得更整洁，我们再新建了一个py文件weixinInterface.py weixinInterface.py，注意自己填写一个专属的token，这个等会微信公众号设置里面有用到。 # -*- coding: utf-8 -*- import hashlib import web import lxml import time import os import urllib2,json from lxml import etree class WeixinInterface: def __init__(self): self.app_root = os.path.dirname(__file__) self.templates_root = os.path.join(self.app_root, 'templates') self.render = web.template.render(self.templates_root) def GET(self): #获取输入参数 data = web.input() signature = data.signature timestamp = data.timestamp nonce = data.nonce echostr = data.echostr #自己的token token = "XXXXXXXXXXX" #注意：填写之后在微信公众平台里输入的token！！！ #字典序排序 list = [token, timestamp, nonce] list.sort() sha1 = hashlib.sha1() map(sha1.update,list) hashcode = sha1.hexdigest() #sha1加密算法 #如果是来自微信的请求，则回复echostr if hashcode == signature: return echostr 3 微信开发者模式设置基本设置–&gt;成为开发者–&gt;修改配置URL就是SAE里Python项目应用的链接。比如填写：http://XXXXX.applinzi.com/weixin，后面要加个/weixin，因为web.py设置了/weixin这个路由。完成之后，一定要启用开发者模式！这样基本的框架就搭好了。 4 python代码 一定要注意目录的设置。 Python主要的逻辑代码：wexinInterface.py # -*- coding: utf-8 -*- import hashlib import web import lxml import time import os import re import json import urllib,urllib2 from lxml import etree import requests class WeixinInterface: def __init__(self): self.app_root = os.path.dirname(__file__) self.templates_root = os.path.join(self.app_root, 'templates') self.render = web.template.render(self.templates_root) def GET(self): #获取输入参数 data = web.input() signature=data.signature timestamp=data.timestamp nonce=data.nonce echostr=data.echostr #自己的token token="lalalala" #这里改写你在微信公众平台里输入的token #字典序排序 list=[token,timestamp,nonce] list.sort() sha1=hashlib.sha1() map(sha1.update,list) hashcode=sha1.hexdigest() #sha1加密算法 #如果是来自微信的请求，则回复echostr if hashcode == signature: return echostr def POST(self): str_xml = web.data() #获得post来的数据 xml = etree.fromstring(str_xml)#进行XML解析 mstype = xml.find("MsgType").text fromUser = xml.find("FromUserName").text toUser = xml.find("ToUserName").text if mstype == "event": mscontent = xml.find("Event").text if mscontent == "subscribe": replayText = u'''你好呀，我是Nicolo，你可以安心搞科研，剩下的事情都交给我喽~欢迎调戏我哟''' return self.render.reply_text(fromUser,toUser,int(time.time()),replayText) if mstype == 'text': content = xml.find("Content").text#获得用户所输入的内容 if content == u"电台" or content == "fm" or content == "Fm" or content == "FM": url = 'http://m.xinli001.com/fm/' fmre = urllib.urlopen(url).read() pa1 = re.compile(r'.*?(.*?)-心理FM',re.S) ts1 = re.findall(pa1,fmre) pa3 = re.compile(r'var broadcast_url = "(.*?)", broadcastListUrl = "/fm/items/',re.S) ts3 = re.findall(pa3,fmre) req = urllib2.Request(ts3[0]) response = urllib2.urlopen(req) redirectUrl = response.geturl() musicTitle = ts1[0] musicDes = '' musicURL = redirectUrl HQURL = 'http://m.xinli001.com/fm/' return self.render.reply_sound(fromUser,toUser,musicTitle,musicDes,musicURL,HQURL) elif content == u'电影': douban_url = 'https://movie.douban.com/' douban_html = requests.get(douban_url).text c = re.compile(r']]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Python</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HARD]]></title>
    <url>%2F2016%2F10%2F16%2F%E7%A1%AC%2F</url>
    <content type="text"><![CDATA[以前总想着学好怎么做人，感觉好难。后来想把技术学好，发现也很硬啊。 入门刚开始感觉很简单，越深入越hard。 总是单纯的认为，既然一些商品是有保质期，那么它肯定有个过渡期。只有它在过渡期里把自己包装好，还是能卖出去的。 人也是，或者保质期十年，或二十年。或者一辈子都是过渡期。 每时每刻都在想着怎么包装自己。一次次的不断否定自己。又一次次的重塑自己。褪去童心，失去信任。 生活慢慢变得很hard，心也越来越hard。 失眠成常态。每天忙忙碌碌。这周的常态。 周末跑个五公里，吃个羊肉泡馍。生活还是不错的嘛。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web（二）：Django概述]]></title>
    <url>%2F2016%2F10%2F15%2FWeb%EF%BC%88%E4%BA%8C%EF%BC%89Django%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[昨晚下了一晚的雨，早上研会的趣味运动会忙了一早上，下午是时候学习了。（白眼）写在前面之前看 learn python the hard way 推荐使用Notepad++，感觉遇到了神器，再也不用烦恼那些东西打不开。简直就是万能编辑器。就是用的着款万能编辑器我修改了我不认识的html、js等文件做了这个博客。那个整本书的代码就是用这个编辑器码的。But,也就像那本书的作者说的一样，一款简单的编辑器足够入门。但是现在学python进阶，感觉还是得需要一款高大上的编辑器。刚开始试了试pycharm，说句实话，简直不能再难用（主要还是生产力工具不给力，略卡）。后来也就装了sublime Text3，感觉挺简洁实用的。在安装过程中也遇到不少的错误，最后也都解决了。主要是安装的那些插件很给力。 视觉享受绝对是学习中的舒服的沙发啊。 安装Django1.pip安装:pip install Django==1.7.52.git安装：git clone https://github.com/django/django.git3.下载pip,python执行:python setup.py install我用的是Pyhton2.7，现在的python 3.x，好像都自带pip。而我的没有，考虑到以后可能会经常用到pip，就安装了pip. 创建django 创建语句及运行语句： 在sublime里改生成的settings.py文件。 INSTALLED_APPS = ( 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'myTest', ) 结果显示]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫入门（四）：urllib2]]></title>
    <url>%2F2016%2F10%2F14%2F%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aurllib2%2F</url>
    <content type="text"><![CDATA[主要使用python自带的urllib2进行爬虫实验。写在前面的蠢事：本来新建了一个urllib2.py便于好认识这是urllib2的实验，结果始终编译不通过，错误错误。不能用Python的关键字（保留字）来命名py文件，改了就好了。 正则表达式与re Python 通过 re 模块提供对正则表达式的支持。使用 re 的一般步骤是：Step1：先将正则表达式的字符串形式编译为Pattern实例。Step2：然后使用Pattern实例处理文本并获得匹配结果（一个Match实例）。Step3：最后使用Match实例获得信息，进行其他的操作。 #!/usr/bin/env python # -*- coding: utf-8 -*- # @Date : 2016-10-14 21:16:25 # @Author : Nicolo (1241251168@qq.com) # @Link : http://www.xiaosablog.cf/ # @Version : $Id$ #一个简单的re实例，匹配字符串中的hello字符串 #导入re模块 import re # 将正则表达式编译成Pattern对象，注意hello前面的r的意思是“原生字符串” pattern = re.compile(r'hello') # 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None match1 = pattern.match('hello world!') match2 = pattern.match('helloo world!') match3 = pattern.match('helllo world!') #如果match1匹配成功 if match1: # 使用Match获得分组信息 print match1.group() else: print 'match1匹配失败！' #如果match2匹配成功 if match2: # 使用Match获得分组信息 print match2.group() else: print 'match2匹配失败！' #如果match3匹配成功 if match3: # 使用Match获得分组信息 print match3.group() else: print 'match3匹配失败！' 编译结果： hello hello match3匹配失败！ 糗事百科的网络爬虫 import urllib2 import urllib import re import thread import time #----------- 加载处理糗事百科 ----------- class Spider_Model: def __init__(self): self.page = 1 self.pages = [] self.enable = False # 将所有的段子都扣出来，添加到列表中并且返回列表 def GetPage(self,page): myUrl = "http://m.qiushibaike.com/hot/page/" + page user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)' headers = { 'User-Agent' : user_agent } req = urllib2.Request(myUrl, headers = headers) myResponse = urllib2.urlopen(req) myPage = myResponse.read() #encode的作用是将unicode编码转换成其他编码的字符串 #decode的作用是将其他编码的字符串转换成unicode编码 unicodePage = myPage.decode("utf-8") # 找出所有class="content"的div标记 #re.S是任意匹配模式，也就是.可以匹配换行符 myItems = re.findall('(.*?)',unicodePage,re.S) items = [] for item in myItems: # item 中第一个是div的标题，也就是时间 # item 中第二个是div的内容，也就是内容 items.append([item[0].replace("\n",""),item[1].replace("\n","")]) return items # 用于加载新的段子 def LoadPage(self): # 如果用户未输入quit则一直运行 while self.enable: # 如果pages数组中的内容小于2个 if len(self.pages) < 2: try: # 获取新的页面中的段子们 myPage = self.GetPage(str(self.page)) self.page += 1 self.pages.append(myPage) except: print '无法链接糗事百科！' else: time.sleep(1) def ShowPage(self,nowPage,page): for items in nowPage: print u'第%d页' % page , items[0] , items[1] myInput = raw_input() if myInput == "quit": self.enable = False break def Start(self): self.enable = True page = self.page print u'正在加载中请稍候......' # 新建一个线程在后台加载段子并存储 thread.start_new_thread(self.LoadPage,()) #----------- 加载处理糗事百科 ----------- while self.enable: # 如果self的page数组中存有元素 if self.pages: nowPage = self.pages[0] del self.pages[0] self.ShowPage(nowPage,page) page += 1 #----------- 程序的入口处 ----------- print u""" --------------------------------------- 程序：糗百爬虫 操作：输入quit退出阅读糗事百科 功能：按下回车依次浏览今日的糗百热点 --------------------------------------- """ print u'请按下回车浏览今日的糗百内容：' raw_input(' ') myModel = Spider_Model() myModel.Start()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web（一）:概述]]></title>
    <url>%2F2016%2F10%2F12%2FWeb%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[学Python也有一段时间了，学完基本语法后整个人都蒙了。没有什么可以来练手，感觉什么也不会。准备主攻爬虫和Web。昨晚学长刚给讲了MVC，回来看到Python的Web就看到MVC。 C/S结构和B/S结构 C/S-Client/Server 客户机/服务器结构B/S-Browser/Server 浏览器/服务器结构 B/S优势： 不用安装软件 不用通知升级 轻松跨平台 访问网站过程： 用户向Web服务器发起请求 Web服务器返回html给用户 用户浏览器将html渲染成网页 静态网站 用户向Web服务器请求，Web服务器会直接将html返回给用户。 动态网站 用户向Web服务器请求。 Web服务器执行Python程序，将执行结果输出成html文件返回给用户。Web服务器可以修改html文件结果。网站会因为用户的请求不同的呈现出不同的结果。也就是动态网站的由来。 采用MVC设计Web应用 M: Model模型，存储Web应用数据的代码V： View视图，格式化和显示Web应用的用户界面的代码。C: Controller控制器，将Web应用粘合在一起并提供业务逻辑的代码。 CGI Common Gateway Interface 通用网关接口 可以让一个客户端，从网页浏览器向服务器请求数据。这是描述客户端和服务器程序之间传输数据的一种标准。 应用于Web的编程语言PHPASP/ASP.netJSPPython 前端程序 HTMlCSSJS 后台程序 PythonPHPJSP 数据库 –与后台程序进行数据交互 MysqlMongoDB 前端 HTML：Hyper Text Markup Language 超文本标记语言 CSS：Cascading Style Sheet 层叠样式表 JS ：JavaScript 后端 PythonPHPJSP··· 数据库及静态存储 Mysql SQLite MongoDB HTML和JavaScript的简单介绍 目标:使用HTML语言和JS语言，编写程序。实现两数相加。新建index.html文件： &lt;head&gt; &lt;title&gt;Calculator&lt;/title&gt; &lt;script src=&quot;add.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=&quot;center&quot; style=&quot;margin-top:60px;&quot;&gt; &lt;form name=&quot;form1&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;adder&quot; name=&quot;adder1&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;adder-2&quot; name=&quot;adder2&quot;&gt;= &lt;input type=&quot;text&quot; readonly=&quot;readonly&quot; placeholder=&quot;result&quot; name=&quot;result&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;calculate&quot; onclick=&quot;add()&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;footer&gt; &lt;/footer&gt; 新建add.js文件： function add() { var adder1=Number(document.form1.adder1.value); var adder2=Number(document.form1.adder2.value); var result=adder1+adder2; document.form1.result.value=result; } 显示为: Calculator &gt; = 上面的只是html文件，不能计算出结果。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP（一）]]></title>
    <url>%2F2016%2F10%2F10%2FTCP-IP%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[IP协议 IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。TCP协议 TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。一个IP包除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。端口有什么作用？在两台计算机通信时，只发IP地址是不够的，因为同一台计算机上跑着多个网络程序。一个IP包来了之后，到底是交给浏览器还是QQ，就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的IP地址和各自的端口号。 TCP编程 Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。 客户端 大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。创建一个基于TCP连接的Socket: # 导入socket库: import socket # 创建一个socket: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 建立连接: s.connect(('www.sina.com.cn', 80)) 创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议，这样，一个Socket对象就创建成功，但是还没有建立连接。客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。新浪网站的IP地址可以用域名www.sina.com.cn自动转换到IP地址，但是怎么知道新浪服务器的端口号呢？ 答案是作为服务器，提供什么样的服务，端口号就必须固定下来。由于我们想要访问网页，因此新浪提供网页服务的服务器必须把端口号固定在80端口，因为80端口是Web服务的标准端口。其他服务都有对应的标准端口号，例如SMTP服务是25端口，FTP服务是21端口，等等。端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。 接新浪服务器的代码如下： s.connect((&#39;www.sina.com.cn&#39;, 80))注意参数是一个tuple，包含地址和端口号。 建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容：发送数据: s.send(‘GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n’)TCP连接创建的是双向通道，双方都可以同时给对方发数据。但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。 发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收新浪服务器返回的数据了： # 接收数据: buffer = [] while True: # 每次最多接收1k字节: d = s.recv(1024) if d: buffer.append(d) else: break data = ''.join(buffer) 接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。 当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了： 关闭连接: s.close() 接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件： header, html = data.split('\r\n\r\n', 1) print header # 把接收的数据写入文件: with open('sina.html', 'wb') as f: f.write(html)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>TCP</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫入门（三）：BeautifulSoup]]></title>
    <url>%2F2016%2F10%2F10%2F%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ABeautifulSoup%2F</url>
    <content type="text"><![CDATA[BeautifulSoup，网页解析器，DOM树，结构化解析。 1 安装 BeautifulSoup4.x 兼容性不好，选用BeautifulSoup3.x + Python 2.x.下载安装包放在/lib文件下，DOS下输入:1 python setup.py build2 python setup.py install 2 测试 IDLE里输入: import BeautifulSoup print BeautifulSoup运行显示： &lt;module &#39;BeautifulSoup&#39; from &#39;C:\Python27\lib\site-packages\BeautifulSoup.pyc&#39;&gt; 3 网页解析器-BeautifulSoup-语法 由HTLM网页可进行以下活动： 创建BeautifulSoup对象 搜索节点find_all/find 访问节点名称、属性、文字 例如： &lt;a herf=&#39;123.html&#39; class=&#39;article_link&#39;&gt; Python&lt;/a&gt; 节点名称：a 节点属性：herf=’123.html’节点属性：class=’article_link’ 节点内容：Python 4 创建BeautifulSoup对象 import BeautifulSoup #根据HTML网页字符串创建BeautifulSoup对象 soup = BeautifulSoup( html_doc, #HTLM文档字符串 'htlm.parser' #HTLM解析器 from_encoding='utf8' #HTLM文档的编码 ) 5 搜索节点（find_all,find） #方法：find_all(name,attrs,string) #查找所有标签为a的节点 soup.find_all('a') #查找所有标签为a,链接符合/view/123.htlm形式的节点 soup.find_all('a',href='/view/123.htlm') soup.find_all('a',href=re.compile(r'/view/d+\.htm')) #查找所有标签为div,class为abc,文字为Python的节点 soup.find_all('div',class_='abc',sting='Python') 6 访问节点信息 #得到节点：Python #获得查找到的节点的标签名称 node.name #获得查找到的a节点的href属性 node['herf'] #获取查找到的a节点的链接文字 node.get_text() 7 实例测试 #coding:utf-8 from bs4 import BeautifulSoup html_doc = &quot;&quot;&quot; &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt; &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;, &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;; and they lived at the bottom of a well.&lt;/p&gt; &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt; &quot;&quot;&quot; #创建对象 soup = BeautifulSoup(html_doc, &apos;htlm.parser&apos;, from_encoding=&apos;utf-8&apos;) #参数：文档字符串，解析器，指定编码 print &apos;获取所有的链接&apos; links = soup.find_all(&apos;a&apos;) #获取所有的链接 for link in links: print link.name, link[&apos;href&apos;],link.get_text() #名称，属性，文字]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我为什么要买高尔夫球]]></title>
    <url>%2F2016%2F10%2F09%2F%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B9%B0%E9%AB%98%E5%B0%94%E5%A4%AB%E7%90%83%2F</url>
    <content type="text"><![CDATA[我不仅买了高尔夫球，还想买网球。 这段时间发生了许多令我震惊的事情。许多人不经意间就猝死了。 中国传媒大学通信专业搞音视频的博士雷神，春雨医生CEO张锐，微博上的装配脑袋。人有时候怎么就那么脆弱。 小时候刚学会游泳那会，感觉自己有水的地方都敢下。大河里，水库里。管它水有多深，管它水里面有什么。 推着水库旁边没人管的船就划到水库中央。脱个精光，纵身而跃。在山里的大石头上，潇洒的跳到深水里。我那时候怎么那么不怕死。现在除了泳池，其他水里都不敢下。人越长大越怕死。 大一那会儿体测，一千米跑完感觉要死。大二那会跑完也要死。大三开始跑步，一个人使劲跑。慢慢加到五公里。那年体测跑了班里第三名。跑完不用休息，潇洒的走了。 后来考研，放弃了一段时间。再后来再跑，脚疼的受不了。跑一次休息三天。脚跑废了。 毕业后断断续续的跑，或者不跑。越来越觉得身体比较重要。准备再跑起来，脚病再犯。一查是足底筋膜炎。 失眠一直是折磨我的一件事。每天晚上就开始探索宇宙真理。辗转反侧，思绪万千。最近也在找各种方法治疗失眠。 希望过的潇洒，过的让家人放心。爱自己才能更好的爱他人。一切还没开始，我不能先倒下。就从踩高尔夫球开始，治疗足底角膜炎。再次跑起来。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>旧事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承和多态]]></title>
    <url>%2F2016%2F10%2F09%2F%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[这里继承和多态的概念与java的概念差不多。概念还是需要多次理解才能透彻。感觉类和实例的概念还是不能深刻理解。再次复习下吧。 在面向对象的程序设计中，定义一个class时，可以从之前现有的class继承。新的class称为子类，被继承的叫做父类（或者是他们称为的基类/超类）。比如： class Animal(object): def run(self): print 'Animal is running...' 需要编写Dog和Cat类时，就可以直接从Animal类继承： class Dog(Animal): pass class Cat(Animal): pass 对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法： dog = Dog() dog.run() cat = Cat() cat.run() 也可以对子类增加一些方法，比如Dog类： class Dog(Animal): def run(self): print 'Dog is running...' def eat(self): print 'Eating meat...' 继承的第二个好处需要我们对代码做一点改进。无论是Dog还是Cat，它们run()的时候，显示的都是Animal is running…，符合逻辑的做法是分别显示Dog is running…和Cat is running…，因此，对Dog和Cat类改进如下： class Dog(Animal): def run(self): print 'Dog is running...' class Cat(Animal): def run(self): print 'Cat is running...' 当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样： a = list() # a是list类型 b = Animal() # b是Animal类型 c = Dog() # c是Dog类型 在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量： def run_twice(animal): animal.run() animal.run() 传入Animal的实例时，run_twice()就打印出： >>> run_twice(Animal()) Animal is running... Animal is running... 传入Dog的实例时，run_twice()就打印出： >>> run_twice(Dog()) Dog is running... Dog is running... 传入Cat的实例时，run_twice()就打印出： >>> run_twice(Cat()) Cat is running... Cat is running... 现在，如果我们再定义一个Tortoise类型，也从Animal派生： class Tortoise(Animal): def run(self): print 'Tortoise is running slowly...' 调用run_twice()时，传入Tortoise的实例： >>> run_twice(Tortoise()) Tortoise is running slowly... Tortoise is running slowly... 会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。 多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思。 对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则。 对扩展开放：允许新增Animal子类对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。 继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。 小结 继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写； 有了继承，才能有多态。在调用类实例方法的时候，尽量把变量视作父类类型，这样，所有子类类型都可以正常被接收； 旧的方式定义Python类允许不从object类继承，但这种编程方式已经严重不推荐使用。任何时候，如果没有合适的类可以继承，就继承自object类。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书摘]]></title>
    <url>%2F2016%2F10%2F05%2F%E4%B9%A6%E6%91%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一只特立独行的猪 –王小波 用一片童心来思考问题，很多烦难的问题就变得易解。 我为什么要写作有人问一位登山家为什么要去登山??谁都知道登山这件事既危险，又没什么实际的好处，他回答道：“因为那座山峰在那里。” 想要读好文字就要去读译著，因为最好的作者在搞翻译。 我念过文科，也念过理科。在课堂上听老师提到艺术这个词，还是理科的老师次数更多：化学老师说，做实验有实验艺术；计算机老师说，编程序有编程艺术。老师们说，怎么做对是科学，怎么做好则是艺术；前者有判断真伪的法则，后者则没有；艺术的真谛就是要叫人感到好，甚至是完美无缺；传授科学知识就是告诉你这些法则，而艺术的修养是无法传授的，只能够潜移默化。这些都是理科老师教给我的，我觉得比文科老师讲得好。 我没有读过大学的中文系，所以孤陋寡闻，但我以为，人活在世上，不必什么都知道，只知道最好的就够了。 围城 –钱钟书 这是七月下旬，合中国旧历的三伏，一年最热的时候。在中国热得更比常年利害，事后大家都说是兵戈之象，因为这就是民国二十六年(一九三七年)。 柏拉图《理想国》里就说兵士对敌人，医生对病人，官吏对民众都应哄骗。 他不肯原谅，也许因为他自己不需要人原谅，不知道也需要人原谅。 干政治的人先去教书，一可以把握青年心理，二可以训练自己的干部人才。 这不是大教授干政治，这是小政客办教育。从前愚民政策是不许人民受教育，现代愚民政策是只许人民受某一种教育。不受教育的人，因为不识字，上人的当，受教育的人，因为识了字，上印刷品的当。 人生是围城，婚姻是围城，进了去，就被生存的种种烦愁包围。城里的人想逃出来，城外的人想冲进去。 女人不肯花钱买书，大家都是知道的男人肯买糖，衣料，化妆品，送给女人，而对于书只肯借给她，不买了送她，女人也不要他送。这是什么道理？借了要还的，一借一还，一本书可以做两次接触的借口，而且不着痕迹。这是男女恋爱必然的初步，一借书，问题就大了！ 经过长期苦旅行而彼此不讨厌的人，才可以结交作朋友。 老婆和老妈掉进了河里，我先救老妈，因为是老妈给了我生命，我找不到任何理由丢下她不管。老婆如果没救上来，我可以再给她陪葬，在墓里继续我们的爱情。 天地间有许多景象是要闭了眼才看得见的，譬如梦。 她忙到窗口一望，果然鸿渐背马路在斜对面人家的篱笆外站着，风里的雨线像水鞭子正侧横斜地抽他漠无反应的身体。她看得心溶化成苦水。 方鸿渐把信还给唐小姐时，痴钝并无感觉。过些时，他才像从昏阙里醒过来，开始不住的心痛，就像因蜷曲而麻木的四肢，到伸直了血脉流通，就觉得刺痛。 解忧杂货店 –东野圭吾 人与人之间的关系往往不是因为某些具体的原因而断绝。即使表面上有某种原因，其实是因为彼此的心已不在一起，事后才牵强附会地找这些借口。因为如果彼此的心没有分开，当发生可能会导致彼此关系断绝的事态时，某一方就会主动修复。之所以没有人修复，就是因为彼此的心已经不在一起了。 其它的信也几乎都是感谢我的答复，虽然很感激，但看了之后，我发现我的答复之所以能够对他们有帮助，是因为他们自己本身就拥有正确的心态。如果他们没有想要认真生活、努力生活的态度，无论别人回答什么，恐怕都帮不了他们。 通常谘商者心里已经有了答案，找人谘商的目的，只是为了确认这个答案是正确的。 其实只要有才华，根本不需要什么运气。 即使遇到不懂的事，也不能立刻开口问别人，要自己先好好查数据。 因为别人通常不会来向我们倾诉烦恼，也不会来找我们这种人商量，恐怕一辈子都不会有这种机会。这是第一次，也可能是最后一次，所以，有一次这样的经验也不错。 有时候不是会觉得有人愿意听自己说话，就很感恩吗？心里有烦恼的时候，如果无法向别人倾诉，就会很痛苦。 浪潮之巅 –吴军 一个真正具有世界历史意义的时刻——一个人类群星闪耀的时刻出现以前，必然会有漫长的岁月无谓地流逝。不过，诚如在艺术上一旦有一位天才产生就会流芳百世一样，这种具有世界历史意义的时刻一旦发生，就会决定几十年乃至几百年的历史进程。那些数不胜数的事件也都往往像避雷针的尖端集中了整个大气层的电流一样，集中在极短的时间内发生。那些平时慢慢悠悠顺序发生和并列发生的事，都压缩在这样一个决定一切的短暂时刻表现出来。这一时刻对世世代代作出不可改变的决定，它决定着一个人的生死，一个民族的存亡甚至整个人类的命运。 我很喜欢德国一位诗人讲过的一句话：亘古而常青的昨天永远是过去，也永远会再来。 硅谷几十年经验证明，那些初出茅庐能干具体事情的年轻人，可能比一个经验丰富但是已经眼高手低的权威对公司更有用。 我的一个朋友在 2002 年创立了一个小公司，打出招人的广告，讲明是没有工资的。（当然，用了一个好听的说法叫“合伙创业”，可以得到一些可能有意义，也可能是废纸的股票）居然在短短的几天里收到上百份简历，其中很多是水平超出要求的工程师。 最后，也是最重要的，创业者必须有好运气。 真正具备这些条件已经很不容易了。而一个初创公司的成功很大程度上还要看外部环境好不好，很多很有前途的公司因为创办的时机不对，也会随着经济大环境的衰退而夭折。 再接下来是判断力和执行力。通常，办起一个公司并不难，把它从小做到大，并且做到盈利就不容易。 但是光有好的团体和技术又远远不够，他们有商业头脑而且必须找到一个能盈利的商业模型（Business Model）。 一个小公司要想成功，有很多因素必须同时具备。首先，创始人很重要。 那么，是什么动力促使人们不断地更新自己的硬件呢？IT 界把它总结成安迪-比尔定理，即比尔要拿走安迪所给的（What Andy gives, Bill takes away）。 有一位先哲说过，社会的需求对科技进步的作用要超过十所大学。 在计算机的研制过程中有无数的科学家和工程师作出了卓越的贡献，但是最主要的三个人应当是冯·诺伊曼（Von Neumann，看过美国电影《美丽人生》，和中国电视剧《暗算》的人应该对他有印象） — 见附图、毛奇莱（John Mouchly）和艾科特（Presper Eckert),应该讲冯·诺依曼是今天运行程序的电子计算机结构（architechture）的主要提出者，这个被称为冯·诺依曼的系统结构影响至今。 IBM PC 唯一一个操作系统的内核 BIOS 是自己的，但是很容易地就被破解了。 凡是和微软合作的公司，最后都没有好结果。IBM 也许是其中第一个吃亏者。 今天，IBM 成为了世界上最大的开源操作系统 Linux 服务器的生产商。 第一，IBM 笔记本 Thinkpad 是笔记本电脑的第一品牌，联想买下这个品牌就可以直接在世界各地销售自己品牌的电脑，而不是为美日公司组装机器。有时，即使花很多时间和金钱，也不一定能创出一个世界级的品牌。联想这次一步到位。第二，当时联想笔记本在世界市场上销量不过2%，这个市场份额无足轻重，根本无法和dell、惠普等公司竞争。当时IBM有5%的市场份额，两家加起来大约有7%，这个份额在世界上可以进前五名，和美日公司就有一拼了。 今天，世界上主要的语音识别公司只剩下 Nuance 一家，美国整个语音识别市场的规模一年不到五亿美元，相当于谷歌两个星期的收入。而同时，世界上对文字处理、图像处理技术的需求随着互联网的普及不断增加。 在二战中，贝尔实验室的天才青年科学家香农提出的信息论。信息论是整个现代通信的基础。 这使得贝尔实验室不仅在通信领域长期执牛耳，而且在射电天文学、晶体管和半导体、计算机科学等领域领先于世界。它著名的发明除电话本身外，还包括射电天文望远镜、晶体管、电子交换机、计算机的 Unix 操作系统和 C 语言等等。此外，贝尔实验室还发现了电子的波动性，发明了信息论，发射了第一颗通信卫星，铺设了第一条商用光纤。在相当长的时间内，贝尔实验室不仅仅是信息领域科学家的首选工作单位，也是基础研究领域学者趋之若鹜的地方。那个时代进入贝尔实验室的人是很幸运的。如果是个人物，他可以成为业界的领袖，甚至得到诺贝尔奖、香农奖或者图灵奖。即使是一般的研究员和工程师，也会有很好的收入、可靠的退休保障以及受人尊重的社会地位。 一九二五年，AT&amp;T 公司成立的研发机构贝尔实验室。 虽然对于一个公司来讲，赶上一次浪潮不能保证它长盛不衰；但是，对于一个人来讲，一生赶上这样一次浪潮就足够了。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>书摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北纬三十六]]></title>
    <url>%2F2016%2F10%2F04%2F%E5%8C%97%E7%BA%AC%E4%B8%89%E5%8D%81%E5%85%AD%2F</url>
    <content type="text"><![CDATA[以前总抱怨，没能挑选一个外地的大学去。后来觉得陪着父母真的好。男儿志在四方？父母在不远游？树欲静而风不止，子欲养而亲不待。以前总相信一切可相信之事。信规则，信人情世故。现在，不敢想太远，不敢奢求太多。对于未来的不确定性更持肯定的态度。现在即是未来。 走在延安的山路，想到很多场景。《平凡的世界》 里的孙少安、孙少平。《血色浪漫》 里的钟跃民。这片神奇的土地。 最没想到的是多变的气候。有点像之前去青海的卓尔山。温度并不高，紫外线极强，晒！早上和晚上又十分冷。这就是苹果比较好吃的原因？温差大，消耗的糖少？产的糖多？ 从宜川去延安的晚上，看到许多小型的油井。人烟稀少，附近的每户人家院子里都有一个喷火杆？猜想是用天然气来照明。资源丰富就是这么任性。 北纬36度，一个孤独的纬度。和家人在一起又是最幸福最温暖的。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>行走</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫入门（二）：单线程爬虫]]></title>
    <url>%2F2016%2F09%2F25%2F%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[Requests介绍与安装 Windows环境下:pip install requests Linux环境下：sudo pip install requests 第三方库安装技巧 少使用easy_install因为只能安装不能卸载 多用pip方式安装 撞墙了怎么办？请戳-&gt;第三方库安装技巧 将下载的后缀为whl的文件改为zip, 解压文件，获得requests文件，拷贝到C盘的python/lib文件夹中。 第一个网络爬虫Requests获取网页源代码 直接获取源代码 修改http头获取源代码 爬取python吧首页的源代码 import requests html = requests.get('http://tieba.baidu.com/f?ie=utf-8&kw=python') print html.text 单线程爬虫的基本原理：使用requests获取网页源代码，再使用正则表达式匹配出感兴趣的内容。 向网页提取数据Get与Post Get是从服务器上获取数据 Post是向服务器传送数据 Get通过构造url中的参数来实现功能 分析目标网站 网站地址：https://www.crowdfunder.com/browse/deals 分析工具：Chrome-审核元素-Network Requests表单提交功能 核心方法：Requests.post 核心步骤：构造表单-提交表单-获取返回信息]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jeklly+Github pages 添加评论]]></title>
    <url>%2F2016%2F09%2F24%2Fjeklly%2BGithub%20pages%20%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[之前的个人博客主要是fork了其他人的源码。基于Jekyll+Github pages。在此基础上改了一些东西，适合自己的才是最好的嘛。最后才准备做评论这方面的东西。 disqus先去http://www.disqus.com/注册了username，修改了相关了html文件。讲道理是可以用的，评论框在文章页面一直加载不出来，过一会又会出现reload。我是在科学上网啊，讲道理不应该。作为一个二把手又看了一遍源码，什么也没看出来。只好放弃disqus。 多说这个就算不科学上网也该可以了吧。先去注册搞到了username，http://duoshuo.com再根据源码，添加多说评论。 comments_provider: duoshuoduoshuo_username: x-nicolo再根据多说给的代码粘贴到模板代码里： &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;请将此处替换成文章在你的站点中的ID&quot; data-title=&quot;请替换成文章的标题&quot; data-url=&quot;请替换成文章的网址&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&quot;x-nicolo&quot;}; (function() { var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; 这样就可以了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>多说</tag>
        <tag>disqus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫入门（一）：轻量级爬虫]]></title>
    <url>%2F2016%2F09%2F24%2F%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[今天下雨，下午没课，适合学习。(●’◡’●) 1.爬虫简介 爬虫：一段自动抓取互联网信息的程序 价值：互联网数据，为我所用！新闻聚合阅读器、最爆笑故事APP、图书价格对比网、Python技术文章大全 2.简单爬虫架构简单爬虫架构-运行流程 调度器-&gt;URL管理器-&gt;下载器-&gt;解析器-&gt;应用 3.URL管理器URL管理器：管理待抓取URL集合和已抓取URL集合防止重复抓取、防止循环抓取 实现方式 1.内存 Python内存 待爬取URL集合：set() 已爬取URL集合：set() 2.关系数据库 MySQL urls(url, is_crawled) 3.缓存数据库 redis 待爬取URL集合：set 已爬取URL集合：set 其中，内存适合个人，缓存数据库适合大型公司。 ### 4.网页下载器（urllib2）[核心组件]() - 网页下载器：将互联网上URL对应的网页下载到本地的工具。 - Python有那几种网页下载器？ - 1.Python官方基础模块：urllib2 2.第三方包更强大：requests 网页下载器-urllib2 urllib2下载网页方法1：最简洁方法 url-&gt;urllib2.urlopen(url) 对应代码： import urllib2 #直接请求 response = urllib2.urlopen('http://www.baidu.com') #获取状态码，如果是200表示获取成功 print response.getcode() #读取内容 cont = response.read() urllib2下载网页方法2：添加data、http header url&amp;data&amp;header-&gt;urllib2.Request-&gt;urllib2.urlopen(request) 对应代码： import urllib2 #创建Request对象 request = urllib2.Request(url) #添加数据，向服务器提交用户数据，比如提交a这个数据的值为1 request.add_data('a','1') #添加http的header，http头信息。这里将爬虫伪装成一个Mozilla的浏览器。 request.add_header('User-Agent','Mozilla/5.0') #发送请求获取结果 response = urllib2.urlopen(request) - urllib2下载网页方法3：添加特殊情景的处理器 例如： - 某些需要登录信息的网页，可以用 HTTPCookieProcessor - 某些需要代理才能访问的网页，可以用ProxyHandler - 某些使用了加密协议，可以用HTTPSHandler - 网页URL相互自动跳转关系，使用HTTPRedirectHandler 将这些Handler传送给opener = urllib2.build_opener(handler),再传送给urllib2.install_opener(opener),最后->urllib2.urlopen(url) urllib2.urlopen(request) *对应代码：* import urllib2, cookielib #创建cookie容器,存储cookie数据 cj = cookielib.CookieJar() #创建1个opener opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj)) #给urllib2安装opener urllib2.install_opener(opener) #使用带有cookie的urllib2访问网页 response = urllib2.urlopen("http://www.baidu.com/")]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn Python The Hard Way]]></title>
    <url>%2F2016%2F09%2F19%2FLearn%20Python%20The%20Hard%20Way%2F</url>
    <content type="text"><![CDATA[最后我要说的是学习创造软件的过程会改变你而让你与众不同。 不是说更好或更坏，只是不同了。 你也许会发现因为你会写软件而人们对你的态度有些怪异，也许会用“怪人”这样的词来形容你。 也许你会发现因为你会戳穿他们的逻辑漏洞而他们开始讨厌和你争辩。 甚至你可能会发现有人因为你懂得计算机怎么工作而觉得你是个讨厌的怪人。 对于这些我只有一个建议: 让他们去死吧。 这个世界需要更多的怪人，他们知道东西是怎么工作的而且喜欢找到答案。 当他们那样对你时，只要记住这是你的旅程，不是他们的。 “与众不同”不是谁的错，告诉你“与众不同是一种错”的人只是嫉妒你掌握了他们做梦都不能想到的技能而已。 你会编程。他们不会。这真他妈的酷。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周末]]></title>
    <url>%2F2016%2F09%2F11%2F%E5%91%A8%E6%9C%AB%2F</url>
    <content type="text"><![CDATA[第一个闲暇的周末周五下午到晚上一直在上课，感冒也越来越严重。 昏昏沉沉的听了半天课。晚上回到宿舍突然特别想吃泡面，然后就在00：20吃了一桶泡面加一根肠。 刷了会手机，昏昏沉沉的睡着了。 周六早上一觉睡到自然醒，起来才发现宿舍停水了。 那么这就更有一个理由，可以继续躺着了。 打开网易云音乐，躺着挺尸。 等到水来了赶紧洗漱，完了去吃早午饭。 晚上有约。 陌生的好朋自远方来，不亦乐乎。 周日突然就特别想学习。 早上起来就开始看书撸代码。 带上耳机，选择后摇-代码必备。 泡一杯茶，整整一天也是蛮充实的。晚上准备再去跑个步。 感冒真的是个烦人的小妖精。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生病</tag>
        <tag>聚餐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开学典礼]]></title>
    <url>%2F2016%2F09%2F02%2F%E5%BC%80%E5%AD%A6%E5%85%B8%E7%A4%BC%2F</url>
    <content type="text"><![CDATA[压力感觉周围人技能都10000+！ 这也给了自己一个好的气氛，毕竟之前在科协里呆过才明白，优秀的人总是集中在一起的。（捂脸） 回忆四年前大一开学那会有一个学习经验交流会，科协的一个学姐作为代表发言，雷厉风行。 讲述他们刷比赛的通宵达旦，让我羡慕不已。 感觉那会全院七八百多人都想加入科协，而纳新只招50人。 可是事实证明大家也就只是一时头脑发热，事后也就忘到脑后。 后来又听了朱虹老师的一次比赛动员会，真心燃了。 我认真了。一定要加入它！ 后来加入科协，开始做一些小的科技作品，感觉很有成就感。 再后来参加院里的一些小比赛，拿到奖状的时候欣喜若狂。 再再后来，参加省级电子设计大赛，参加全国电子设计打算，也获得让自己满意成绩。 真心觉得科协改变了我。热爱大集体的感觉，热爱向上的感觉。 遇到过困难，想到过放弃，但是还是坚持到最后。 再后来，大三进来科协的主席团，担任主席。 许多人可能觉得会累吧，是累，真累。 但是你热爱一个事物，是会拿出自己的热心与热情去为她奉献。 以后的事有吃苦耐劳的精神，也要有家国情怀。 希望三年里能充分利用时间，认真学习些有用的东西。 越来越觉得自己是一个唯物主义者。 务实才是根本，花架子是招不住的。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>学校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新开始]]></title>
    <url>%2F2016%2F08%2F29%2F%E6%96%B0%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[开学前几天和小伙伴们又聚了一次，玩到半夜。 体会就是工作了的其实还是比较累的。 开学ing和大学新生一样，各种地方跑着办手续，买东西。 工科学校的典型代表。 到了一个新环境，其实并不陌生。当初一心一意想考的这个学校，学这个专业。但你拼劲全力进来后才发现也就那样。不过一切都是新的，一切都要重新开始，上帝又要洗牌发牌了。 “西军电”学校一般都是一个尿性。 感觉习惯了理工大的默默无闻，与世无争。知行网还是可以反映一些生活学习等方面的问题，也可以得到有效的解决。学校领导层和教师学生们直接也可以很好的交流沟通。 但是西电不一样。西电，旧称西军电，是一所军校。可能是一直保留着军校的传统。很多规定就是规定，不容你去挑战。 比如，洗澡时间就是下午五点半到晚上八点半！你晚上想去跑步，回来澡堂就关门了。这个规定听说已经持续很久，澡堂设备也被吐槽万分。后勤部被投诉多次也无果。这确实很军校。 一年体检三次还是死规定。 三月份考研复试在西电体检一次。六月份本科毕业在理工大体检一次。现在九月份开学又要在西电体检一次。 抽血空槽了。 Anyway,I’m coming.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>学校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016上半年书单]]></title>
    <url>%2F2016%2F08%2F26%2F2016%E4%B8%8A%E5%8D%8A%E5%B9%B4%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[毛铭基&amp;傅真 《藏地白皮书》 《最好金龟换酒》 《泛若不系之舟》 毛姆 《月亮与六便士》 圣埃克苏佩里 《小王子》 吴军 《数学之美》 《浪潮之巅》 CodingBook Learn Python the hard way 教科书还是国外的比较搞笑，国内大多过于死板。 宗教，信仰 其中傅真夫妇的三本游记确实写的令人向往。 在旅行中产生爱情，发现新世界。 Gap year确实也是一个富有激情的生活方式。 后来又看了已经封杀的张昕宇&amp;梁红夫妇《侣行》1，2，3季。 大多数的环球旅行，除了大自然鬼斧神工的美景，还有就是宗教与信仰。 后者在这两对夫妇的书中和纪录片中尤为突出。 人可以没有宗教，但是一定要有信仰。 现实，理想 第一次读毛姆的书。 觉得不仅仅是具有艺术理想的画家具有特立独行的人生观价值观。 而是每个人都该一样。人人生而平等，人人生而自由。 既然我们最后的下场都是一样的，在此之前去做自己喜欢的事吧。 生活本来就不易，又显的理想有多么重要。 在登上一个小小的山丘上时，短暂的迷茫或许是必须的。 这时需要找准以后的方向，keep hungry 才能不断前进。 即便看见地上残酷的六便士，也要常常仰头看看远方的月亮。 说实话，第一遍看小王子并没有看懂。 与其说是没有看懂，还不如说没有理解其中对于成年人来讲更为深刻的含义。 所以读了两遍。 不安现状的唯一办法就是打破现状，一次次去尝试改变。 去刷新自己的三观，扩大三观的容忍度。 见的鸟儿多了，再大的林子也待得下。 现在，未来 吴军的两本书可以培养理科思维和认识计算机互联网时代变迁。 后者更加说明一切皆有可能，前提是必须具有更为宽广的视野。 希望自己能搭上互联网时代的浪潮。 小时候想当科学家，到了大学发现自己可能是架基站的工程师。 马上读研又发现自己是CS码农。 Life is like a box of chocolate. You never know what you’re gonna get.]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择比努力更重要]]></title>
    <url>%2F2016%2F05%2F08%2F%E9%80%89%E6%8B%A9%E6%AF%94%E5%8A%AA%E5%8A%9B%E9%87%8D%E8%A6%81%2F</url>
    <content type="text"><![CDATA[生活是一场修行，从来没有人能逃脱。 回顾一年来的跌宕起伏，只能用《赛末点》里的一句话来总结： 如果有人相信运气，那么他一定参透了人生。 从开始决定考研的2015年3月份，到复试完了的2016年3月份，一切都像绷紧了的弦，目标就是一发即中。最后考取了西安电子科技大学的电子与通信工程专业。到现在才能静下心来总结，也是为了给学弟学妹留下些经验。 首先我要承认我不是学霸，不会在这里给大家介绍所谓的学习经验，网上的各类神经验贴都会比我写的好。刚开始的复习也是三天打鱼，两天晒网。一方面大三的专业课程比较重要也比较多，另一方面科协各种事情还得去筹办。和大部分人一样，最早开始复习的时候是没有明确的院校目标。一是不了解自身的实力，二是不了解想要考取院校的实际招生情况，只能边复习边给自己定位。我的专业是通信工程。通信工程专业考研全国最热门的就是“两电一邮”。地理就近原则我便去了解了下西电，才知道信息不对等是多么的可怕。虽然你看到每年的复试线都不是很高，但是当你看到最终的录取名单的时候，一切你都会明白，那只是一个富有深意的复试线。整个西电通院的考取名额大概有650个，除去保研优研，每年剩下给统考的名额已经寥寥无几。择优而录的原则使实际的统考录取分数线很高。这些信息只有自己去深入了解才能知己知彼。有许多人就是要么自身定位不准，导致考研失败，要么就是信息获取缺失，导致你分数考的再高也没用，因为老师没有了名额一切都是白搭。 于是就像许多人一样，每天都是复习又复习，稀里糊涂到了6月份。我认为照我这样复习下去，西电根本就希望渺茫。只能选择其他院校或者直接放弃考研。一个偶然的机会，在西电的高中同学告诉我西电有个优研计划要我去参加，过了优研只需考研分数线过了国家线就可以录取。这个优研我以前也听过，好像本科不是211，也不是985，基本上希望等于零。同学知道我在大学期间喜欢参加各类比赛，说是有一个竞赛类的要求符合也可参加，于是我仔细研读了去年的优研计划文件。我有电赛省赛的一个二等奖，还有一个专利。觉得还是去试试比较好。在正式放暑假的最后一个工作日才去打印了成绩单，在网上申请了西电两个院的优研。之后又去了解了许多优研的情况,内心越来越觉得机会来了。 接下来就是漫无边际的等待。暑假里复习也基本停止了，两个月基本上也全部花费在全国大学生电子设计大赛。许多人可能不理解，已经决定考研了为什么还要去浪费时间在这些比赛上，我想大概是因为热爱吧。这次电赛的成绩其实已经和我考研没什么关系，如果有，那也是在考研复试的面试中，那时候说这些都是后话。我一直都觉得做人做事不能太功利化，现在的努力都是给未来在铺垫道路。又有谁会知道之前的比赛成绩会是自己能优研的考研捷径？ 暑假期间学院的优研资格审查出来了，两个院都过了。电赛的成绩也出来了，省一等奖，这样就可以参加国赛。一边在准备电赛的国赛，一边还要准备西电网信院的优研考试。参加过的两年电赛评测场地都在西电新校区，在决定考西电的那个暑假的那种心情简直太神奇了。在西电新校区参加完电赛国赛的三天后，以基本裸考的状态又去西电参加了网信院的考试，还好考试很重视基础也比较简单。整个暑假的结果是电赛拿到了国二的成绩，网信院的优研也过了。电赛国赛二等奖奖，按照理所当然的规定那就是我有了保研名额。但是按照本校特色，本专业老师的特色，不能外保，只能内保，做了一小会的思想斗争，我放弃了。我还装模作样的签了一个“自愿”放弃免试资格（保研），只能有一条路就是考研。 九月份开始，开始正式加入复习大军。很久没有复习，基本上也忘得差不多，一切都从零开始。到了十月份通院的优研正式结果也出来了，很幸运的也过了。最后选择了西电的通院，接下来就是好好复习通过国家线就好了。 不过也是巧，也许只有我一个人的话，我也无法坚持，一直以来都是和几个优研的小伙伴在一起复习。几个人一起努力总比一个人的努力幸福的多。从九月到十二月，教六的考研自习室都是正襟危坐学习的人，考研和高考还是不一样的，高考是普通人不可避免的随波逐流，但考研是长大后的自己主动选择迎难而上，考研就像一个人单枪匹马去上战场，考研比高考更了不起。 之后的复习就是早出晚归，要拿得出定力，找工作的同学一个个的都拿到了心仪的offer，只有考研的同学还得夜以继日，前面的路到底如何，谁也谁不清楚，只有再多做一道题，再多看一会书才能安慰下浮躁的心。就这样一直复习到考试前。考试完后对自己的成绩也大概有个了解，考的比较差，应该在去年的国家线附近。心里真的是五味杂陈。 考研是比高考更残酷的选拔性考试，我们都戏说考研就是竞赛，没有基础题，没有送分题。要不是大学里还做了点有用的事情，拿不到优研资格，我基本上也就告别考研了。等国家线的日子是一个内心煎熬的过程。人心惶惶的等到了国家线，出人意料的工科分数线大降，我也算是擦线而过。如果有幸福的话，它总是和绝望紧密相连。 考研不仅是拼实力，运气成分也占很大的比重，一定要以乐观的心态去面对所要发生的一切。真正的勇敢不是不怕被打倒，而是你恐惧你害怕，但你依然选择了往前走。之后的复试也开始认真的准备，后面的都比较顺利，就是心太累。此刻的我意识到最重要的道理——确知自己拥有的能力和机会，并使之得到最好的发挥。 所以选择比努力更重要，不管任何时刻，一定要把自己想要做的事情做好，你不会知道你现在的努力会对你的未来产生何种影响。但至少，一定是好的影响。我身边不乏有许多学霸在这次考研里败北。原因有的是运气不佳，有的是从一开始就没有给自己定好位。我算是一路走来比较幸运的，心态也比较好。复习的时候，很在状态，很喜欢，也很鼓励；不留后路，不遥远，也不迷茫。 一年来理解最深刻的道理其实都最简单，最简单的道理只有自己去实践才会发现它本身蕴含的价值： 锲而不舍,金石可镂。坚持到底的受益远远大于考研这件事本身。 不要对还未发生的事情而产生顾虑和烦恼，学会制定B计划。 永远都要对自己有信心，不要妄自菲薄，要敢去尝试。 早起的鸟儿有虫吃，有想法就要尽早去实现，机会不等人。 毕业之际，其实还是比较想念教六毫无生气的考研自习室和枯燥无味的书本。我比较庆幸自己在大学里参加了科协，只有真正喜欢的东西才能坚持下来。由此参加了那些大大小小的比赛，真心喜欢并且坚持去做，认识了许多志同道合的朋友，实验室里确实少了许多大学里应该有的色彩斑斓，但是也学习了许多受益终身的知识和道理。最后想到一段话分享给大家： 也许你们从来都无法融入学校 也许你是学校里最矮的，最胖的 或者最古怪的孩子 也许你们没有朋友 这没什么 当你们总是一个人独处 制造计算机或者练习大提琴 你在做的其实是变得更有趣 当人们终于注意到你的时候 他们会发现 你比他们想的要酷的多 ——莱纳德·李奇·霍夫斯塔特《生活大爆炸》 后记这是大四下学期考研复试结束后应科协之邀，写的文章。 也算是对自己一年的考研之路的总结。 共勉。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>旧事</tag>
      </tags>
  </entry>
</search>
